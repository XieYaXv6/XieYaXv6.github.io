<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="小本本"><meta name="keywords" content=""><meta name="author" content="XYX"><meta name="copyright" content="XYX"><title>小本本 | XYX's Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?42b25629bbf1fae4313b2d989bcab163";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="XYX's Blog" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#居中"><span class="toc-number">1.</span> <span class="toc-text">居中</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#垂直居中"><span class="toc-number">1.1.</span> <span class="toc-text">垂直居中</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#水平居中"><span class="toc-number">1.2.</span> <span class="toc-text">水平居中</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#跨域"><span class="toc-number">2.</span> <span class="toc-text">跨域</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-JSONP-跨域"><span class="toc-number">2.1.</span> <span class="toc-text">1. JSONP 跨域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-CORS-跨域资源共享"><span class="toc-number">2.2.</span> <span class="toc-text">2. CORS 跨域资源共享</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#webpack"><span class="toc-number">2.3.</span> <span class="toc-text">webpack</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP-与-UDP"><span class="toc-number">3.</span> <span class="toc-text">TCP 与 UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#区别"><span class="toc-number">3.1.</span> <span class="toc-text">区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-三次握手"><span class="toc-number">3.2.</span> <span class="toc-text">TCP 三次握手</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四次挥手"><span class="toc-number">3.3.</span> <span class="toc-text">四次挥手</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#http-和-https"><span class="toc-number">4.</span> <span class="toc-text">http 和 https</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-与-HTTPS-有什么区别？"><span class="toc-number">4.1.</span> <span class="toc-text">HTTP 与 HTTPS 有什么区别？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#两边固定中间自适应的布局"><span class="toc-number">5.</span> <span class="toc-text">两边固定中间自适应的布局</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#输入-url-地址按下回车会发生什么"><span class="toc-number">6.</span> <span class="toc-text">输入 url 地址按下回车会发生什么</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#type-of-与-instance-of"><span class="toc-number">7.</span> <span class="toc-text">type of 与 instance of</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#回流和重绘"><span class="toc-number">8.</span> <span class="toc-text">回流和重绘</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Session和Cookie的区别"><span class="toc-number">9.</span> <span class="toc-text">Session和Cookie的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#localStorage和sessionStorage区别"><span class="toc-number">9.1.</span> <span class="toc-text">localStorage和sessionStorage区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#token"><span class="toc-number">9.2.</span> <span class="toc-text">token</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">9.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#node中import和require的区别"><span class="toc-number">10.</span> <span class="toc-text">node中import和require的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Mysql"><span class="toc-number">11.</span> <span class="toc-text">Mysql</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#深克隆和浅克隆"><span class="toc-number">12.</span> <span class="toc-text">深克隆和浅克隆</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#微任务和宏任务"><span class="toc-number">13.</span> <span class="toc-text">微任务和宏任务</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#promise和async-await"><span class="toc-number">14.</span> <span class="toc-text">promise和async&#x2F;await</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#promise"><span class="toc-number">14.1.</span> <span class="toc-text">promise</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Async-await"><span class="toc-number">14.2.</span> <span class="toc-text">Async&#x2F;await</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#var-let-const的区别"><span class="toc-number">15.</span> <span class="toc-text">var,let,const的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#flex-flex-1"><span class="toc-number">16.</span> <span class="toc-text">flex&#x2F;flex:1</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue双向绑定原理"><span class="toc-number">17.</span> <span class="toc-text">Vue双向绑定原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue中的虚拟dom及diff算法"><span class="toc-number">18.</span> <span class="toc-text">Vue中的虚拟dom及diff算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#computed和watch的区别"><span class="toc-number">19.</span> <span class="toc-text">computed和watch的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MVC-MVVM"><span class="toc-number">20.</span> <span class="toc-text">MVC&#x2F;MVVM</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#webpack-1"><span class="toc-number">21.</span> <span class="toc-text">webpack</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java和JavaScript"><span class="toc-number">22.</span> <span class="toc-text">Java和JavaScript</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">XYX</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">28</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">29</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">12</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">我的朋友们</div><a class="author-info-links__name text-center" href="https://www.ntutn.top/ &quot;ruiOvO&quot;：https://www.ruiovo.top/" target="_blank" rel="noopener">归零幻想</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://w.wallhaven.cc/full/g7/wallhaven-g75r7d.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">XYX's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">小本本</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-08-09</time><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">6.6k</span><span class="post-meta__separator">|</span><span>阅读时长: 22 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote>
<p>序<br><br>用来记录一些繁杂的东西</p>
</blockquote>
<a id="more"></a>

<h1 id="居中"><a href="#居中" class="headerlink" title="居中"></a>居中</h1><ol>
<li>定位<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">父级开启定位 子级相对定位</span><br><span class="line">top：50%;</span><br><span class="line">left：50%;</span><br><span class="line">transform：translate(-50%,-50%); &#x2F;&#x2F;自身的一半</span><br></pre></td></tr></table></figure></li>
<li>flex<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">父容器</span><br><span class="line">display:flex;</span><br><span class="line">justify-content:center; 主轴分配空白</span><br><span class="line">align-item:center; 辅轴分配空白</span><br></pre></td></tr></table></figure></li>
<li>table-cell<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">父容器</span><br><span class="line">display:table-cell;</span><br><span class="line">vertical-align:middle;</span><br><span class="line">text-align:center;</span><br><span class="line">&#x2F;*父容器必须指定宽高 *&#x2F;</span><br><span class="line">height:500px;</span><br><span class="line">width:500px;</span><br><span class="line">子元素</span><br><span class="line">display:inline-block;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h2><ol>
<li>通过 verticle-align:middle 实现</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">display: inline-block;</span><br><span class="line">vertical-align:middle;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>通过 display:flex 实现</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父元素display:flex;</span><br><span class="line">子元素align-self:center;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>通过 display:table-cell 实现</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父元素display:table;</span><br><span class="line">子元素display：table-cell;</span><br></pre></td></tr></table></figure>

<h2 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h2><ol>
<li><p>通过 margin: 0 auto; text-align: center 实现</p>
</li>
<li><p>通过 display:flex 实现</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">父元素display:flex;</span><br><span class="line">     flex-direction:column;</span><br><span class="line">子元素align-self:center;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>通过 width:fit-content 实现</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">width:fit-content;</span><br><span class="line">margin: 0 auto ;</span><br><span class="line">text-align: center;</span><br></pre></td></tr></table></figure>

<h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><ul>
<li><p>跨域是指一个域下的文档或脚本试图去请求另一个域下的资源。</p>
<h2 id="1-JSONP-跨域"><a href="#1-JSONP-跨域" class="headerlink" title="1. JSONP 跨域"></a>1. JSONP 跨域</h2></li>
<li><p>jsonp 的原理就是利用&lt;script&gt;标签没有跨域限制，通过&lt;script&gt;标签 src 属性，发送带有 callback 参数的 GET 请求，服务端将接口返回数据拼凑到 callback 函数中，返回给浏览器，浏览器解析执行，从而前端拿到 callback 函数返回的数据。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> &lt;script&gt;</span><br><span class="line">    var script &#x3D; document.createElement(&#39;script&#39;);</span><br><span class="line">    script.type &#x3D; &#39;text&#x2F;javascript&#39;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数</span><br><span class="line">    script.src &#x3D; &#39;http:&#x2F;&#x2F;www.domain2.com:8080&#x2F;login?user&#x3D;admin&amp;callback&#x3D;handleCallback&#39;;</span><br><span class="line">    document.head.appendChild(script);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 回调执行函数</span><br><span class="line">    function handleCallback(res) &#123;</span><br><span class="line">        alert(JSON.stringify(res));</span><br><span class="line">    &#125;</span><br><span class="line"> &lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">handleCallback(&#123;&quot;success&quot;: true, &quot;user&quot;: &quot;admin&quot;&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="2-CORS-跨域资源共享"><a href="#2-CORS-跨域资源共享" class="headerlink" title="2. CORS 跨域资源共享"></a>2. CORS 跨域资源共享</h2><ul>
<li>普通跨域请求：只服务端设置 Access-Control-Allow-Origin 即可，前端无须设置，若要带 cookie 请求：前后端都需要设置</li>
<li>跨域到哪个服务器就在哪个服务器上配置响应头<br><img src="/2020/08/09/%E5%B0%8F%E6%9C%AC%E6%9C%AC/cors.png" alt><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var xhr &#x3D; new XMLHttpRequest(); &#x2F;&#x2F; IE8&#x2F;9需用window.XDomainRequest兼容</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 前端设置是否带cookie</span><br><span class="line">xhr.withCredentials &#x3D; true;</span><br><span class="line"></span><br><span class="line">xhr.open(&#39;post&#39;, &#39;http:&#x2F;&#x2F;www.domain2.com:8080&#x2F;login&#39;, true);</span><br><span class="line">xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application&#x2F;x-www-form-urlencoded&#39;);</span><br><span class="line">xhr.send(&#39;user&#x3D;admin&#39;);</span><br><span class="line"></span><br><span class="line">xhr.onreadystatechange &#x3D; function() &#123;</span><br><span class="line">    if (xhr.readyState &#x3D;&#x3D; 4 &amp;&amp; xhr.status &#x3D;&#x3D; 200) &#123;</span><br><span class="line">        alert(xhr.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><ul>
<li>利用 node + webpack + webpack-devserver 代理接口跨域。在开发环境下，由于 vue 渲染服务和接口代理服务都是 webpack-dev-server 同一个，所以页面与代理接口之间不再跨域，无须设置 headers 跨域信息了。</li>
<li>不写请求的基础地址都是默认向本地址请求资源，在webpack加proxy配置代理目标的基础路径，就会把请求都代理到目标接口<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    entry: &#123;&#125;,</span><br><span class="line">    module: &#123;&#125;,</span><br><span class="line">    ...</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        historyApiFallback: true,</span><br><span class="line">        proxy: [&#123;</span><br><span class="line">            context: &#39;&#x2F;login&#39;,</span><br><span class="line">            target: &#39;http:&#x2F;&#x2F;www.domain2.com:8080&#39;,  &#x2F;&#x2F; 代理跨域目标接口</span><br><span class="line">            changeOrigin: true,</span><br><span class="line">            cookieDomainRewrite: &#39;www.domain1.com&#39;  &#x2F;&#x2F; 可以为false，表示不修改</span><br><span class="line">        &#125;],</span><br><span class="line">        noInfo: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="TCP-与-UDP"><a href="#TCP-与-UDP" class="headerlink" title="TCP 与 UDP"></a>TCP 与 UDP</h1><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ol>
<li>TCP 面向连接（如打电话要先拨号建立连接）;UDP 是无连接的，即发送数据之前不需要建立连接</li>
<li>TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP 尽最大努力交付，即不保证可靠交付</li>
<li>TCP 面向字节流，实际上是 TCP 把数据看成一连串无结构的字节流;UDP 是面向报文的，UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 IP 电话，实时视频会议等）</li>
<li>每一条 TCP 连接只能是点到点的;UDP 支持一对一，一对多，多对一和多对多的交互通信</li>
<li>TCP 首部开销 20 字节;UDP 的首部开销小，只有 8 个字节</li>
<li>TCP 的逻辑通信信道是全双工的可靠信道，UDP 则是不可靠信道</li>
</ol>
<h2 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h2><ul>
<li>第一次握手<ul>
<li>客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。</li>
</ul>
</li>
<li>第二次握手<ul>
<li>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。</li>
</ul>
</li>
<li>第三次握手<ul>
<li>当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。</li>
</ul>
</li>
</ul>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><ul>
<li>第一次挥手<ul>
<li>客户端发送一个FIN=M，用来关闭客户端到服务器端的数据传送，客户端进入FIN_WAIT_1状态。意思是说”我客户端没有数据要发给你了”，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。</li>
</ul>
</li>
<li>第二次挥手<ul>
<li>服务器端收到FIN后，先发送ack=M+1，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息。这个时候客户端就进入FIN_WAIT_2 状态，继续等待服务器端的FIN报文。</li>
</ul>
</li>
<li>第三次挥手<ul>
<li>当服务器端确定数据已发送完成，则向客户端发送FIN=N报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入LAST_ACK状态。</li>
</ul>
</li>
<li>第四次挥手<ul>
<li>客户端收到FIN=N报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送ack=N+1后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。服务器端收到ACK后，就知道可以断开连接了。客户端等待了2MSL后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次握手。</li>
</ul>
</li>
</ul>
<h1 id="http-和-https"><a href="#http-和-https" class="headerlink" title="http 和 https"></a>http 和 https</h1><ul>
<li>HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</li>
<li>HTTPS：是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版，即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。</li>
<li>HTTPS 协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</li>
</ul>
<h2 id="HTTP-与-HTTPS-有什么区别？"><a href="#HTTP-与-HTTPS-有什么区别？" class="headerlink" title="HTTP 与 HTTPS 有什么区别？"></a>HTTP 与 HTTPS 有什么区别？</h2><ul>
<li>HTTP 协议传输的数据都是未加密的，也就是明文的，因此使用 HTTP 协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了 SSL（Secure Sockets Layer）协议用于对 HTTP 协议传输的数据进行加密，从而就诞生了 HTTPS。简单来说，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 http 协议安全。</li>
</ul>
<h1 id="两边固定中间自适应的布局"><a href="#两边固定中间自适应的布局" class="headerlink" title="两边固定中间自适应的布局"></a>两边固定中间自适应的布局</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">float实现：</span><br><span class="line">&lt;div style&#x3D;&quot;width:100%; margin:0 auto;&quot;&gt;</span><br><span class="line"></span><br><span class="line">       &lt;div style&#x3D;&quot;width:200px; float:right; background-color:#960&quot;&gt;这是右侧的内容 固定宽度&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">       &lt;div style&#x3D;&quot;width:150px; float:left; background:#6FF&quot;&gt;这是左侧的内容 固定宽度&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">       &lt;div style&#x3D;&quot;margin-left:150px;margin-right:200px; background-color:#9F3&quot;&gt;中间内容，自适应宽度&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">flex实现</span><br><span class="line">.box &#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 200px;</span><br><span class="line">    display: flex;</span><br><span class="line">&#125;</span><br><span class="line">.left, .right &#123;</span><br><span class="line">    width: 20px;</span><br><span class="line">    background:  #090;</span><br><span class="line">&#125;</span><br><span class="line">.middle &#123;</span><br><span class="line">    flex: 1;</span><br><span class="line">    background: #f00;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div class&#x3D;&quot;box&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;left&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;middle&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;right&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<h1 id="输入-url-地址按下回车会发生什么"><a href="#输入-url-地址按下回车会发生什么" class="headerlink" title="输入 url 地址按下回车会发生什么"></a>输入 url 地址按下回车会发生什么</h1><p>1.输入 url 地址后，首先进行 DNS 解析，将相应的域名解析为 IP 地址； 2.客户端根据 IP 地址去寻找相应的服务器； 3.与服务器进行 TCP 的三次握手；</p>
<ul>
<li><p>所谓三次握手就是客户端在请求与服务器相连接时，彼此共计发送了三次数据包，就好比以下的对话：<br>_ 首先，需要明确的是，三次握手是客户端先发起请求。<br>_ （第一次）客户端：hi，服务器，在吗？我想和你建立连接，你能收到我的消息吗？（此时客户端给服务端发送了一个数据包和发送序号，即 SYN=1，Seq=X）<br>_ （第二次）服务器：hi，客户端，我在呢，我收到你的消息了，我们可以建立连接，你能收到我答复的消息吗？（此时服务端发送 syn+ack 报文，并置发送序号为 Y，再确认序号为 X+1）<br>_ （第三次）客户端：我收到你的答复了，很开心能和你建立连接。（此时客户端发送 ack 报文，并置发送序号为 Z，再确认序号为 Y+1）</p>
<p>4.客户端找到相应的资源库；</p>
<p>5.根据资源库返回页面信息；</p>
<p>6.浏览器根据自身的执行机制解析页面；</p>
<p>7.最后服务器将解析信息返回给客户端，进行TCP的四次挥手</p>
</li>
</ul>
<h1 id="type-of-与-instance-of"><a href="#type-of-与-instance-of" class="headerlink" title="type of 与 instance of"></a>type of 与 instance of</h1><ul>
<li>typeof 是判断参数是什么类型的实例，返回值为说明运算数类型的字符串。<ul>
<li>返回值结果：“number”、“string”、“boolean”、“object”、“function”、“undefined”</li>
<li>若参数为引用类型，始终返回“object”，对于 Array、null 始终返回“object”</li>
</ul>
</li>
<li>instanceof 是用来判断一个对象在其原型链中是否存在一个构造函数的 prototype 属性<ul>
<li>a instanceof b：判断 a 是否为 b 的实例，可以用于继承关系中</li>
</ul>
</li>
</ul>
<h1 id="回流和重绘"><a href="#回流和重绘" class="headerlink" title="回流和重绘"></a>回流和重绘</h1><ul>
<li><p>html 加载时发生了什么</p>
<ul>
<li><p>在页面加载时，浏览器把获取到的HTML代码解析成1个DOM树，DOM树里包含了所有HTML标签，包括display:none隐藏，还有用JS动态添加的元素等。</p>
</li>
<li><p>DOM Tree 和样式结构体 （浏览器把所有样式【用户定义的CSS和用户代理】解析成样式结构体） 组合后构建render tree, render tree类似于DOM tree，但区别很大，因为render tree能识别样式，render tree中每个NODE都有自己的style，而且render tree不包含隐藏的节点(比如display:none的节点，还有head节点)，因为这些节点不会用于呈现，而且不会影响呈现的，所以就不会包含到 render tree中。我自己简单的理解就是DOM Tree和我们写的CSS结合在一起之后，渲染出了render tree。</p>
</li>
</ul>
</li>
<li><p>什么是回流</p>
<ul>
<li>当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候，这时候是一定会发生回流的，因为要构建render tree。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘。</li>
</ul>
</li>
<li><p>什么是重绘</p>
<ul>
<li>当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。</li>
</ul>
</li>
<li><p>区别：</p>
<ol>
<li>回流必将引起重绘，而重绘不一定会引起回流。</li>
</ol>
<ul>
<li>比如：只有颜色改变的时候就只会发生重绘而不会引起回流</li>
</ul>
<ol start="2">
<li>当页面布局和几何属性改变时就需要回流</li>
</ol>
<ul>
<li>比如：添加或者删除可见的DOM元素，元素位置改变，元素尺寸改变——边距、填充、边框、宽度和高度，内容改变</li>
</ul>
</li>
</ul>
<h1 id="Session和Cookie的区别"><a href="#Session和Cookie的区别" class="headerlink" title="Session和Cookie的区别"></a>Session和Cookie的区别</h1><ol>
<li><p>cookie数据存放在客户的浏览器上(客户端),session数据放在服务器上</p>
<ul>
<li><p>cookie不是很安全,别人可以分析存放在本地的cookie并进行cookie 欺骗,如果主要考虑到安全应当使用session</p>
</li>
<li><p>session会在一定时间内保存在服务器上.当访问增多,会比较占用你服务器的性能,如果主要考虑到减轻服务器性能方面,应当使用cookie</p>
</li>
</ul>
</li>
<li><p>单个cookie在客户端的限制是3K,就是说一个站点在客户端存放的cookie不能3K</p>
<ul>
<li>将登陆信息等重要信息存放为session;其他信息如果需要保留,可以放在 cookie 中</li>
</ul>
</li>
<li><p>session不能区分路径,同一个用户在访问一个网站期间,所有的session在任何一个地方都可以访问到.而cookie中如果设置了路径参数,那么同一个网站中不同路径下的cookie互相是访问不到的.cookie只能是子路径访问父路径设置的cookie</p>
</li>
</ol>
<h2 id="localStorage和sessionStorage区别"><a href="#localStorage和sessionStorage区别" class="headerlink" title="localStorage和sessionStorage区别"></a>localStorage和sessionStorage区别</h2><ul>
<li><p>localStorage和sessionStorage一样都是用来存储客户端临时信息的对象。</p>
</li>
<li><p>他们均只能存储字符串类型的对象（虽然规范中可以存储其他原生类型的对象，但是目前为止没有浏览器对其进行实现）。</p>
</li>
<li><p>localStorage生命周期是永久，这意味着除非用户显示在浏览器提供的UI上清除localStorage信息，否则这些信息将永远存在。</p>
</li>
<li><p>sessionStorage生命周期为当前窗口或标签页，一旦窗口或标签页被永久关闭了，那么所有通过sessionStorage存储的数据也就被清空了。</p>
</li>
</ul>
<h2 id="token"><a href="#token" class="headerlink" title="token"></a>token</h2><ul>
<li>token 也称作令牌，由uid+time+sign[+固定参数]</li>
<li>token 的认证方式类似于临时的证书签名, 并且是一种服务端无状态的认证方式, 非常适合于 REST API 的场景. 所谓无状态就是服务端并不会保存身份认证相关的数据。</li>
<li>token在客户端一般存放于localStorage，cookie，或sessionStorage中。在服务器一般存于数据库中</li>
<li>token认证流程<ul>
<li>token 的认证流程与cookie很相似</li>
<li>用户登录，成功后服务器返回Token给客户端。</li>
<li>客户端收到数据后保存在客户端</li>
<li>客户端再次访问服务器，将token放入headers中</li>
<li>服务器端采用filter过滤器校验。校验成功则返回请求数据，校验失败则返回错误码</li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>session存储于服务器，可以理解为一个状态列表，拥有一个唯一识别符号sessionId，通常存放于cookie中。服务器收到cookie后解析出sessionId，再去session列表中查找，才能找到相应session。依赖cookie</li>
<li>cookie类似一个令牌，装有sessionId，存储在客户端，浏览器通常会自动添加。</li>
<li>token也类似一个令牌，无状态，用户信息都被加密到token中，服务器收到token后解密就可知道是哪个用户。需要开发者手动添加。</li>
</ul>
<h1 id="node中import和require的区别"><a href="#node中import和require的区别" class="headerlink" title="node中import和require的区别"></a>node中import和require的区别</h1><ul>
<li>import和require都是被模块化所使用</li>
<li>require是运行时调用，所以require理论上可以运用在代码的任何地方</li>
<li>import是编译时调用，所以必须放在文件开头</li>
</ul>
<h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><p><a href="https://blog.csdn.net/qq_42992643/article/details/82959720" target="_blank" rel="noopener">https://blog.csdn.net/qq_42992643/article/details/82959720</a></p>
<h1 id="深克隆和浅克隆"><a href="#深克隆和浅克隆" class="headerlink" title="深克隆和浅克隆"></a>深克隆和浅克隆</h1><ul>
<li>浅克隆只是改变了指针的指向，没有开辟新的内存空间，改变值后原有的值也会发生改变</li>
<li>深克隆是先把对象转化成json数据JSON.stringify(obj)，然后在解析成对象JSON.parse，完整JSON.parse(JSON.stringify(obj))，是开辟了新的内存空间存数据，改变值后原有值也不变。<strong><em>但是对函数、正则、时间对象、数字对象的时候会不好用,遇到他们时需要特殊处理来过滤</em></strong></li>
</ul>
<h1 id="微任务和宏任务"><a href="#微任务和宏任务" class="headerlink" title="微任务和宏任务"></a>微任务和宏任务</h1><p><img src="/2020/08/09/%E5%B0%8F%E6%9C%AC%E6%9C%AC/%E5%BE%AE%E4%BB%BB%E5%8A%A1%E5%AE%8F%E4%BB%BB%E5%8A%A1.png" alt></p>

<ul>
<li>js是单线程的，浏览器是多线程的</li>
<li>先执行主线程，执行完主线程再执行微任务，最后执行宏任务</li>
<li>宏任务：setTimeout，setInterval，整体代码script，I/O</li>
<li>微任务：Promise，process.nextTick</li>
</ul>
<h1 id="promise和async-await"><a href="#promise和async-await" class="headerlink" title="promise和async/await"></a>promise和async/await</h1><h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><ul>
<li>promice的思想就是每一个异步任务返回一个promise对象，该对象有一个then方法，通过.then()的方法可进行链式调用,允许指定回调函数，Promice的出现大大改善了异步变成的困境，避免出现回调地狱（数作为参数层层嵌套），嵌套层级得到改善。</li>
<li>API<ul>
<li>Promise.resolve()</li>
<li>Promise.reject()</li>
<li>Promise.prototype.then()</li>
<li>Promise.prototype.catch()</li>
<li>Promise.all()  // 所有的完成  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  function promiseDemo () &#123;</span><br><span class="line">    Promise.all([A, B]).then(function (res) &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;A,B</span><br><span class="line">A请求、B请求同时发,两条响应都收到后再执行then</span><br></pre></td></tr></table></figure></li>
<li>Promise.race() // 竞速，完成一个即执行then  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function promiseDemo () &#123;</span><br><span class="line">    Promise.race([A, B]).then(function (res) &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Async-await"><a href="#Async-await" class="headerlink" title="Async/await"></a>Async/await</h2></li>
</ul>
</li>
<li>Async/await建立于Promise之上</li>
<li>async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖</li>
<li>如果要实现并发多个请求，可以把函数存到数组中，在调用array.map实现</li>
</ul>
<h1 id="var-let-const的区别"><a href="#var-let-const的区别" class="headerlink" title="var,let,const的区别"></a>var,let,const的区别</h1><ul>
<li>var声明变量存在变量提升，let/const不存在</li>
<li>var不存在块级作用域。let和const存在块级作用域，顾名思义，就是只在当前代码块起作用</li>
<li>var允许重复声明变量，后一个变量会覆盖前一个变量。let和const在同一作用域不允许重复声明变量，会报错（正常情况下三者都不能重复声明变量，但是编译器会忽略重复声明的var，所以var可以）</li>
<li>const/let大部分特性一样，不同的是：<ul>
<li>const声明时必须赋值且只能赋值一次，不能修改</li>
<li>如果const声明的是复合类型数据，可以修改其属性</li>
</ul>
</li>
</ul>
<h1 id="flex-flex-1"><a href="#flex-flex-1" class="headerlink" title="flex/flex:1"></a>flex/flex:1</h1><ul>
<li>flex属性= flex-grow(放大) + flex-shrink(缩小) + flex-basis(基础)</li>
<li>flex：1实际是flex-grow:1表示父元素有剩余空间时是否放大</li>
</ul>
<h1 id="Vue双向绑定原理"><a href="#Vue双向绑定原理" class="headerlink" title="Vue双向绑定原理"></a>Vue双向绑定原理</h1><ul>
<li>VUE的双向绑定通过数据劫持结合发布者-订阅者模式的方式来实现</li>
<li>利用object.defineProperty（）重写对象的set方法和get方法。通过这两种方法对data中的数据进行监控，当修改数据值时，触发set；当访问数据值时，触发get。</li>
<li>监控数据变化是为了更新页面，更新变化数据对应的DOM节点</li>
<li>完成上述要求需要底层虚拟DOM的支持</li>
<li>vue3中用proxy来监听数据，只需要监听对象，对象中的属性发生改变自动捕获。</li>
</ul>
<h1 id="Vue中的虚拟dom及diff算法"><a href="#Vue中的虚拟dom及diff算法" class="headerlink" title="Vue中的虚拟dom及diff算法"></a>Vue中的虚拟dom及diff算法</h1><ul>
<li>vue2引入了虚拟dom，渲染速度比vue1提高了2-4倍，而且大大降低了内存消耗</li>
<li>模板转换成视图的过程<ol>
<li>将模板编译转换成渲染函数，执行渲染函数得到一个虚拟节点树</li>
<li>对数据进行操作的时候，会触发监听函数，然后watch对象会将新旧虚拟节点进行对比，然后根据对比结果进行dom操作来更新视图</li>
</ol>
<ul>
<li>简单点讲，在Vue的底层实现上，Vue将模板编译成虚拟DOM渲染函数。在状态改变时，Vue能够智能地计算出重新渲染组件的最小代价并应到DOM操作上<br><img src="/2020/08/09/%E5%B0%8F%E6%9C%AC%E6%9C%AC/%E8%99%9A%E6%8B%9Fdom.jpg" alt></li>
</ul>
</li>
<li>概念：<ol>
<li>渲染函数：渲染函数是用来生成Virtual DOM的。Vue推荐使用模板来构建我们的应用界面，在底层实现中Vue会将模板编译成渲染函数</li>
<li>VNode 虚拟节点：它可以代表一个真实的 dom 节点。通过 createElement 方法能将 VNode 渲染成 dom 节点。简单地说，vnode可以理解成节点描述对象，它描述了应该怎样去创建真实的DOM节点</li>
<li>patch(也叫做patching算法)：虚拟DOM最核心的部分，它可以将vnode渲染成真实的DOM，这个过程是对比新旧虚拟节点之间有哪些不同，然后根据对比结果找出需要更新的的节点进行更新。这点我们从单词含义就可以看出， patch本身就有补丁、修补的意思，其实际作用是在现有DOM上进行修改来实现更新视图的目的。</li>
</ol>
</li>
<li>虚拟dom是什么？<ul>
<li>虚拟dom是一颗以js对象（VNode节点）为基础的树，用对象属性来描述节点。它实际上是对真实dom的抽象，最后通过一系列操作可以使这棵树映射到真实环境上。虚拟dom就相当于缓存，介于cpu（JS）和硬盘（dom）之间,js只操作虚拟dom，最后再把变更的地方写入真实dom中。</li>
<li>虚拟dom的最终目标是将虚拟节点渲染到视图上，如果直接用虚拟节点覆盖旧节点，会有很多不必要的dom操作，为了避免这种情况，虚拟dom在虚拟节点映射到视图的过程中，将虚拟节点与上一次的旧虚拟节点做对比，找到需要更新的节点进行dom操作，从而避免不必要的操作。</li>
<li>其实虚拟DOM在Vue.js主要做了两件事：<ol>
<li>提供与真实DOM节点所对应的虚拟节点vnode</li>
<li>将虚拟节点vnode和旧虚拟节点oldVnode进行对比，然后更新视图</li>
</ol>
</li>
<li>模板 → 渲染函数 → 虚拟DOM树 → 真实DOM</li>
</ul>
</li>
<li>diff算法<ul>
<li>为了实现高效的DOM操作，一套高效的虚拟DOM diff算法显得很有必要。我们通过patch 的核心—-diff 算法，找出本次DOM需要更新的节点来更新，其他的不更新。思想是仅在同级的vnode间做diff，递归地进行同级vnode的diff，最终实现整个DOM树的更新。</li>
<li>diff 算法包括几个步骤：<ol>
<li>用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中</li>
<li>当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异</li>
<li>把所记录的差异应用到所构建的真正的DOM树上，视图就更新了</li>
</ol>
</li>
</ul>
</li>
</ul>
<h1 id="computed和watch的区别"><a href="#computed和watch的区别" class="headerlink" title="computed和watch的区别"></a>computed和watch的区别</h1><ul>
<li>computed是用于定义基于数据之上的数据；并且computed是有缓存的，在数据还没有变化时访问时，计算属性会立即返回缓存中之前计算的结果。</li>
<li>watch是在某个数据变化时做一些事情，可以是调用函数，也可以像computed返回数据，而且监听的是一个参数，而computed可以依赖多个参数。</li>
</ul>
<h1 id="MVC-MVVM"><a href="#MVC-MVVM" class="headerlink" title="MVC/MVVM"></a>MVC/MVVM</h1><ul>
<li>mvc用户对View的操作交给了Controller处理，在Controller中响应View的事件调用Model的接口对数据进行操作，一旦Model发生变化便通知相关视图进行更新。</li>
<li>在原生的html+js中，可以将html看成view;js看成controller，负责处理用户与应用的交互，响应对view的操作（对事件的监听），调用Model对数据进行操作，完成model与view的同步（根据model的改变，通过选择器对view进行操作）;将js的ajax当做Model，也就是数据层，通过ajax从服务器获取数据。</li>
<li>Model的对象不只包含数据，也有对属性（name）的监听事件</li>
<li>MVVM与MVC最大的区别就是：它实现了View和Model的自动同步，也就是当Model的属性改变时，我们不用再自己手动操作Dom元素，来改变View的显示，而是改变属性后该属性对应View层显示会自动改变</li>
<li>Vue实例中的data相当于Model层，而ViewModel层的核心是Vue中的双向数据绑定，即Model变化时VIew可以实时更新，View变化也能让Model发生变化</li>
<li>MVVM比MVC精简很多，不仅简化了业务与界面的依赖，还解决了数据频繁更新的问题，不用再用选择器操作DOM元素</li>
</ul>
<h1 id="webpack-1"><a href="#webpack-1" class="headerlink" title="webpack"></a>webpack</h1><ul>
<li>webpack有五大核心概念：<ol>
<li>entry：指示从哪个文件开始打包</li>
<li>output：指示打包的文件输出到哪里去</li>
<li>loader：因为webpack本身只能打包js文件，所以需要loader把其他文件转化成js文件加载进来</li>
<li>plugin：用于拓展webpack的功能，它可以执行更多的任务，从打包优化到压缩，一直到重新定义变量等</li>
<li>model：model指示webpack使用的相应模式的配置，分为开发模式和生产模式</li>
</ol>
</li>
</ul>
<h1 id="Java和JavaScript"><a href="#Java和JavaScript" class="headerlink" title="Java和JavaScript"></a>Java和JavaScript</h1><ul>
<li>Java和js的区别<ol>
<li>Java是面向对象的语言，即使是简单的程序也需要设计对象，JavaScript是脚本语言，他是种基于对象和事件驱动的语言</li>
<li>Java在执行之前必须编译，JavaScript不需要，可以有浏览器直接解释执行</li>
<li>Java的所有变量在编译之前必须做声明，JavaScript不需要</li>
<li>代码格式不一样</li>
</ol>
</li>
<li>js怎么实现Java的继承<ol>
<li>使用对象冒充（this.method）,将parent指向的对象赋给this.method,然后执行this.method，最后执行完再销毁就行了</li>
<li>使用call方法，parent.call(this,父类对象)，改变this指向</li>
<li>也可使用apply方法改变this指向</li>
<li>原型链方式，父类的函数和变量放在原型对象上，子类通过实例化父类来继承函数和变量</li>
</ol>
</li>
<li>js实现public和private<ul>
<li>public<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;通过初始化实例变量来给对象添加public变量</span><br><span class="line">functin Container(param) &#123;   </span><br><span class="line">this.member &#x3D; param;   </span><br><span class="line">&#125;  </span><br><span class="line">var myContainer &#x3D; new Container(&#39;abc&#39;)，则myContainer.member为&#39;abc&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;函数通过加在原型链来实现public</span><br><span class="line">Container.prototype.stamp &#x3D; function (string) &#123;   </span><br><span class="line">return this.member + string;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Private<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">普通的var变量就是private</span><br><span class="line">private函数</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;private methd  </span><br><span class="line">function getSex()&#123;  </span><br><span class="line">    return sex;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">function getSalary()&#123;  </span><br><span class="line">    return salary;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">this.display &#x3D; function()&#123;  </span><br><span class="line">    document.write(this.getName() + &quot;---&quot; + this.getAge() + &quot;---&quot; + getSex() + &quot;----&quot; + getSalary());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</div></article><div class="post-meta__tag-list"></div><div class="social-share pull-right" data-disabled="Linkedin,点点,Facebook,Twitter"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/08/09/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"><i class="fa fa-chevron-left">  </i><span>网络安全</span></a></div><div class="next-post pull-right"><a href="/2020/08/09/%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96%E5%8A%A8/"><span>节流和防抖动</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'true' == true ? true : false;
var verify = 'true' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'YiMuUS8mJ9iQH4i0HKdegAjN-gzGzoHsz',
  appKey:'S42xmXqdEnhtc3ibq7F71WYu',
  placeholder:'Just go go',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'5',
  lang: 'zh-cn'
})</script></div></div><footer class="footer-bg" style="background-image: url(https://w.wallhaven.cc/full/g7/wallhaven-g75r7d.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2021 By XYX</div><div class="framework-info"></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span></span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;"></a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>