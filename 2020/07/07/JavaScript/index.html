<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="JavaScript"><meta name="keywords" content="JavaScript"><meta name="author" content="XYX"><meta name="copyright" content="XYX"><title>JavaScript | XYX's Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?42b25629bbf1fae4313b2d989bcab163";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="XYX's Blog" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#js基本语法"><span class="toc-number">1.</span> <span class="toc-text">js基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#引入js"><span class="toc-number">1.1.</span> <span class="toc-text">引入js</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#标识符"><span class="toc-number">1.2.</span> <span class="toc-text">标识符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据类型"><span class="toc-number">1.3.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运算符"><span class="toc-number">1.4.</span> <span class="toc-text">运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#break和continue"><span class="toc-number">1.5.</span> <span class="toc-text">break和continue</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#对象"><span class="toc-number">2.</span> <span class="toc-text">对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#分类"><span class="toc-number">2.1.</span> <span class="toc-text">分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建对象"><span class="toc-number">2.2.</span> <span class="toc-text">创建对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数"><span class="toc-number">2.3.</span> <span class="toc-text">函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#作用域"><span class="toc-number">2.4.</span> <span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this"><span class="toc-number">2.5.</span> <span class="toc-text">this</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造函数"><span class="toc-number">2.6.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#原型-prototype"><span class="toc-number">2.7.</span> <span class="toc-text">原型-prototype</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#toString方法"><span class="toc-number">2.8.</span> <span class="toc-text">toString方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#垃圾回收"><span class="toc-number">2.9.</span> <span class="toc-text">垃圾回收</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数组"><span class="toc-number">3.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#创建数组"><span class="toc-number">3.1.</span> <span class="toc-text">创建数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组的方法"><span class="toc-number">3.2.</span> <span class="toc-text">数组的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#遍历数组"><span class="toc-number">3.3.</span> <span class="toc-text">遍历数组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#常用类和方法"><span class="toc-number">4.</span> <span class="toc-text">常用类和方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#call-和apply"><span class="toc-number">4.1.</span> <span class="toc-text">call-和apply</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arguments"><span class="toc-number">4.2.</span> <span class="toc-text">arguments</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Date"><span class="toc-number">4.3.</span> <span class="toc-text">Date</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Math"><span class="toc-number">4.4.</span> <span class="toc-text">Math</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#包装类"><span class="toc-number">4.5.</span> <span class="toc-text">包装类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串"><span class="toc-number">4.6.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#正则表达式"><span class="toc-number">4.7.</span> <span class="toc-text">正则表达式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DOM"><span class="toc-number">5.</span> <span class="toc-text">DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#简介"><span class="toc-number">5.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#事件"><span class="toc-number">5.2.</span> <span class="toc-text">事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM操作HTML"><span class="toc-number">5.3.</span> <span class="toc-text">DOM操作HTML</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM修改"><span class="toc-number">5.4.</span> <span class="toc-text">DOM修改</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM操作CSS"><span class="toc-number">5.5.</span> <span class="toc-text">DOM操作CSS</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#事件-1"><span class="toc-number">6.</span> <span class="toc-text">事件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#事件对象"><span class="toc-number">6.1.</span> <span class="toc-text">事件对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#事件的冒泡"><span class="toc-number">6.2.</span> <span class="toc-text">事件的冒泡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#事件的委派"><span class="toc-number">6.3.</span> <span class="toc-text">事件的委派</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#事件的绑定"><span class="toc-number">6.4.</span> <span class="toc-text">事件的绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#事件的传播"><span class="toc-number">6.5.</span> <span class="toc-text">事件的传播</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常用的事件"><span class="toc-number">6.6.</span> <span class="toc-text">常用的事件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#BOM"><span class="toc-number">7.</span> <span class="toc-text">BOM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#BOM对象"><span class="toc-number">7.1.</span> <span class="toc-text">BOM对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Navigator"><span class="toc-number">7.2.</span> <span class="toc-text">Navigator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#History"><span class="toc-number">7.3.</span> <span class="toc-text">History</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Location"><span class="toc-number">7.4.</span> <span class="toc-text">Location</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#window"><span class="toc-number">7.5.</span> <span class="toc-text">window</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类的操作"><span class="toc-number">8.</span> <span class="toc-text">类的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#直接修改元素的类css"><span class="toc-number">8.1.</span> <span class="toc-text">直接修改元素的类css</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JSON"><span class="toc-number">9.</span> <span class="toc-text">JSON</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JSON-格式"><span class="toc-number">9.1.</span> <span class="toc-text">JSON-格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JSON分类："><span class="toc-number">9.2.</span> <span class="toc-text">JSON分类：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JSON中允许的值："><span class="toc-number">9.3.</span> <span class="toc-text">JSON中允许的值：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JSON工具类"><span class="toc-number">9.4.</span> <span class="toc-text">JSON工具类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他"><span class="toc-number">9.5.</span> <span class="toc-text">其他</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">XYX</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">32</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">31</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">13</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">我的朋友们</div><a class="author-info-links__name text-center" href="https://www.ntutn.top/" target="_blank" rel="noopener">归零幻想</a><a class="author-info-links__name text-center" href="https://www.ruiovo.top/" target="_blank" rel="noopener">ruiOvO</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://w.wallhaven.cc/full/g7/wallhaven-g75r7d.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">XYX's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/gallery">相册</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">JavaScript</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-07-07</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%A4%A7%E5%9D%97/">前端三大块</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">13k</span><span class="post-meta__separator">|</span><span>阅读时长: 43 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote>
<p>序<br><br>终于开始学前端的核心内容了！学好JS才能为后面的jQuery( JavaScript库)和JS框架(React,Vue,Angular)打好基础，冲冲冲！</p>
</blockquote>
<a id="more"></a>
<h1 id="js基本语法"><a href="#js基本语法" class="headerlink" title="js基本语法"></a>js基本语法</h1><h2 id="引入js"><a href="#引入js" class="headerlink" title="引入js"></a>引入js</h2><ul>
<li>可以编写到标签的onclick属性中，也可以写在标签的属性中，但是他们属于行为和结构耦合，不方便维护，不推荐<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick&#x3D;&quot;alert(&#39;xxx&#39;)&quot;&gt;&lt;&#x2F;button&gt;</span><br><span class="line">&lt;a href&#x3D;&quot;javascript:alert(&#39;xxx&#39;)&quot;&gt;&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure></li>
<li>可以写在标签或者外部文件中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>js标签一旦引入外部文件了，就不能再编码了，即使编写了浏览器也会忽略；如果需要则可以再创建一个新的script标签用于编写内部代码，执行顺序按从上至下依次执行。</li>
</ul>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><ul>
<li>在js中所有的可以由我们自主命名的都可以成为标识符</li>
<li>例如：变量名，函数名，属性名等等</li>
<li>命名一个标识符需要遵守如下规则：<ol>
<li>标识符可以包含字母，数字，_，$</li>
<li>标识符不能以数字开头</li>
<li>标识符不能是关键字和保留字</li>
</ol>
</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li>数据类型</li>
</ul>
<p>String，Number，Boolean，Null，Undefined，Object(object不属于基本数据类型)</p>
<ul>
<li><p>数组</p>
<blockquote>
<p>用方括号书写，数组的项目由逗号分隔。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">下面的代码声明（创建）了名为 cars 的数组，包含三个项目（汽车品牌）：</span><br><span class="line">var cars &#x3D; [&quot;Porsche&quot;, &quot;Volvo&quot;, &quot;BMW&quot;];</span><br></pre></td></tr></table></figure>
</li>
<li><p>typeof 运算符</p>
</li>
</ul>
<p>可使用typeof 来确定 JavaScript 变量的类型,typeof<br>运算符返回变量或表达式的类型</p>
<ul>
<li>进制</li>
</ul>
<ol>
<li>表示16进制的数字，需要0x开头</li>
<li>表示8进制的数字，需要0开头</li>
<li>表示2进制的数字，需要0b开头</li>
</ol>
<ul>
<li><p>强制转换</p>
<ol>
<li><p>将其他数据类型转换为String</p>
<ul>
<li>方法一：调用被转换数据类型的toString()方法</li>
<li>该方法不影响原变量，他会将转换的结果返回</li>
<li>但是注意null和undefined这两个值没有toString()方法，会报错</li>
<li>方法二：调用String()函数，并将被转换的数据作为参数传递给函数</li>
<li>使用String()函数强制转换时，对于Number和Boolean实际上就是调用toString()方法，但是对于null和undefined就会将他们转换为字符串”null”和”undefined”</li>
</ul>
</li>
<li><p>将其他数据类型转换为Number</p>
<ul>
<li>方法一：使用Number()函数</li>
<li>如果字符串中有非数字的内容，则转换为NaN</li>
<li>如果字符串是空或者是全空格，则转换为0</li>
<li>方法二：这种方法专用于字符串</li>
<li>parseInt()把一个字符串转换为一个整数<br>//将一个字符串中的有效内容的整数内容读取出来转换为Number</li>
<li>parseFloat()把一个字符串转换为一个浮点数//将一个字符串中的有效内容的小数内容读取出来转换为Number</li>
<li>可以用一元的+来进行隐式的类型转换</li>
</ul>
</li>
<li><p>将其他数据类型转换为Boolean</p>
<ul>
<li><p>使用Boolean()函数</p>
<ul>
<li>数字-&gt;布尔(除了0和NaN，其余都是true)</li>
<li>字符串-&gt;布尔(除了空串，其余都是true)</li>
<li>null和undefined都会转换为false</li>
<li>对象也会转换为true</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul>
<li><p>逻辑运算符</p>
<ul>
<li><p>!</p>
<p>非运算可以对一个布尔值进行取反，true变false false边true<br>当对非布尔值使用!时，会先将其转换为布尔值然后再取反<br>我们可以利用!来将其他的数据类型转换为布尔值</p>
</li>
<li><p>&amp;&amp;</p>
<p>&amp;&amp;可以对符号两侧的值进行与运算<br>只有两端的值都为true时，才会返回true。只要有一个false就会返回false。<br>与是一个短路的与，如果第一个值是false，则不再检查第二个值<br>对于非布尔值，它会将其转换为布尔值然后做运算，并返回原值<br>规则：</p>
</li>
</ul>
<p>1.如果第一个值为false，则返回第一个值<br> 2.如果第一个值为true，则返回第二个值</p>
<ul>
<li><p>||</p>
<p>||可以对符号两侧的值进行或运算<br>只有两端都是false时，才会返回false。只要有一个true，就会返回true。<br>或是一个短路的或，如果第一个值是true，则不再检查第二个值<br>对于非布尔值，它会将其转换为布尔值然后做运算，并返回原值<br>规则：1. 如果第一个值为true，则返回第一个值2.<br>如果第一个值为false，则返回第二个值</p>
</li>
</ul>
</li>
</ul>
<h2 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h2><ul>
<li>break关键字可以用来退出switch或循环语句</li>
<li>不能在if语句中使用break和continue</li>
<li>break关键字，会立即终止离他最近的那个循环语句</li>
<li>continue可以跳过当次循环</li>
</ul>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><blockquote>
<p>对象属于一种复合的数据类型，在对象中可以保存多个不同数据类型的属性</p>
</blockquote>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ol>
<li>内建对象</li>
</ol>
<ul>
<li>由ES标准中定义的对象，在任何的ES的实现中都可以使用</li>
<li>比如：Math String Number Boolean Function Object…</li>
</ul>
<ol start="2">
<li>宿主对象</li>
</ol>
<ul>
<li>由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象</li>
<li>比如：BOM DOM</li>
</ul>
<ol start="3">
<li>自定义对象</li>
</ol>
<ul>
<li><p>由开发人员自己创建的对象</p>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2></li>
</ul>
<ol>
<li>方法一<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; new Object();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>基本数据类型的数据，变量是直接保存的它的值。</li>
<li>变量与变量之间是互相独立的，修改一个变量不会影响其他的变量。</li>
<li>引用数据类型的数据，对象是保存在堆内存中的，每创建一个新对象，就会在堆内存中开辟一个新的空间，而变量保存的是对象的内存地址，如果两个变量保存的是同一个对象引用，当我们通过一个变量修改属性时，另一个也会受到影响</li>
<li>当两个引用数据类型比较时，比较的是对象的内存地址</li>
</ul>
<ol start="2">
<li>方法二<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>使用对象字面量可以在创建对象的时候，直接指定对象中的属性</li>
<li>语法：{属性名：属性值，属性名：属性值，···}//要是属性名过于特殊，则要加引号</li>
</ul>
<ol start="3">
<li><p>向对象中添加属性</p>
<ul>
<li>语法：对象.属性名=属性值;</li>
<li>对象[“属性名”] = 属性值; 这种方式能够使用特殊的属性名</li>
<li>对象的属性名没有任何要求，不需要遵守标识符的规范，但是在开发中，尽量按照标识符的要求去写。属性值也可以任意的数据类型。</li>
</ul>
</li>
<li><p>读取对象中的属性</p>
<ul>
<li>语法：对象.属性名</li>
<li>对象[“属性名”] ;“属性名”可以使字符串常量，也可以是字符串变量</li>
<li>如果读取一个对象中没有的属性，它不会报错，而是返回一个undefined</li>
</ul>
</li>
<li><p>修改对象中的属性</p>
<ul>
<li>语法：对象.属性值=新值</li>
</ul>
</li>
<li><p>删除对象中的属性</p>
<ul>
<li><p>语法：delete 对象.属性名</p>
<pre><code>delete 对象[&quot;属性名&quot;]</code></pre></li>
</ul>
</li>
</ol>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><blockquote>
<p>函数也是一个对象，函数主要用来封装一些功能</p>
</blockquote>
<ol>
<li><p>创建函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">函数声明</span><br><span class="line">function 函数名(形参1,形参2...形参N)</span><br><span class="line">&#123;  </span><br><span class="line">语句...  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">函数表达式：将要封装的代码以字符串的形式传递给构造函数</span><br><span class="line">var 函数名 &#x3D; function(形参1,形参2...形参N)</span><br><span class="line">&#123;  </span><br><span class="line">语句...  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>立即执行函数</p>
<ul>
<li>函数定义完，立即被调用，这种函数叫做立即执行函数</li>
<li>立即执行函数往往只会执行一次<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(function(a,b)&#123;  </span><br><span class="line">console.log(&quot;a &#x3D; &quot;+a);  </span><br><span class="line">console.log(&quot;b &#x3D; &quot;+b);  </span><br><span class="line">&#125;)(123,456);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>枚举对象中的属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">for(var 变量 in 对象)&#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><ol>
<li><p>全局作用域</p>
<ul>
<li>直接在script标签中编写的代码都运行在全局作用域中</li>
<li>全局作用域在页面打开时创建，在页面关闭时销毁</li>
<li>在全局作用域中有一个全局对象window，他代表的是一个浏览器的窗口，他由浏览器创建时我们可以直接使用</li>
<li>在全局作用域中创建的变量都会作为window对象的属性保存</li>
<li>在全局作用域中创建的函数都会作为window对象的方法保存</li>
<li>在全局作用域中创建的变量和函数可以在页面的任意位置访问</li>
<li>在函数作用域中也可以访问到全局作用域的变量</li>
</ul>
</li>
<li><p>函数作用域</p>
<ul>
<li>调用函数时创建函数作用域，函数执行完毕后，函数作用域销毁</li>
<li>每调用一个函数就会创建一个新的函数作用域，他们之间是相互独立的</li>
<li>在函数作用域中可以访问到全局作用域的变量</li>
<li>在全局作用域中无法访问到函数作用域的变量</li>
<li>当在函数作用域中操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用，如果没有就向上一级的作用域中寻找，直到找到全局作用域，若全局作用域中还没有，则会报错</li>
</ul>
</li>
<li><p>变量的声明提前</p>
<ul>
<li>在全局作用域中，使用var关键字声明的变量会在所有代码执行前被声明(但是不会被赋值)，但是如果声明变量不使用var关键字，则变量不会被声明提前</li>
<li>在函数作用域中，也具有同上特性，使用var关键字声明的变量会在函数所有的代码执行前被声明，如果没有使用var关键字声明变量，则变量会变成全局变量</li>
</ul>
</li>
<li><p>函数的声明提前</p>
<ul>
<li>使用函数声明形式创建的函数function<br>函数名(){},他会在所有代码执行前被创建，所以我们可以在函数声明前调用函数；使用函数表达式(var<br>fun = function(){})创建的函数没有该特性</li>
<li>在函数作用域中，使用函数声明创建的函数，会在所有的函数中的代码执行之前就被创建好了</li>
</ul>
</li>
</ol>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><blockquote>
<p>我们每次调用函数时，解析器都会将一个上下文对象作为隐含的参数传递进函数。<br>使用this来引用上下文对象，根据函数的调用形式不同，this的值也不同。</p>
</blockquote>
<ul>
<li>this的不同的情况：<ol>
<li>以函数的形式调用时，this是window</li>
<li>以方法的形式调用时，this就是调用方法的对象</li>
<li>以构造函数的形式调用时，this就是新创建的对象</li>
<li>在事件的响应函数中，响应函数是给谁绑定的this，那么这个this就是谁</li>
</ol>
</li>
<li>改变this指向<ul>
<li>apply 、 call 、bind 三者都是用来改变函数的this对象的指向的；</li>
<li>apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文；</li>
<li>apply 、 call 、bind 三者都可以利用后续参数传参；</li>
<li>call需要把参数按顺序传递进去func.call(this, arg1, arg2)；而 apply 则是把参数放在数组里func.apply(this, [arg1, arg2])；bind() 方法的第二个以及以后的参数+函数运行时本身的参数按照顺序作为原函数的参数来调用原函数，就是说bind会不断的产生新的函数</li>
<li>bind是返回对应函数，便于稍后调用；apply、call则是立即调用</li>
</ul>
</li>
</ul>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ul>
<li>一个构造函数我们也可以称为一个类</li>
<li>通过一个构造函数创建的对象，我们称该对象时这个构造函数的实例</li>
<li>可以用 instanceof 用来检查一个对象是否是一个类的实例</li>
<li>通过同一个构造函数创建的对象，我们称为一类对象</li>
<li>构造函数就是一个普通的函数，只是他的调用方式不同，如果直接调用，它就是一个普通函数，如果使用new来调用，则它就是一个构造函数</li>
<li>构造函数的执行流程：<ol>
<li>创建一个新的对象</li>
<li>将新建的对象设置为函数中的this，在构造函数中用this来引用新建的对象</li>
<li>执行函数中的代码</li>
<li>将新建的对象返回<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line"></span><br><span class="line">function Person(name , age , gender)&#123;  </span><br><span class="line">this.name &#x3D; name;  </span><br><span class="line">this.age &#x3D; age;  </span><br><span class="line">this.gender &#x3D; gender;  </span><br><span class="line">this.sayName &#x3D; function()&#123;  </span><br><span class="line">alert(this.name);  </span><br><span class="line">&#125;;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h2 id="原型-prototype"><a href="#原型-prototype" class="headerlink" title="原型-prototype"></a>原型-prototype</h2><ul>
<li><p>我们所创建的每一个函数，解析器都会像函数中添加一个属性prototype</p>
</li>
<li><p>prototype属性指向的是一个对象，这个对象我们称为原型对象</p>
</li>
<li><p>当函数作为构造函数使用，<strong>它所创建的对象中都会有一个隐含的属性执行该原型对象</strong>，并且这个隐含的属性可以通过对象.<strong>proto</strong>来访问</p>
</li>
<li><p>当我们访问对象的一个属性或者是方法是，他会先在对象自身中寻找，如果有就直接使用；如果没有就回去原型对象中寻找，找到则直接使用</p>
</li>
<li><p>原型对象就相当于一个公共的区域，凡是通过同一个构造函数创建的对象他们通常都可以访问到相同的原型对象</p>
</li>
<li><p>举例：<br><img src="/2020/07/07/JavaScript/js%E5%8E%9F%E5%9E%8B.png" alt></p>
</li>
<li><p><strong>作用：如果将构造函数中的函数定义在全局作用域中，污染了全局作用域的命名空间，而且定义在全局作用域中很不安全，所以我们可以将对象共有的属性和方法放在原型对象中，这样既不用分别为每一个对象添加，也不会影响全局作用域，就可以使每个对啊ing都具有这些属性和方法了</strong></p>
</li>
<li><p>hasOwnProperty()</p>
<blockquote>
<p>这个方法可以用来检查对象自身中是否含有某个属性</p>
<blockquote>
<p>语法：对象.hasOwnProperty(“属性名”)</p>
</blockquote>
</blockquote>
</li>
<li><p>原型也是对象，所以他也有原型</p>
<blockquote>
<p>当我们使用一个对象或方法时，会先在自身中寻找，自身要是有就直接使用</p>
<blockquote>
<p>如果自身没有就去原型对象中寻找，如果有就直接使用</p>
<blockquote>
<p>如果原型对象中还没有，就去原型的原型中去寻找，直到找到object对象（object没有以原型），如果还没找到就返回undefined\</p>
<p><img src="/2020/07/07/JavaScript/%E5%8E%9F%E5%9E%8B%E7%9A%84%E5%8E%9F%E5%9E%8B.png" alt></p>
</blockquote>
</blockquote>
</blockquote>
</li>
</ul>
<h2 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h2><ul>
<li><p>当我们直接在页面中打印一个对象时，事实上是输出的对象的toString()方法的返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;修改Person原型的toString方法的返回值  </span><br><span class="line">Person.prototype.toString &#x3D; function()&#123;  </span><br><span class="line">return &quot;Person[name&#x3D;&quot;+this.name+&quot;,age&#x3D;&quot;+this.age+&quot;,gender&#x3D;&quot;+this.gender+&quot;]&quot;;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2></li>
<li><p>就像人生活的时间长了会产生垃圾一样，程序运行过程中也会产生垃圾,这些垃圾积攒过多以后，会导致程序运行的速度过慢，所以我们需要一个垃圾回收的机制，来处理程序运行过程中产生垃圾</p>
</li>
<li><p>当一个对象没有任何的变量或属性对它进行引用，此时我们将永远无法操作该对象，此时这种对象就是一个垃圾，这种对象过多会占用大量的内存空间，导致程序运行变慢，所以这种垃圾必须进行清理。</p>
</li>
<li><p>在JS中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁，我们不需要也不能进行垃圾回收的操作，<strong>我们需要做的只是要将不再使用的对象设置null即可</strong></p>
</li>
</ul>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><ul>
<li>数组也是一个对象，是一个用来存储数据的对象和Object类似，但是它的存储效率比普通对象要高，数组中保存的内容我们称为元素</li>
</ul>
<h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">方法一：</span><br><span class="line">var arr &#x3D; new Array();  </span><br><span class="line">arr[0] &#x3D; 123;  </span><br><span class="line">arr[1] &#x3D; &quot;hello&quot;;</span><br><span class="line">方法二：</span><br><span class="line">var arr &#x3D; [123,&quot;hello&quot;];</span><br></pre></td></tr></table></figure></code></pre><h2 id="数组的方法"><a href="#数组的方法" class="headerlink" title="数组的方法"></a>数组的方法</h2><ol>
<li>join():数组转换成字符串</li>
<li>push():  把里面的内容添加到数组末尾，并返回修改后的长度</li>
<li>pop()：移除数组最后一项，返回移除的那个值，减少数组的length</li>
<li>shift()：删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefined</li>
<li>unshift():将参数添加到原数组开头，并返回数组的长度 </li>
<li>sort()：将数组里的项从小到大排序</li>
<li>reverse()：反转数组项的顺序</li>
<li>concat():将参数添加到原数组中</li>
<li>slice()：返回从原数组中指定开始下标到结束下标之间的项组成的新数组</li>
<li>splice()<ul>
<li>删除：指定 2 个参数：要删除的第一项的位置和要删除的项数</li>
<li>插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、 0（要删除的项数）和要插入的项</li>
<li>替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等</li>
</ul>
</li>
<li>indexOf()：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的开头（位置 0）开始向后查找</li>
<li>lastIndexOf：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的末尾开始向前查找</li>
<li>forEach()：对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有返回值。参数都是function类型，默认有传参，参数分别为：遍历的数组内容；第对应的数组索引，数组本身</li>
<li>map()：指“映射”，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组</li>
<li>filter()：“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组</li>
<li>every()：判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true</li>
<li>some()：判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true</li>
</ol>
<h2 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h2><ol>
<li><p>用for循环来遍历数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">方法一：</span><br><span class="line">for(var i&#x3D;0 ; i&lt;数组.length ; i++)&#123;  </span><br><span class="line">    &#x2F;&#x2F;数组[i]  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用forEach()方法来遍历数组（不兼容IE8）</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">数组.forEach(function(value , index , obj)&#123;  </span><br><span class="line">  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">value:正在遍历的元素</span><br><span class="line">index:正在遍历元素的索引</span><br><span class="line">obj:被遍历对象</span><br></pre></td></tr></table></figure>

<ul>
<li>forEach()方法需要一个回调函数作为参数，<br>数组中有几个元素，回调函数就会被调用几次，<br>每次调用时，都会将遍历到的信息以实参的形式传递进来，<br>我们可以定义形参来获取这些信息</li>
</ul>
<h1 id="常用类和方法"><a href="#常用类和方法" class="headerlink" title="常用类和方法"></a>常用类和方法</h1><h2 id="call-和apply"><a href="#call-和apply" class="headerlink" title="call-和apply"></a>call-和apply</h2><ul>
<li>这两个方法都是函数对象的方法，需要通过函数对象调用</li>
<li>当对函数调用call()和apply()都会调用函数执行</li>
<li>在调用call()和apply()可以将一个对象指定为第一个参数，此时这个对象将会成为函数执行时的this</li>
<li>call()方法可以将实参在对象之后一次传递</li>
<li>apply()方法需要将实参封装到一个数组中统一传递</li>
</ul>
<h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><ul>
<li>arguments是一个类数组对象，它可以通过索引来操作数据，也可以获取长度</li>
<li>在调用函数是，我们所传递的实参都会在arguments中保存</li>
<li>arguements.length可以用来获取实参长度</li>
<li>还可以用arguements来使用实参，arguements[0]表示第一个实参，arguements[1]表示第二个实参···</li>
<li>它里面有一个属性交callee，这个属性对应一个函数对象，就是当前正在指向的函数对象</li>
</ul>
<h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><ul>
<li><p>日期的对象，在JS中通过Date对象来表示一个时间</p>
</li>
<li><p>如果直接用构造函数创建一个Date对象，则封装为当前代码执行的时间</p>
</li>
<li><p>创建对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">创建一个当前的时间对象</span><br><span class="line">var d &#x3D; new Date();</span><br><span class="line"></span><br><span class="line">创建一个指定的时间对象</span><br><span class="line">var d &#x3D; new Date(&quot;月&#x2F;日&#x2F;年 时:分:秒&quot;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法</p>
<table>
<thead>
<tr>
<th>name</th>
<th>function</th>
</tr>
</thead>
<tbody><tr>
<td>getDate()</td>
<td>当前日期对象是几日（1-31）</td>
</tr>
<tr>
<td>getDay()</td>
<td>返回当前日期对象时周几（0-6），0 周日，1 周一 ···</td>
</tr>
<tr>
<td>getMonth()</td>
<td>返回当前日期对象的月份（0-11），0 一月， 1 二月 ···</td>
</tr>
<tr>
<td>getFullYear()</td>
<td>从 Date 对象以四位数字返回年份</td>
</tr>
<tr>
<td>getHours()</td>
<td>返回 Date 对象的小时 (0 ~ 23)</td>
</tr>
<tr>
<td>getMinutes()</td>
<td>返回 Date 对象的分钟 (0 ~ 59)</td>
</tr>
<tr>
<td>getSeconds()</td>
<td>返回 Date 对象的秒数 (0 ~ 59)</td>
</tr>
<tr>
<td>getMilliseconds()</td>
<td>返回 Date 对象的毫秒(0 ~ 999)</td>
</tr>
<tr>
<td>getTime()</td>
<td>返回当前日期对象的时间戳，时间戳，指的是从1970年月1日 0时0分0秒，到现在时间的毫秒数，计算机底层保存时间都是以时间戳的形式保存的</td>
</tr>
<tr>
<td>Date.now()</td>
<td>可以获取当前代码执行时的时间戳</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><ul>
<li><p>Math属于一个工具类，它不需要我们创建对象，它里边封装了属性运算相关的常量和方法,我们可以直接使用它来进行数学运算相关的操作</p>
</li>
<li><p>方法</p>
<p>name                   |              function</p>
</li>
<li><p>-|–<br> Math.PI                              |常量，圆周率<br> Math.abs()                          | 绝对值运算<br> Math.cell()                         | 向上取整<br> Math.floor()                        | 向下取整<br> Math.round()                        | 四舍五入取整<br> Math.random()                       | 生成一个01之间的随机数<br> Math.round(Math.random()*(y-x)+x)  | 生成一个xy之间的随机数<br> Math.pow(x,y)                       | 求x的y次幂<br> Math.sqrt()                         | 对一个数进行开方<br> Math.max()                          | 求多个数中最大值<br> Math.min()                          | 求多个数中的最小值</p>
</li>
</ul>
<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><ul>
<li><p>在JS中为我们提供了三个包装类，通过这三个包装类可以将基本的数据类型的数据转换为对象：<br>String() Boolean()<br>Number()通过这三个包装类可以创建基本数据类型的对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">通过包装类创建基本数据类型的对象：</span><br><span class="line"></span><br><span class="line">var num &#x3D; new Number(2);  </span><br><span class="line">var str &#x3D; new String(&quot;hello&quot;);  </span><br><span class="line">var bool &#x3D; new Boolean(true);</span><br></pre></td></tr></table></figure>
</li>
<li><p>但是在实际应用中千万不要这么干。当我们去操作一个基本数据类型的属性和方法时，解析器会临时将其转换为对应的包装类，然后再去操作属性和方法，操作完成以后再将这个临时对象进行销毁</p>
</li>
</ul>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul>
<li><p>在底层字符串是以字符数组的形式保存的</p>
</li>
<li><p>方法</p>
<table>
<thead>
<tr>
<th>name</th>
<th>function</th>
</tr>
</thead>
<tbody><tr>
<td>length</td>
<td>获取字符串的长度</td>
</tr>
<tr>
<td>charAt()</td>
<td>根据索引获取指定的字符</td>
</tr>
<tr>
<td>charCodeAt()</td>
<td>根据索引获取指定的字符编码(Unicode编码)</td>
</tr>
<tr>
<td>String.fromCharCode()</td>
<td>根据字符编码获取字符</td>
</tr>
<tr>
<td>indexof()</td>
<td>可以检索一个字符串是否含有指定内容，需要一个字符串作为参数，这个字符串就是要检索的内容，如果找到该内容，则会返回其第一次出现的索引，如果没有找到则返回-1，可以指定一个第二个参数，来表示开始查找的位置</td>
</tr>
<tr>
<td>lastIndexOf()</td>
<td>功能同indexof，indexOf()是从前向后找，lastIndexOf()是从后向前找</td>
</tr>
<tr>
<td>slice(start,end)</td>
<td>可以从一个字符串中截取指定的内容，并将截取到内容返回，不会影响原变量，参数：第一个：截取开始的位置（包括开始），第二个：截取结束的位置（不包括结束）可以省略第二个参数，如果省略则一直截取到最后，可以传负数，如果是负数则从后往前数</td>
</tr>
<tr>
<td>substr()</td>
<td>和slice()基本一致，不同的是它第二个参数不是索引，而是截取的数量</td>
</tr>
<tr>
<td>substring()</td>
<td>和slice()基本一致，不同的是它不能接受负值作为参数，如果设置一个负值，则会自动修正为0，substring()中如果第二个参数小于第一个，自动调整位置</td>
</tr>
<tr>
<td>toLowerCase()</td>
<td>将字符串转换为小写并返回</td>
</tr>
<tr>
<td>toUpperCase()</td>
<td>将字符串转换为大写并返回</td>
</tr>
<tr>
<td>正则表达式相关方法:</td>
<td></td>
</tr>
<tr>
<td>split()</td>
<td>可以将一个字符串拆分成一个数组，方法中可以传一个正则表达式作为参数，这样方法就会根据正则表达式去拆分字符串</td>
</tr>
<tr>
<td>search()</td>
<td>可以搜索字符串中是否含有指定内容，如果搜索到指定内容，则会返回第一次出现的索引，如果没有则返回-1，它可以接受正则表达式作为参数，然后根据正则表达式去检索字符串,search只会查找第一个，即使设置全局匹配也没用</td>
</tr>
<tr>
<td>match()</td>
<td>可以根据正则表达式，从一个字符串中将符合条件的内容提取出来，默认情况下我们的match只会找到第一个符合要求的内容，找到以后就停止检索，我们可以设置正则表达式为全局匹配模式，这样就会匹配到所有的内容，可以为一个正则表达式设置多个匹配模式，且顺序无所谓，match()会将匹配到的内容封装到一个数组中返回，即使只查询到一个结果</td>
</tr>
<tr>
<td>replace()</td>
<td>可以将字符串中指定内容替换为新的内容,参数：1.被替换的内容，可以接受一个正则表达式作为参数2.新的内容；替换为””则为删除,默认只会替换第一个</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><ul>
<li><p>用于定义一些字符串的规则，计算机可以根据正则表达式来检查一个字符串是否符合规则，并将字符串中符合规则的内容提取出来</p>
</li>
<li><p>创建正则表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">方法一：</span><br><span class="line">var reg &#x3D; new RegExp(“正则”,”匹配模式”); </span><br><span class="line"></span><br><span class="line">方法二：</span><br><span class="line">var reg &#x3D; &#x2F;正则表达式&#x2F;匹配模式; </span><br><span class="line">&#x2F;&#x2F;（匹配模式可以多个一起写：&#x2F;gi）</span><br><span class="line"></span><br><span class="line">匹配模式：</span><br><span class="line">i:忽略大小写（ignore）</span><br><span class="line">g:全局匹配模式（默认为1次）</span><br><span class="line">m:执行多行匹配</span><br><span class="line">设置匹配模式时，可以都不设置，也可以设置1个，也可以全设置，设置时没有顺序要求</span><br></pre></td></tr></table></figure>

<ul>
<li>test()<ul>
<li>语法：正则表达式.test(字符串)</li>
<li>可以用来检查一个字符串是否符合正则表达式，如果符合返回true，否则返回false</li>
</ul>
</li>
</ul>
</li>
<li><p>正则语法</p>
<ul>
<li>| 或</li>
<li>[] 或 //[]里的内容也是或的关系</li>
<li>[^···] 除了 //除了···都为true</li>
<li><strong>[x-y] x的ascii到y的ascii码之间的值</strong></li>
<li>[a-z] 小写字母 （也可以[e-i])</li>
<li>[A-Z] 大写字母</li>
<li>[A-z] 任意字母,但是还包括了其他ASCII在此之中的</li>
<li>[0-9] 任意数字</li>
</ul>
</li>
<li><p>量词</p>
<ul>
<li>通过量词可以设置一个内容出现的次数，<strong>量词只对它前边的一个内容起作用</strong></li>
<li>{n}     正好出现n次</li>
<li>{m,n}    出现m~n次</li>
<li>{m,}    出现m次以上</li>
<li><ul>
<li>至少一个，相当于{1,}</li>
</ul>
</li>
<li>*   0个或多个，相当于{0,}</li>
<li>?   0个或1个，相当于{0,1}</li>
</ul>
</li>
<li><p>边界表达式</p>
<ul>
<li>^表示开头</li>
<li>$表示结尾</li>
<li>在正则表达式中同时使用^$则要求字符串必须符合正则表达式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line">reg &#x3D; &#x2F;^a&#x2F;;  &#x2F;&#x2F;以a开头</span><br><span class="line">reg &#x3D; &#x2F;b$&#x2F;;  &#x2F;&#x2F;以b接位</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>元符号</p>
<ul>
<li>.     表示任意字符</li>
<li>\  .  表示 .</li>
<li>\\  表示 \</li>
<li>\w  任意字母、数字、_ [A-z0-9_]</li>
<li>\W  除了字母、数字、_ [ ^A-z0-9_]</li>
<li>\d  任意的数字 [0-9]</li>
<li>\D  除了数字 [ ^0-9]</li>
<li>\s  空格</li>
<li>\S  除了空格</li>
<li>\b  单词边界</li>
<li>\B  除了单词边界</li>
</ul>
</li>
<li><p>正则表达式应用举例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">去掉字符串两端的空格:</span><br><span class="line">var s &#x3D; &quot;        	he    llo    &quot;;   </span><br><span class="line">s &#x3D; s.replace(&#x2F;^\s*|\s*$&#x2F;g,&quot;&quot;);</span><br><span class="line"></span><br><span class="line">邮件的正则:</span><br><span class="line">hello.nihao@abc.com.cn</span><br><span class="line">任意字母下划线 . 任意字母下划线  @ 任意字母数字 .任意字母(2-5位) .任意字母(2-5位)</span><br><span class="line">\w&#123;3,&#125;  (\.\w+)*  @  [A-z0-9]+  (\.[A-z]&#123;2,5&#125;)&#123;1,2&#125;</span><br></pre></td></tr></table></figure>

<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1></li>
</ul>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>Document Object<br>Model文档对象模型,通过DOM可以来任意来修改网页中各个内容</p>
</blockquote>
<ul>
<li>文档<ul>
<li>文档指的是网页，一个网页就是一个文档</li>
</ul>
</li>
<li>对象<ul>
<li>对象指将网页中的每一个节点都转换为对象,转换完对象以后，就能以一种纯面向对象的形式来操作网页了</li>
</ul>
</li>
<li>模型<ul>
<li>模型用来表示节点和节点之间的关系，方便操作页面</li>
</ul>
</li>
<li>节点（Node）<ul>
<li>节点是构成网页的最基本的单元，网页中的每一个部分都可以称为是一个节点</li>
<li>虽然都是节点，但是节点的类型却是不同的</li>
<li>常用的节点：<ol>
<li>文档节点 （Document），代表整个网页</li>
<li>元素节点（Element），代表网页中的标签</li>
<li>属性节点（Attribute），代表标签中的属性</li>
<li>文本节点（Text），代表网页中的文本内容<br><img src="/2020/07/07/JavaScript/node.png" alt></li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><blockquote>
<p>就是用户和浏览器的交互行为，我们可以在事件对应的属性中设置一些js代码，事件被触发时执行代码</p>
</blockquote>
<ul>
<li><p>浏览器加载一个页面时，是按照从上至下的顺序加载的，如果把script标签放在页面上面，在代码执行时，页面还没有加载，就无法获取到dom对象，解决方法如下：</p>
<ol>
<li>解决方式一：可以将js代码编写到body的下边</li>
<li>解决方式二：将js代码编写到window.onload =<br>function(){}，window.onload<br>对应的回调函数会在整个页面加载完毕以后才执行，所以可以确保代码执行时，DOM对象已经加载完毕了<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">window.onload &#x3D; function()&#123;  </span><br><span class="line">var btn &#x3D; document.getElementById(&quot;btn&quot;);  </span><br><span class="line">btn.onclick &#x3D; function()&#123;  </span><br><span class="line">&#125;;  </span><br><span class="line">&#125;;  </span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>


</li>
</ol>
</li>
</ul>
<h2 id="DOM操作HTML"><a href="#DOM操作HTML" class="headerlink" title="DOM操作HTML"></a>DOM操作HTML</h2><ul>
<li><p>document对象获取元素节点对象</p>
<ol>
<li><p>getElementById()</p>
<ul>
<li>通过元素的id属性获取一个元素节点对象：</li>
</ul>
</li>
<li><p>getElementsByTagName()</p>
<ul>
<li>通过标签名获取一组元素节点对象</li>
</ul>
</li>
<li><p>getElementsByName()</p>
<ul>
<li>通过name属性获取一组元素节点对象</li>
</ul>
</li>
</ol>
</li>
<li><p>document对象的其他的属性和方法</p>
<ol>
<li><p>document.all</p>
<ul>
<li>获取页面中的所有元素，相当于document.getElementsByTagName(“*”);</li>
</ul>
</li>
<li><p>document.documentElement</p>
<ul>
<li>获取页面中html根元素</li>
</ul>
</li>
<li><p>document.body</p>
<ul>
<li>获取页面中的body元素</li>
</ul>
</li>
<li><p>document.getElementsByClassName()</p>
<ul>
<li>根据元素的class属性值查询一组元素节点对象//这个方法不支持IE8及以下的浏览器</li>
</ul>
</li>
<li><p>document.querySelector()</p>
<ul>
<li>根据CSS选择器去页面中查询一个元素，如果匹配到的元素有多个，则它会返回查询到的第一个元素</li>
</ul>
</li>
<li><p>document.querySelectorAll()</p>
<ul>
<li>用法同5，根据CSS选择器去页面中查询一组元素，会将匹配到所有元素封装到一个数组中返回，即使只匹配到一个</li>
</ul>
</li>
</ol>
</li>
<li><p>元素的属性：</p>
<ul>
<li><p>读取元素的属性：</p>
<ul>
<li>语法：元素.属性名</li>
<li>注意：class属性不能采用这种方式，读取class属性时需要使用<br>元素.className</li>
</ul>
</li>
<li><p>修改元素的属性：<br>语法：元素.属性名 = 属性值</p>
</li>
</ul>
</li>
<li><p>innerHTML</p>
<blockquote>
<p>使用该属性可以获取或设置元素内部的HTML代码</p>
</blockquote>
</li>
<li><p>获取元素节点的子节点</p>
<ul>
<li><p>元素.getElementsByTagName()</p>
<ul>
<li>通过标签名查询当前元素的指定后代元素</li>
</ul>
</li>
<li><p>子节点包括便签元素中的文本，子元素自包含标签元素</p>
</li>
<li><p>元素.childNodes</p>
<ul>
<li>获取当前元素的所有子节点，会获取到空白的文本子节点</li>
<li>childNodes属性会获取包括文本节点在内的所有节点，根据DOM标签标签间空白也会当成文本节点【注意：在IE8及以下的浏览器中，不会将空白文本当成子节点，所以该属性在IE8中会返回4个子元素而其他浏览器是9个】</li>
</ul>
</li>
<li><p>元素.children</p>
<ul>
<li>获取当前元素的所有子元素</li>
</ul>
</li>
<li><p>元素.firstChild</p>
<ul>
<li>获取当前元素的第一个子节点，会获取到空白的文本子节点</li>
</ul>
</li>
<li><p>元素.lastChild</p>
<ul>
<li>获取当前元素的最后一个子节点</li>
</ul>
</li>
<li><p>元素.parentNode</p>
<ul>
<li>获取当前元素的父元素</li>
</ul>
</li>
<li><p>元素.previousSibling</p>
<ul>
<li>获取当前元素的前一个兄弟节点</li>
<li>previousElementSibling获取前一个兄弟元素，IE8及以下不支持</li>
</ul>
</li>
<li><p>元素.nextSibling</p>
<ul>
<li>获取当前元素的后一个兄弟节点</li>
</ul>
</li>
<li><p>firstElementChild</p>
<ul>
<li>获取当前元素的第一个子元素</li>
<li>firstElementChild不支持IE8及以下的浏览器，如果需要兼容他们尽量不要使用</li>
</ul>
</li>
<li><p>innerHTML和innerText</p>
<ul>
<li>这两个属性并没有在DOM标准定义，但是大部分浏览器都支持这两个属性<br>两个属性作用类似，都可以获取到标签内部的内容，<br>不同是innerHTML会获取到html标签，而innerText会自动去除标签<br>如果使用这两个属性来设置标签内部的内容时，没有任何区别的</li>
</ul>
</li>
<li><p>读取标签内部的文本内容</p>
<ul>
<li>元素.firstChild.nodeValue</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="DOM修改"><a href="#DOM修改" class="headerlink" title="DOM修改"></a>DOM修改</h2><ul>
<li><p>document.createElement()</p>
<ul>
<li>可以用于创建一个元素节点对象，它需要一个标签名作为参数，将会根据该标签名创建元素节点对象，并将创建好的对象作为返回值返回</li>
</ul>
</li>
<li><p>document.createTextNode()</p>
<ul>
<li>可以根据文本内容创建一个文本节点对象</li>
</ul>
</li>
<li><p>父节点.appendChild(子节点)</p>
<ul>
<li>向父节点中添加指定的子节点</li>
</ul>
</li>
<li><p>父节点.insertBefore(新节点,旧节点)</p>
<ul>
<li>将一个新的节点插入到旧节点的前边</li>
</ul>
</li>
<li><p>父节点.replaceChild(新节点,旧节点)</p>
<ul>
<li>使用一个新的节点去替换旧节点</li>
</ul>
</li>
<li><p>父节点.removeChild(子节点)</p>
<ul>
<li>删除指定的子节点</li>
<li>推荐方式：子节点.parentNode.removeChild(子节点)</li>
</ul>
</li>
</ul>
<h2 id="DOM操作CSS"><a href="#DOM操作CSS" class="headerlink" title="DOM操作CSS"></a>DOM操作CSS</h2><ul>
<li><p>读取和修改内联样式</p>
<ul>
<li>使用style属性来操作元素的内联样式</li>
<li>读取内联样式：</li>
<li>语法：元素.style.样式名<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">元素.style.width</span><br><span class="line">元素.style.height</span><br><span class="line">注意：如果样式名中带有-，则需要将样式名修改为驼峰命名法将-去掉，然后后的字母改大写</span><br><span class="line">比如：backgroundcolor &gt; backgroundColor</span><br><span class="line">borderwidth &gt; borderWidth</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>修改内联样式：</p>
<ul>
<li>语法：元素.style.样式名 = 样式值</li>
<li>通过style修改和读取的样式都是内联样式，由于内联样式的优先级比较高，所以我们通过JS来修改的样式，往往会立即生效，但是如果样式中设置了!important，则内联样式将不会生效。</li>
</ul>
</li>
<li><p>读取元素的当前样式</p>
<ol>
<li>正常浏览器</li>
</ol>
<ul>
<li>使用getComputedStyle()</li>
<li>这个方法是window对象的方法，可以返回一个对象，这个对象中保存着当前元素生效样式</li>
<li>参数：<ul>
<li>1.要获取样式的元素</li>
<li>2.可以传递一个伪元素，一般传null</li>
<li>例子：<ul>
<li>获取元素的宽度</li>
<li>getComputedStyle(box , null)[“width”];</li>
<li>通过该方法读取到样式都是只读的不能修改</li>
</ul>
</li>
</ul>
</li>
<li>可以通过对象.样式名来读取样式</li>
<li>如果获取的样式没有设置，则会获取到真实的值，而不是默认值</li>
</ul>
<ol start="2">
<li>IE8</li>
</ol>
<ul>
<li>使用currentStyle</li>
<li>语法：<ul>
<li>元素.currentStyle.样式名</li>
<li>例子：<ul>
<li>box.currentStyle[“width”]</li>
<li>通过这个属性读取到的样式是只读的不能修改</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>实现兼容性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*  </span><br><span class="line">* 定义一个函数，用来获取指定元素的当前的样式  </span><br><span class="line">* 参数：  </span><br><span class="line">* 		obj 要获取样式的元素  </span><br><span class="line">* 		name 要获取的样式名  </span><br><span class="line">*&#x2F;  </span><br><span class="line">function getStyle(obj , name)&#123;  </span><br><span class="line">    if(window.getComputedStyle)&#123;  </span><br><span class="line">        &#x2F;&#x2F;正常浏览器的方式，具有getComputedStyle()方法  </span><br><span class="line">        return getComputedStyle(obj , null)[name];  </span><br><span class="line">    &#125;else&#123;  </span><br><span class="line">        &#x2F;&#x2F;IE8的方式，没有getComputedStyle()方法  </span><br><span class="line">        return obj.currentStyle[name];  </span><br><span class="line">    &#125;  </span><br><span class="line">    &#x2F;&#x2F;简写：return window.getComputedStyle?getComputedStyle(obj , null)[name]:obj.currentStyle[name];			  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>其他的样式相关的属性</p>
<blockquote>
<p>注意：以下样式都是只读的，不能修改，未指明偏移量都是相对于当前窗口左上角</p>
</blockquote>
<table>
<thead>
<tr>
<th>name</th>
<th>function</th>
</tr>
</thead>
<tbody><tr>
<td>clientHeight</td>
<td>元素的可见高度，包括元素的内容区和内边距的高度</td>
</tr>
<tr>
<td>clientWidth</td>
<td>元素的可见宽度，包括元素的内容区和内边距的宽度</td>
</tr>
<tr>
<td>offsetHeight</td>
<td>整个元素的高度，包括内容区、内边距、边框</td>
</tr>
<tr>
<td>offfsetWidth</td>
<td>整个元素的宽度，包括内容区、内边距、边框</td>
</tr>
<tr>
<td>offsetParent</td>
<td>当前元素的定位父元素,离他最近的开启了定位的祖先元素，如果所有的元素都没有开启定位，则返回body</td>
</tr>
<tr>
<td>offsetLeft</td>
<td>当前元素和定位父元素之间的偏移量(水平偏移量)</td>
</tr>
<tr>
<td>offsetTop</td>
<td>当前元素和定位父元素之间的偏移量(垂直偏移量)</td>
</tr>
<tr>
<td>scrollHeight</td>
<td>获取元素整个滚动区域的高度</td>
</tr>
<tr>
<td>scrollWidth</td>
<td>获取元素整个滚动区域的宽度</td>
</tr>
<tr>
<td>scrollTop</td>
<td>获取元素垂直滚动条滚动的距离</td>
</tr>
<tr>
<td>scrollLeft</td>
<td>获取元素水平滚动条滚动的距离</td>
</tr>
<tr>
<td>scrollHeight -scrollTop = clientHeight</td>
<td>判断滚动条是否滚动到底(垂直滚动条)</td>
</tr>
<tr>
<td>scrollWidth -scrollLeft = clientWidth</td>
<td>判断滚动条是否滚动到底(水平滚动条)</td>
</tr>
</tbody></table>
<h1 id="事件-1"><a href="#事件-1" class="headerlink" title="事件"></a>事件</h1></li>
</ul>
<h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><ul>
<li><p>当响应函数被调用时，浏览器每次都会将一个事件对象作为实参传递进响应函数中，这个事件对象中封装了当前事件的相关信息，比如：鼠标的坐标，键盘的按键，鼠标的按键，滚轮的方向。。</p>
</li>
<li><p>可以在响应函数中定义一个形参，来使用事件对象，但是在IE8以下浏览器中事件对象没有做完实参传递，而是作为window对象的属性保存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">元素.事件 &#x3D; function(event)&#123;  </span><br><span class="line">    event &#x3D; event || window.event;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">元素.事件 &#x3D; function(e)&#123;  </span><br><span class="line">	e &#x3D; e || event;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取到鼠标的坐标</p>
<ol>
<li><p>clientX和clientY</p>
<ul>
<li>用于获取鼠标在当前的可见窗口的坐标</li>
<li>div的偏移量，是相对于整个页面的</li>
</ul>
</li>
<li><p>pageX和pageY</p>
<ul>
<li>可以获取鼠标相对于当前页面的坐标但是这个两个属性在IE8中不支持，所以如果需要兼容IE8，则不要使用var<br>left = event.clientX;var　top = event.clientY;</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="事件的冒泡"><a href="#事件的冒泡" class="headerlink" title="事件的冒泡"></a>事件的冒泡</h2><ul>
<li><p>事件的冒泡指的是事件向上传导，当后代元素上的事件被触发时，将会导致其祖先元素上的同类事件也会触发</p>
</li>
<li><p>事件的冒泡大部分情况下都是有益的，如果需要取消冒泡，则需要使用事件对象来取消<br>可以将事件对象的cancelBubble设置为true，即可取消冒泡</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">元素.事件 &#x3D; function(event)&#123;  </span><br><span class="line">    event &#x3D; event || window.event;  </span><br><span class="line">    event.cancelBubble &#x3D; true;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="事件的委派"><a href="#事件的委派" class="headerlink" title="事件的委派"></a>事件的委派</h2><ul>
<li>指将事件统一绑定给元素的共同的祖先元素，这样当后代元素上的事件触发时，会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件。</li>
<li>事件委派是利用了冒泡，通过委派可以减少事件绑定的次数，提高程序的性能</li>
<li>我们希望，只绑定一次事件，即可应用到多个的元素上，即使元素是后添加的<br>我们可以尝试将其绑定给元素的共同的祖先元素</li>
<li>target : event中的target表示的触发事件的对象</li>
</ul>
<h2 id="事件的绑定"><a href="#事件的绑定" class="headerlink" title="事件的绑定"></a>事件的绑定</h2><ul>
<li><p>addEventListener()</p>
</li>
<li><p>通过这个方法也可以为元素绑定响应函数</p>
</li>
<li><p>参数：</p>
<ol>
<li>事件的字符串，不要on</li>
<li>回调函数，当事件触发时该函数会被调用</li>
<li>是否在捕获阶段触发事件，需要一个布尔值，一般都传false</li>
</ol>
</li>
<li><p>使用addEventListener()可以同时为一个元素的相同事件同时绑定多个响应函数，<br>这样当事件被触发时，响应函数将会按照函数的绑定顺序执行,<strong>这个方法不支持IE8及以下的浏览器</strong></p>
</li>
<li><p>attachEvent()</p>
</li>
<li><p>在IE8中可以使用attachEvent()来绑定事件</p>
</li>
<li><p>参数：</p>
<ol>
<li>事件的字符串，要on</li>
<li>回调函数</li>
</ol>
</li>
<li><p>这个方法也可以同时为一个事件绑定多个处理函数，不同的是它是后绑定是事件先执行，执行顺序和addEventListener()相反</p>
</li>
<li><p>兼容模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;定义一个函数，用来为指定元素绑定响应函数  </span><br><span class="line">            &#x2F;*  </span><br><span class="line">            * addEventListener()中的this，是绑定事件的对象  </span><br><span class="line">            * attachEvent()中的this，是window  </span><br><span class="line">            *  需要统一两个方法this  </span><br><span class="line">            *&#x2F;  </span><br><span class="line">            &#x2F;*  </span><br><span class="line">            * 参数：  </span><br><span class="line">            * 	obj 要绑定事件的对象  </span><br><span class="line">            * 	eventStr 事件的字符串(不要on)  </span><br><span class="line">            *  callback 回调函数  </span><br><span class="line">            *&#x2F;  </span><br><span class="line">function bind(obj , eventStr , callback)&#123;  </span><br><span class="line">    if(obj.addEventListener)&#123;  </span><br><span class="line">        &#x2F;&#x2F;大部分浏览器兼容的方式  </span><br><span class="line">        obj.addEventListener(eventStr , callback , false);  </span><br><span class="line">    &#125;else&#123;  </span><br><span class="line">                    &#x2F;*  </span><br><span class="line">                    * this是谁由调用方式决定  </span><br><span class="line">                    * callback.call(obj)  </span><br><span class="line">                    *&#x2F;  </span><br><span class="line">        &#x2F;&#x2F;IE8及以下  </span><br><span class="line">        obj.attachEvent(&quot;on&quot;+eventStr , function()&#123;  </span><br><span class="line">            &#x2F;&#x2F;在匿名函数中调用回调函数  </span><br><span class="line">            callback.call(obj);  </span><br><span class="line">        &#125;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="事件的传播"><a href="#事件的传播" class="headerlink" title="事件的传播"></a>事件的传播</h2><ul>
<li><p>关于事件的传播网景公司和微软公司有不同的理解：</p>
<ul>
<li>微软公司认为事件应该是由内向外传播，也就是当事件触发时，应该先触发当前元素上的事件，然后再向当前元素的祖先元素上传播，也就说事件应该在冒泡阶段执行</li>
<li>网景公司认为事件应该是由外向内传播的，也就是当前事件触发时，应该先触发当前元素的最外层的祖先元素的事件，然后在向内传播给后代元素</li>
</ul>
</li>
<li><p>W3C综合了两个公司的方案，将事件传播分成了三个阶段：</p>
<ol>
<li><p>捕获阶段</p>
<ul>
<li>在捕获阶段时从最外层的祖先元素，向目标元素进行事件的捕获，但是默认此时不会触发事件</li>
</ul>
</li>
<li><p>目标阶段</p>
<ul>
<li>事件捕获到目标元素，捕获结束开始在目标元素上触发事件</li>
</ul>
</li>
<li><p>冒泡阶段</p>
<ul>
<li>事件从目标元素向他的祖先元素传递，依次触发祖先元素上的事件</li>
</ul>
</li>
</ol>
</li>
<li><p>如果希望在捕获阶段就触发事件，可以将addEventListener()的第三个参数设置为true</p>
</li>
<li><p>一般情况下我们不会希望在捕获阶段触发事件，所以这个参数一般都是false</p>
</li>
<li><p>IE8及以下的浏览器中没有捕获阶段</p>
</li>
</ul>
<h2 id="常用的事件"><a href="#常用的事件" class="headerlink" title="常用的事件"></a>常用的事件</h2><ul>
<li><p>拖拽事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;  </span><br><span class="line">    &lt;html&gt;  </span><br><span class="line">    &lt;head&gt;  </span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;  </span><br><span class="line">        &lt;title&gt;&lt;&#x2F;title&gt;  </span><br><span class="line">&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;  </span><br><span class="line">    #box1&#123;  </span><br><span class="line">width: 100px;  </span><br><span class="line">height: 100px;  </span><br><span class="line">background-color: red;  </span><br><span class="line">position: absolute;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">#box2&#123;  </span><br><span class="line">width: 100px;  </span><br><span class="line">height: 100px;  </span><br><span class="line">background-color: yellow;  </span><br><span class="line">position: absolute;  </span><br><span class="line">  </span><br><span class="line">left: 200px;  </span><br><span class="line">top: 200px;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">    &lt;&#x2F;style&gt;  </span><br><span class="line">  </span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;  </span><br><span class="line">    window.onload &#x3D; function()&#123;  </span><br><span class="line">    &#x2F;*  </span><br><span class="line">				 * 拖拽box1元素  </span><br><span class="line">				 *  - 拖拽的流程  </span><br><span class="line">				 * 		1.当鼠标在被拖拽元素上按下时，开始拖拽  onmousedown  </span><br><span class="line">				 * 		2.当鼠标移动时被拖拽元素跟随鼠标移动 onmousemove  </span><br><span class="line">				 * 		3.当鼠标松开时，被拖拽元素固定在当前位置	onmouseup  </span><br><span class="line">				 *&#x2F;  </span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F;获取box1  </span><br><span class="line">    var box1 &#x3D; document.getElementById(&quot;box1&quot;);  </span><br><span class="line">    var box2 &#x3D; document.getElementById(&quot;box2&quot;);  </span><br><span class="line">    &#x2F;&#x2F;开启box1的拖拽  </span><br><span class="line">    drag(box1);  </span><br><span class="line">    &#x2F;&#x2F;开启box2的  </span><br><span class="line">    drag(box2);  </span><br><span class="line">  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">&#x2F;*  </span><br><span class="line">			 * 提取一个专门用来设置拖拽的函数  </span><br><span class="line">			 * 参数：开启拖拽的元素  </span><br><span class="line">			 *&#x2F;  </span><br><span class="line">function drag(obj)&#123;  </span><br><span class="line">    &#x2F;&#x2F;当鼠标在被拖拽元素上按下时，开始拖拽  onmousedown  </span><br><span class="line">    obj.onmousedown &#x3D; function(event)&#123;  </span><br><span class="line">        &#x2F;&#x2F;设置box1捕获所有鼠标按下的事件  </span><br><span class="line">        &#x2F;*  </span><br><span class="line">					 * setCapture()  </span><br><span class="line">					 * 	- 只有IE支持，但是在火狐中调用时不会报错，  </span><br><span class="line">					 * 		而如果使用chrome调用，会报错  </span><br><span class="line">					 *&#x2F;  </span><br><span class="line">        &#x2F;*if(box1.setCapture)&#123;  </span><br><span class="line">						box1.setCapture();  </span><br><span class="line">					&#125;*&#x2F;  </span><br><span class="line">        &#x2F;&#x2F;当调用setcapture方法之后，这个元素将会把下一次所有的鼠标按下相关事件捕获到自身上</span><br><span class="line">        obj.setCapture &amp;&amp; obj.setCapture();  </span><br><span class="line">        event &#x3D; event || window.event;  </span><br><span class="line">        &#x2F;&#x2F;div的偏移量 鼠标.clentX - 元素.offsetLeft  </span><br><span class="line">        &#x2F;&#x2F;div的偏移量 鼠标.clentY - 元素.offsetTop  </span><br><span class="line">        var ol &#x3D; event.clientX - obj.offsetLeft;  </span><br><span class="line">        var ot &#x3D; event.clientY - obj.offsetTop;  </span><br><span class="line">        &#x2F;&#x2F;为document绑定一个onmousemove事件  </span><br><span class="line">        document.onmousemove &#x3D; function(event)&#123;  </span><br><span class="line">            event &#x3D; event || window.event;  </span><br><span class="line">            &#x2F;&#x2F;当鼠标移动时被拖拽元素跟随鼠标移动 onmousemove  </span><br><span class="line">            &#x2F;&#x2F;获取鼠标的坐标  </span><br><span class="line">            var left &#x3D; event.clientX - ol;  </span><br><span class="line">            var top &#x3D; event.clientY - ot;  </span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F;修改box1的位置  </span><br><span class="line">            obj.style.left &#x3D; left+&quot;px&quot;;  </span><br><span class="line">            obj.style.top &#x3D; top+&quot;px&quot;;  </span><br><span class="line">  </span><br><span class="line">        &#125;;  </span><br><span class="line">        &#x2F;&#x2F;为document绑定一个鼠标松开事件  </span><br><span class="line">        document.onmouseup &#x3D; function()&#123;  </span><br><span class="line">            &#x2F;&#x2F;当鼠标松开时，被拖拽元素固定在当前位置	onmouseup  </span><br><span class="line">            &#x2F;&#x2F;取消document的onmousemove事件  </span><br><span class="line">            document.onmousemove &#x3D; null;  </span><br><span class="line">            &#x2F;&#x2F;取消document的onmouseup事件  </span><br><span class="line">            document.onmouseup &#x3D; null;  </span><br><span class="line">            &#x2F;&#x2F;当鼠标松开时，取消对事件的捕获  </span><br><span class="line">            obj.releaseCapture &amp;&amp; obj.releaseCapture();  </span><br><span class="line">        &#125;;  </span><br><span class="line"> &#x2F;*  </span><br><span class="line">* 当我们拖拽一个网页中的内容时，浏览器会默认去搜索引擎中搜索内容，  </span><br><span class="line">* 	此时会导致拖拽功能的异常，这个是浏览器提供的默认行为，  </span><br><span class="line">* 	如果不希望发生这个行为，则可以通过return false来取消默认行为  </span><br><span class="line">*   </span><br><span class="line">* 但是这招对IE8不起作用  </span><br><span class="line">*&#x2F;  </span><br><span class="line">        return false;  </span><br><span class="line">    &#125;;  </span><br><span class="line">&#125;  </span><br><span class="line">&lt;&#x2F;script&gt;  </span><br><span class="line">&lt;&#x2F;head&gt;  </span><br><span class="line">&lt;body&gt;   </span><br><span class="line">我是一段文字   </span><br><span class="line">&lt;div id&#x3D;&quot;box1&quot;&gt;&lt;&#x2F;div&gt;  </span><br><span class="line">&lt;div id&#x3D;&quot;box2&quot;&gt;&lt;&#x2F;div&gt;  </span><br><span class="line">&lt;&#x2F;body&gt;  </span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>滚轮事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;  </span><br><span class="line">    &lt;html&gt;  </span><br><span class="line">    &lt;head&gt;  </span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;  </span><br><span class="line">        &lt;title&gt;&lt;&#x2F;title&gt;  </span><br><span class="line">&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;  </span><br><span class="line">  </span><br><span class="line">    #box1&#123;  </span><br><span class="line">width: 100px;  </span><br><span class="line">height: 100px;  </span><br><span class="line">background-color: red;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">    &lt;&#x2F;style&gt;  </span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;  </span><br><span class="line">  </span><br><span class="line">    window.onload &#x3D; function()&#123;  </span><br><span class="line">    &#x2F;&#x2F;获取id为box1的div  </span><br><span class="line">    var box1 &#x3D; document.getElementById(&quot;box1&quot;);  </span><br><span class="line">    &#x2F;&#x2F;为box1绑定一个鼠标滚轮滚动的事件  </span><br><span class="line">    &#x2F;*  </span><br><span class="line">				 * onmousewheel鼠标滚轮滚动的事件，会在滚轮滚动时触发，  </span><br><span class="line">				 * 	但是火狐不支持该属性  </span><br><span class="line">				 *   </span><br><span class="line">				 * 在火狐中需要使用 DOMMouseScroll 来绑定滚动事件  </span><br><span class="line">				 * 	注意该事件需要通过addEventListener()函数来绑定  </span><br><span class="line">				 *&#x2F;  </span><br><span class="line">  </span><br><span class="line">    box1.onmousewheel &#x3D; function(event)&#123;  </span><br><span class="line">        event &#x3D; event || window.event;  </span><br><span class="line">        &#x2F;&#x2F;event.wheelDelta 可以获取鼠标滚轮滚动的方向  </span><br><span class="line">        &#x2F;&#x2F;向上滚 120   向下滚 -120  </span><br><span class="line">        &#x2F;&#x2F;wheelDelta这个值我们不看大小，只看正负  </span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F;alert(event.wheelDelta);  </span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F;wheelDelta这个属性火狐中不支持  </span><br><span class="line">        &#x2F;&#x2F;在火狐中使用event.detail来获取滚动的方向  </span><br><span class="line">        &#x2F;&#x2F;向上滚 -3  向下滚 3  </span><br><span class="line">        &#x2F;&#x2F;alert(event.detail);  </span><br><span class="line">        &#x2F;*  </span><br><span class="line">					 * 当鼠标滚轮向下滚动时，box1变长  </span><br><span class="line">					 * 	当滚轮向上滚动时，box1变短  </span><br><span class="line">					 *&#x2F;  </span><br><span class="line">        &#x2F;&#x2F;判断鼠标滚轮滚动的方向  </span><br><span class="line">        if(event.wheelDelta &gt; 0 || event.detail &lt; 0)&#123;  </span><br><span class="line">            &#x2F;&#x2F;向上滚，box1变短  </span><br><span class="line">            box1.style.height &#x3D; box1.clientHeight - 10 + &quot;px&quot;;  </span><br><span class="line">  </span><br><span class="line">        &#125;else&#123;  </span><br><span class="line">            &#x2F;&#x2F;向下滚，box1变长  </span><br><span class="line">            box1.style.height &#x3D; box1.clientHeight + 10 + &quot;px&quot;;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        &#x2F;*  </span><br><span class="line">					 * 使用addEventListener()方法绑定响应函数，取消默认行为时不能使用return false  </span><br><span class="line">					 * 需要使用event来取消默认行为event.preventDefault();  </span><br><span class="line">					 * 但是IE8不支持event.preventDefault();这个玩意，如果直接调用会报错  </span><br><span class="line">					 *&#x2F;  </span><br><span class="line">        event.preventDefault &amp;&amp; event.preventDefault();  </span><br><span class="line"></span><br><span class="line">        &#x2F;*  </span><br><span class="line">					 * 当滚轮滚动时，如果浏览器有滚动条，滚动条会随之滚动，  </span><br><span class="line">					 * 这是浏览器的默认行为，如果不希望发生，则可以取消默认行为  </span><br><span class="line">					 *&#x2F;  </span><br><span class="line">        return false;  </span><br><span class="line">    &#125;;  </span><br><span class="line">    &#x2F;&#x2F;为火狐绑定滚轮事件  </span><br><span class="line">    bind(box1,&quot;DOMMouseScroll&quot;,box1.onmousewheel);  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">function bind(obj , eventStr , callback)&#123;  </span><br><span class="line">    if(obj.addEventListener)&#123;  </span><br><span class="line">        &#x2F;&#x2F;大部分浏览器兼容的方式  </span><br><span class="line">        obj.addEventListener(eventStr , callback , false);  </span><br><span class="line">    &#125;else&#123;  </span><br><span class="line">        &#x2F;*  </span><br><span class="line">					 * this是谁由调用方式决定  </span><br><span class="line">					 * callback.call(obj)  </span><br><span class="line">					 *&#x2F;  </span><br><span class="line">        &#x2F;&#x2F;IE8及以下  </span><br><span class="line">        obj.attachEvent(&quot;on&quot;+eventStr , function()&#123;  </span><br><span class="line">            &#x2F;&#x2F;在匿名函数中调用回调函数  </span><br><span class="line">            callback.call(obj);  </span><br><span class="line">        &#125;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">&lt;&#x2F;script&gt;  </span><br><span class="line">&lt;&#x2F;head&gt;  </span><br><span class="line">&lt;body style&#x3D;&quot;height: 2000px;&quot;&gt;   </span><br><span class="line">    &lt;div id&#x3D;&quot;box1&quot;&gt;&lt;&#x2F;div&gt;  </span><br><span class="line">&lt;&#x2F;body&gt;  </span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li>键盘事件</li>
</ul>
<ol>
<li><p>onkeydown</p>
<ul>
<li>按键被按下</li>
<li>对于onkeydown来说如果一直按着某个按键不松手，则事件会一直触发</li>
<li>当onkeydown连续触发时，第一次和第二次之间会间隔稍微长一点，其他的会非常的快，这种设计是为了防止误操作的发生</li>
</ul>
</li>
<li><p>onkeyup</p>
<ul>
<li>按键被松开</li>
<li>键盘事件一般都会绑定给一些可以获取到焦点的对象或者是document</li>
</ul>
</li>
<li><p>keyCode</p>
<ul>
<li>可以通过keyCode来获取按键的编码通过它可以判断哪个按键被按下</li>
<li>除了keyCode，事件对象中还提供了几个属性<ul>
<li>altKey</li>
<li>ctrlKey</li>
<li>shiftKey</li>
<li>这个三个用来判断alt ctrl 和<br>shift是否被按下，如果按下则返回true，否则返回false<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;判断一个y是否被按下  </span><br><span class="line"> &#x2F;&#x2F;判断y和ctrl是否同时被按下  </span><br><span class="line"> if(event.keyCode &#x3D;&#x3D;&#x3D; 89 &amp;&amp; event.ctrlKey)&#123;  </span><br><span class="line">     console.log(&quot;ctrl和y都被按下了&quot;);  </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;使文本框中不能输入数字  </span><br><span class="line"> input.onkeydown &#x3D; function(event) &#123;  </span><br><span class="line">     event &#x3D; event || window.event;  </span><br><span class="line">     &#x2F;&#x2F;数字 48 - 57  </span><br><span class="line">     if(event.keyCode &gt;&#x3D; 48 &amp;&amp; event.keyCode &lt;&#x3D; 57) &#123;  </span><br><span class="line">         &#x2F;&#x2F;在文本框中输入内容，属于onkeydown的默认行为  </span><br><span class="line">         &#x2F;&#x2F;如果在onkeydown中取消了默认行为，则输入的内容，不会出现在文本框中  </span><br><span class="line">         return false;  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><ul>
<li>浏览器对象模型(browser object model)</li>
<li>BOM可以使我们通过JS来操作浏览器</li>
<li>在BOM中为我们提供了一组对象，用来完成对浏览器的操作</li>
</ul>
<h2 id="BOM对象"><a href="#BOM对象" class="headerlink" title="BOM对象"></a>BOM对象</h2><ul>
<li>Window<ul>
<li>代表的是整个浏览器的窗口，同时window也是网页中的全局对象</li>
</ul>
</li>
<li>Navigator<ul>
<li>代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器</li>
</ul>
</li>
<li>Location<ul>
<li>代表当前浏览器的地址栏信息，通过Location可以获取地址栏信息，或者操作浏览器跳转页面</li>
</ul>
</li>
<li>History<ul>
<li>代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录<br>由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页，而且该操作只在当次访问时有效</li>
</ul>
</li>
<li>Screen<ul>
<li>代表用户的屏幕的信息，通过该对象可以获取到用户的显示器的相关的信息</li>
</ul>
</li>
<li>这些BOM对象在浏览器中都是作为window对象的属性保存的，可以通过window对象来使用，也可以直接使用</li>
</ul>
<h2 id="Navigator"><a href="#Navigator" class="headerlink" title="Navigator"></a>Navigator</h2><ul>
<li>代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器</li>
<li>由于历史原因，Navigator对象中的大部分属性都已经不能帮助我们识别浏览器了，一般我们只会使用userAgent来判断浏览器的信息，</li>
<li>userAgent是一个字符串，这个字符串中包含有用来描述浏览器信息的内容，不同的浏览器会有不同的userAgent<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;通过userAgent判断浏览器类型</span><br><span class="line"></span><br><span class="line">alert(navigator.appName);   </span><br><span class="line">var ua &#x3D; navigator.userAgent;  </span><br><span class="line"></span><br><span class="line">if(firefoxi.test(ua))&#123;  </span><br><span class="line">alert(&quot;你是火狐！！！&quot;);  </span><br><span class="line">&#125;else if(chromei.test(ua))&#123;  </span><br><span class="line">alert(&quot;你是Chrome&quot;);  </span><br><span class="line">&#125;else if(msiei.test(ua))&#123;  </span><br><span class="line">alert(&quot;你是IE浏览器~~~&quot;);  </span><br><span class="line">&#x2F;&#x2F;通过userAgent不能判断浏览器类型时，还可以通过一些浏览器特有的对象来判断浏览器信息，比如：ActiveXObject</span><br><span class="line">&#125;else if(&quot;ActiveXObject&quot; in window)&#123;  </span><br><span class="line">alert(&quot;你是IE11，枪毙了你~~~&quot;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="History"><a href="#History" class="headerlink" title="History"></a>History</h2><ul>
<li>对象可以用来操作浏览器向前或向后翻页</li>
<li>length<ul>
<li>可以获取到当次访问的链接数量</li>
</ul>
</li>
<li>back()<ul>
<li>可以用来回退到上一个页面，作用和浏览器的回退按钮一样</li>
</ul>
</li>
<li>forward()<ul>
<li>可以跳转下一个页面，作用和浏览器的前进按钮一样</li>
</ul>
</li>
<li>go()<ul>
<li>可以用来跳转到指定的页面</li>
<li>它需要一个整数作为参数<ul>
<li>1:表示向前跳转一个页面 相当于forward()</li>
<li>2:表示向前跳转两个页面</li>
<li>-1:表示向后跳转一个页面</li>
<li>-2:表示向后跳转两个页面</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h2><ul>
<li>该对象中封装了浏览器的地址栏的信息</li>
<li>如果直接打印location，则可以获取到地址栏的信息（当前页面的完整路径）</li>
<li>alert(location);<ul>
<li>如果直接将location属性修改为一个完整的路径或相对路径，则我们页面会自动跳转到该路径，并且会生成相应的历史记录<ul>
<li>location = “http:<a href="http://www.baidu.com" target="_blank" rel="noopener" ">www.baidu.com”</a>;</li>
<li>location = “01.BOM.html”;</li>
</ul>
</li>
</ul>
</li>
<li>assign()<ul>
<li>用来跳转到其他的页面，作用和直接修改location一样</li>
</ul>
</li>
<li>reload()<ul>
<li>用于重新加载当前页面，作用和刷新按钮一样</li>
<li>如果在方法中传递一个true，作为参数，则会强制清空缓存刷新页面<br>location.reload(true);</li>
</ul>
</li>
<li>replace()<ul>
<li>可以使用一个新的页面替换当前页面，调用完毕也会跳转页面<br>不会生成历史记录，不能使用回退按钮回退</li>
</ul>
</li>
</ul>
<h2 id="window"><a href="#window" class="headerlink" title="window"></a>window</h2><ul>
<li><p>定时调用</p>
</li>
<li><p>setInterval()</p>
<ul>
<li>可以将一个函数，每隔一段时间执行一次</li>
<li>参数：<ul>
<li>1.回调函数，该函数会每隔一段时间被调用一次</li>
<li>2.每次调用间隔的时间，单位是毫秒</li>
</ul>
</li>
<li>返回值：<ul>
<li>返回一个Number类型的数据</li>
<li>这个数字用来作为定时器的唯一标识</li>
</ul>
</li>
</ul>
</li>
<li><p>clearInterval()</p>
<ul>
<li>可以用来关闭一个定时器</li>
<li>方法中需要一个定时器的标识作为参数，这样将关闭标识对应的定时器</li>
<li>clearInterval()可以接收任意参数，如果参数是一个有效的定时器的标识，则停止对应的定时器,如果参数不是一个有效的标识，则什么也不做<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var num &#x3D; 1;  </span><br><span class="line">var timer &#x3D; setInterval(function() &#123;  </span><br><span class="line">    count.innerHTML &#x3D; num++;  </span><br><span class="line">    if(num &#x3D;&#x3D; 11) &#123;  </span><br><span class="line">        &#x2F;&#x2F;关闭定时器  </span><br><span class="line">        clearInterval(timer);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>延时调用</p>
</li>
<li><p>setTimeout</p>
<ul>
<li>参数：<ul>
<li>1.回调函数，该函数会在一段时间后被调用一次</li>
<li>2.每次调用的时间，单位是毫秒</li>
</ul>
</li>
<li>延时调用一个函数不马上执行，而是隔一段时间以后在执行，而且只会执行一次</li>
<li>延时调用和定时调用的区别，定时调用会执行多次，而延时调用只会执行一次，延时调用和定时调用实际上是可以互相代替的，在开发中可以根据自己需要去选择</li>
<li>使用clearTimeout()来关闭一个延时调用clearTimeout(timer);</li>
</ul>
</li>
</ul>
<h1 id="类的操作"><a href="#类的操作" class="headerlink" title="类的操作"></a>类的操作</h1><h2 id="直接修改元素的类css"><a href="#直接修改元素的类css" class="headerlink" title="直接修改元素的类css"></a>直接修改元素的类css</h2><ul>
<li><p>通过style属性来修改元素的样式，每修改一个样式，浏览器就需要重新渲染一次页面，这样的执行的性能是比较差的，而且这种形式当我们要修改多个样式时，也不太方便<br>我希望一行代码，可以同时修改多个样式，<strong>我们可以通过修改元素的class属性来间接的修改样式</strong>，这样一来，我们只需要修改一次，即可同时修改多个样式，浏览器只需要重新渲染页面一次，性能比较好，并且这种方式，可以使表现和行为进一步的分离</p>
<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><blockquote>
<p>JavaScript Object Notation JS对象表示法</p>
</blockquote>
</li>
</ul>
<h2 id="JSON-格式"><a href="#JSON-格式" class="headerlink" title="JSON-格式"></a>JSON-格式</h2><ul>
<li>复合类型的值只能是数组或对象，<strong>不能是函数</strong>、正则表达式对象、日期对象</li>
<li>原始类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和null（不能使用NaN,<br>Infinity, -Infinity和undefined）</li>
<li>字符串必须使用双引号表示，不能使用单引号。</li>
<li>对象的键名必须放在双引号里面。</li>
<li>数组或对象最后一个成员的后面，不能加逗号。</li>
<li>JS中的对象只有JS自己认识，其他的语言都不认识</li>
<li>JSON就是一个特殊格式的字符串，这个字符串可以被任意的语言所识别，并且可以转换为任意语言中的对象，JSON在开发中主要用来数据的交互</li>
<li>JSON和JS对象的格式一样，只不过JSON字符串中的属性名必须加双引号,其他的和JS语法一致</li>
</ul>
<h2 id="JSON分类："><a href="#JSON分类：" class="headerlink" title="JSON分类："></a>JSON分类：</h2><ol>
<li>对象 {}</li>
<li>数组 []</li>
</ol>
<h2 id="JSON中允许的值："><a href="#JSON中允许的值：" class="headerlink" title="JSON中允许的值："></a>JSON中允许的值：</h2><ol>
<li>字符串</li>
<li>数值</li>
<li>布尔值</li>
<li>null</li>
<li>对象</li>
<li>数组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line"></span><br><span class="line">var arr &#x3D; &#39;[1,2,3,&quot;hello&quot;,true]&#39;;  </span><br><span class="line">var obj2 &#x3D; &#39;&#123;&quot;arr&quot;:[1,2,3]&#125;&#39;;    </span><br><span class="line">var arr2 &#x3D;&#39;[&#123;&quot;name&quot;:&quot;孙悟空&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;男&quot;&#125;,&#123;&quot;name&quot;:&quot;孙悟空&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;男&quot;&#125;]&#39;;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="JSON工具类"><a href="#JSON工具类" class="headerlink" title="JSON工具类"></a>JSON工具类</h2><ul>
<li><strong>JSON -&gt; JS对象</strong></li>
<li>JSON.parse()<ul>
<li>可以将以JSON字符串转换为js对象</li>
<li>它需要一个JSON字符串作为参数，会将该字符串转换为JS对象并返回<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var o &#x3D; JSON.parse(json);</span><br><span class="line">var o2 &#x3D; JSON.parse(arr);</span><br><span class="line"></span><br><span class="line">var obj3 &#x3D; &#123;name:”猪八戒” , age:28 , gender:”男”&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>JS对象 -&gt; JSON</strong></li>
<li>JSON.stringify()<ul>
<li>可以将一个JS对象转换为JSON字符串</li>
<li>需要一个js对象作为参数，会返回一个JSON字符串<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var str &#x3D; JSON.stringify(obj3);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>JSON这个对象在IE7及以下的浏览器中不支持，所以在这些浏览器中调用时会报错</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>eval()<ul>
<li>这个函数可以用来执行一段字符串形式的JS代码，并将执行结果返回</li>
<li>如果使用eval()执行的字符串中含有{},它会将{}当成是代码块</li>
<li>如果不希望将其当成代码块解析，则需要在字符串前后各加一个()</li>
<li>eval()这个函数的功能很强大，可以直接执行一个字符串中的js代码，但是在开发中尽量不要使用，首先它的执行性能比较差，然后它还具有安全隐患<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line"></span><br><span class="line">var str &#x3D; &#39;&#123;&quot;name&quot;:&quot;孙悟空&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;男&quot;&#125;&#39;;  </span><br><span class="line">var obj &#x3D; eval(&quot;(&quot;+str+&quot;)&quot;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>confirm()<ul>
<li>用于弹出一个带有确认和取消按钮的提示框，和alert一样，但是他有两个按钮</li>
<li>需要一个字符串作为参数，该字符串将会作为提示文字显示出来</li>
<li>如果用户点击确认则会返回true，如果点击取消则返回false</li>
</ul>
</li>
</ul>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a></div><div class="social-share pull-right" data-disabled="Linkedin,点点,Facebook,Twitter"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/07/08/JS%E9%AB%98%E7%BA%A7/"><i class="fa fa-chevron-left">  </i><span>JS高级</span></a></div><div class="next-post pull-right"><a href="/2020/07/04/htmlcss/"><span>HTML5 CSS3</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'true' == true ? true : false;
var verify = 'true' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'YiMuUS8mJ9iQH4i0HKdegAjN-gzGzoHsz',
  appKey:'S42xmXqdEnhtc3ibq7F71WYu',
  placeholder:'Just go go',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'5',
  lang: 'zh-cn'
})</script></div></div><footer class="footer-bg" style="background-image: url(https://w.wallhaven.cc/full/g7/wallhaven-g75r7d.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2022 By XYX</div><div class="framework-info"></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span></span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;"></a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>