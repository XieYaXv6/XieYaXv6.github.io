<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="JavaScript"><meta name="keywords" content="JavaScript"><meta name="author" content="XYX"><meta name="copyright" content="XYX"><title>JavaScript | XYX's Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="XYX's Blog" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#js基本语法"><span class="toc-number">1.</span> <span class="toc-text">js基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#引入js"><span class="toc-number">1.1.</span> <span class="toc-text">引入js</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#标识符"><span class="toc-number">1.2.</span> <span class="toc-text">标识符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据类型"><span class="toc-number">1.3.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运算符"><span class="toc-number">1.4.</span> <span class="toc-text">运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#break和continue"><span class="toc-number">1.5.</span> <span class="toc-text">break和continue</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#对象"><span class="toc-number">2.</span> <span class="toc-text">对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#分类"><span class="toc-number">2.1.</span> <span class="toc-text">分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建对象"><span class="toc-number">2.2.</span> <span class="toc-text">创建对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数"><span class="toc-number">2.3.</span> <span class="toc-text">函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#作用域"><span class="toc-number">2.4.</span> <span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this"><span class="toc-number">2.5.</span> <span class="toc-text">this</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造函数"><span class="toc-number">2.6.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#原型-prototype"><span class="toc-number">2.7.</span> <span class="toc-text">原型 prototype</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#toString方法"><span class="toc-number">2.8.</span> <span class="toc-text">toString方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#垃圾回收"><span class="toc-number">2.9.</span> <span class="toc-text">垃圾回收</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#未完待续···"><span class="toc-number">3.</span> <span class="toc-text">未完待续···</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">XYX</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">3</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">3</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">2</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(http://www.xyx6.top/img/top/top.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">XYX's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">JavaScript</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-07-05</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%A4%A7%E5%9D%97/">前端三大块</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote>
<p>序<br><br>终于开始学前端的核心内容了！学好JS才能为后面的jQuery( JavaScript 库)和JS框架(React,Vue,Angular)打好基础，冲冲冲！</p>
</blockquote>
<a id="more"></a>

<h1 id="js基本语法"><a href="#js基本语法" class="headerlink" title="js基本语法"></a>js基本语法</h1><h2 id="引入js"><a href="#引入js" class="headerlink" title="引入js"></a>引入js</h2><ul>
<li><p>可以编写到标签的onclick属性中，也可以写在标签的属性中，但是他们属于行为和结构耦合，不方便维护，不推荐</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"alert('xxx')"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:alert('xxx')"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以写在标签或者外部文件中</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>js标签一旦引入外部文件了，就不能再编码了，即使编写了浏览器也会忽略；如果需要则可以再创建一个新的script标签用于编写内部代码，执行顺序按从上至下依次执行。</p>
</li>
</ul>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><ul>
<li>在js中所有的可以由我们自主命名的都可以成为标识符</li>
<li>例如：变量名，函数名，属性名等等</li>
<li>命名一个标识符需要遵守如下规则：<ol>
<li>标识符可以包含字母，数字，_，$</li>
<li>标识符不能以数字开头</li>
<li>标识符不能是关键字和保留字</li>
</ol>
</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li><p>数据类型</p>
<p>String，Number，Boolean，Null，Undefined，Object(object不属于基本数据类型)</p>
</li>
<li><p>数组</p>
<blockquote>
<p>用方括号书写，数组的项目由逗号分隔。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">下面的代码声明（创建）了名为 cars 的数组，包含三个项目（汽车品牌）：</span><br><span class="line"><span class="keyword">var</span> cars = [<span class="string">"Porsche"</span>, <span class="string">"Volvo"</span>, <span class="string">"BMW"</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>typeof 运算符</p>
<p>可使用typeof 来确定 JavaScript 变量的类型,typeof 运算符返回变量或表达式的类型</p>
</li>
<li><p>进制</p>
<ol>
<li>表示16进制的数字，需要0x开头</li>
<li>表示8进制的数字，需要0开头</li>
<li>表示2进制的数字，需要0b开头</li>
</ol>
</li>
<li><p>强制转换</p>
<ol>
<li>将其他数据类型转换为String<ul>
<li>方法一：调用被转换数据类型的toString()方法</li>
<li>该方法不影响原变量，他会将转换的结果返回</li>
<li>但是注意null和undefined这两个值没有toString()方法，会报错</li>
<li>方法二：调用String()函数，并将被转换的数据作为参数传递给函数</li>
<li>使用String()函数强制转换时，对于Number和Boolean实际上就是调用toString()方法，但是对于null和undefined就会将他们转换为字符串”null”和”undefined”</li>
</ul>
</li>
<li>将其他数据类型转换为Number<ul>
<li>方法一：使用Number()函数</li>
<li>如果字符串中有非数字的内容，则转换为NaN</li>
<li>如果字符串是空或者是全空格，则转换为0</li>
<li>方法二：这种方法专用于字符串</li>
<li>parseInt()把一个字符串转换为一个整数 //将一个字符串中的有效内容的整数内容读取出来转换为Number</li>
<li>parseFloat()把一个字符串转换为一个浮点数//将一个字符串中的有效内容的小数内容读取出来转换为Number</li>
<li>可以用一元的+来进行隐式的类型转换</li>
</ul>
</li>
<li>将其他数据类型转换为Boolean<ul>
<li>使用Boolean()函数<ul>
<li>数字-&gt;布尔(除了0和NaN，其余都是true)</li>
<li>字符串-&gt;布尔(除了空串，其余都是true)</li>
<li>null和undefined都会转换为false</li>
<li>对象也会转换为true</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul>
<li><p>逻辑运算符</p>
<ul>
<li><p>!</p>
<p>非运算可以对一个布尔值进行取反，true变false false边true<br>当对非布尔值使用!时，会先将其转换为布尔值然后再取反<br>我们可以利用!来将其他的数据类型转换为布尔值</p>
</li>
<li><p>&amp;&amp;</p>
<p>&amp;&amp;可以对符号两侧的值进行与运算<br>只有两端的值都为true时，才会返回true。只要有一个false就会返回false。<br>与是一个短路的与，如果第一个值是false，则不再检查第二个值<br>对于非布尔值，它会将其转换为布尔值然后做运算，并返回原值<br>规则：</p>
</li>
</ul>
<p>   1.如果第一个值为false，则返回第一个值<br>   2.如果第一个值为true，则返回第二个值</p>
<ul>
<li><p>||</p>
<p>||可以对符号两侧的值进行或运算<br>只有两端都是false时，才会返回false。只要有一个true，就会返回true。<br>或是一个短路的或，如果第一个值是true，则不再检查第二个值<br>对于非布尔值，它会将其转换为布尔值然后做运算，并返回原值<br>规则：1. 如果第一个值为true，则返回第一个值2. 如果第一个值为false，则返回第二个值</p>
</li>
</ul>
</li>
</ul>
<h2 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h2><ul>
<li>break关键字可以用来退出switch或循环语句</li>
<li>不能在if语句中使用break和continue</li>
<li>break关键字，会立即终止离他最近的那个循环语句</li>
<li>continue可以跳过当次循环</li>
</ul>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><blockquote>
<p>对象属于一种复合的数据类型，在对象中可以保存多个不同数据类型的属性</p>
</blockquote>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ol>
<li>内建对象<ul>
<li>由ES标准中定义的对象，在任何的ES的实现中都可以使用</li>
<li>比如：Math String Number Boolean Function Object…</li>
</ul>
</li>
<li>宿主对象<ul>
<li>由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象</li>
<li>比如：BOM DOM</li>
</ul>
</li>
<li>自定义对象<ul>
<li>由开发人员自己创建的对象</li>
</ul>
</li>
</ol>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><ol>
<li>方法一<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>基本数据类型的数据，变量是直接保存的它的值。</li>
<li>变量与变量之间是互相独立的，修改一个变量不会影响其他的变量。</li>
<li>引用数据类型的数据，对象是保存在堆内存中的，每创建一个新对象，就会在堆内存中开辟一个新的空间，而变量保存的是对象的内存地址，如果两个变量保存的是同一个对象引用，当我们通过一个变量修改属性时，另一个也会受到影响</li>
<li>当两个引用数据类型比较时，比较的是对象的内存地址</li>
</ul>
<ol start="2">
<li>方法二<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>使用对象字面量可以在创建对象的时候，直接指定对象中的属性</li>
<li>语法：{属性名：属性值，属性名：属性值，···}//要是属性名过于特殊，则要加引号</li>
</ul>
<ol start="3">
<li>向对象中添加属性<ul>
<li>语法：对象.属性名=属性值;</li>
<li>对象[“属性名”] = 属性值; 这种方式能够使用特殊的属性名</li>
<li>对象的属性名没有任何要求，不需要遵守标识符的规范，但是在开发中，尽量按照标识符的要求去写。属性值也可以任意的数据类型。</li>
</ul>
</li>
<li>读取对象中的属性<ul>
<li>语法：对象.属性名</li>
<li>对象[“属性名”] ;“属性名”可以使字符串常量，也可以是字符串变量</li>
<li>如果读取一个对象中没有的属性，它不会报错，而是返回一个undefined</li>
</ul>
</li>
<li>修改对象中的属性<ul>
<li>语法：对象.属性值=新值</li>
</ul>
</li>
<li>删除对象中的属性<ul>
<li>语法：delete 对象.属性名  <pre><code>delete 对象[&quot;属性名&quot;]</code></pre></li>
</ul>
</li>
</ol>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><blockquote>
<p>函数也是一个对象，函数主要用来封装一些功能</p>
</blockquote>
<ol>
<li>创建函数  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">函数声明</span><br><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params">形参<span class="number">1</span>,形参<span class="number">2.</span>..形参N</span>)</span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">语句...  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">函数表达式：将要封装的代码以字符串的形式传递给构造函数</span><br><span class="line"><span class="keyword">var</span> 函数名 = <span class="function"><span class="keyword">function</span>(<span class="params">形参<span class="number">1</span>,形参<span class="number">2.</span>..形参N</span>)</span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">语句...  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>立即执行函数<ul>
<li>函数定义完，立即被调用，这种函数叫做立即执行函数</li>
<li>立即执行函数往往只会执行一次<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;  </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"a = "</span>+a);  </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"b = "</span>+b);  </span><br><span class="line">&#125;)(<span class="number">123</span>,<span class="number">456</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>枚举对象中的属性  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> 变量 <span class="keyword">in</span> 对象)&#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><ol>
<li>全局作用域<ul>
<li>直接在script标签中编写的代码都运行在全局作用域中 </li>
<li>全局作用域在页面打开时创建，在页面关闭时销毁</li>
<li>在全局作用域中有一个全局对象window，他代表的是一个浏览器的窗口，他由浏览器创建时我们可以直接使用</li>
<li>在全局作用域中创建的变量都会作为window对象的属性保存</li>
<li>在全局作用域中创建的函数都会作为window对象的方法保存</li>
<li>在全局作用域中创建的变量和函数可以在页面的任意位置访问</li>
<li>在函数作用域中也可以访问到全局作用域的变量</li>
</ul>
</li>
<li>函数作用域<ul>
<li>调用函数时创建函数作用域，函数执行完毕后，函数作用域销毁</li>
<li>每调用一个函数就会创建一个新的函数作用域，他们之间是相互独立的</li>
<li>在函数作用域中可以访问到全局作用域的变量</li>
<li>在全局作用域中无法访问到函数作用域的变量</li>
<li>当在函数作用域中操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用，如果没有就向上一级的作用域中寻找，直到找到全局作用域，若全局作用域中还没有，则会报错</li>
</ul>
</li>
<li>变量的声明提前<ul>
<li>在全局作用域中，使用var关键字声明的变量会在所有代码执行前被声明(但是不会被赋值)，但是如果声明变量不使用var关键字，则变量不会被声明提前</li>
<li>在函数作用域中，也具有同上特性，使用var关键字声明的变量会在函数所有的代码执行前被声明，如果没有使用var关键字声明变量，则变量会变成全局变量</li>
</ul>
</li>
<li>函数的声明提前<ul>
<li>使用函数声明形式创建的函数function 函数名(){},他会在所有代码执行前被创建，所以我们可以在函数声明前调用函数；使用函数表达式(var fun = function(){})创建的函数没有该特性</li>
<li>在函数作用域中，使用函数声明创建的函数，会在所有的函数中的代码执行之前就被创建好了</li>
</ul>
</li>
</ol>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><blockquote>
<p>我们每次调用函数时，解析器都会将一个上下文对象作为隐含的参数传递进函数。<br>使用this来引用上下文对象，根据函数的调用形式不同，this的值也不同。</p>
</blockquote>
<ul>
<li>this的不同的情况：<ol>
<li>以函数的形式调用时，this是window</li>
<li>以方法的形式调用时，this就是调用方法的对象</li>
<li>以构造函数的形式调用时，this就是新创建的对象</li>
</ol>
</li>
</ul>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ul>
<li>一个构造函数我们也可以称为一个类</li>
<li>通过一个构造函数创建的对象，我们称该对象时这个构造函数的实例</li>
<li>可以用 instanceof 用来检查一个对象是否是一个类的实例</li>
<li>通过同一个构造函数创建的对象，我们称为一类对象</li>
<li>构造函数就是一个普通的函数，只是他的调用方式不同，如果直接调用，它就是一个普通函数，如果使用new来调用，则它就是一个构造函数</li>
<li>构造函数的执行流程：<ol>
<li>创建一个新的对象</li>
<li>将新建的对象设置为函数中的this，在构造函数中用this来引用新建的对象</li>
<li>执行函数中的代码</li>
<li>将新建的对象返回<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> eg:</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name , age , gender</span>)</span>&#123;  </span><br><span class="line"> <span class="keyword">this</span>.name = name;  </span><br><span class="line"> <span class="keyword">this</span>.age = age;  </span><br><span class="line"> <span class="keyword">this</span>.gender = gender;  </span><br><span class="line"> <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">   alert(<span class="keyword">this</span>.name);  </span><br><span class="line">&#125;;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h2 id="原型-prototype"><a href="#原型-prototype" class="headerlink" title="原型 prototype"></a>原型 prototype</h2><ul>
<li>我们所创建的每一个函数，解析器都会像函数中添加一个属性prototype</li>
<li>prototype属性指向的是一个对象，这个对象我们称为原型对象</li>
<li>当函数作为构造函数使用，<strong>它所创建的对象中都会有一个隐含的属性执行该原型对象</strong>，并且这个隐含的属性可以通过对象.<strong>proto</strong>来访问</li>
<li>当我们访问对象的一个属性或者是方法是，他会先在对象自身中寻找，如果有就直接使用；如果没有就回去原型对象中寻找，找到则直接使用</li>
<li>原型对象就相当于一个公共的区域，凡是通过同一个构造函数创建的对象他们通常都可以访问到相同的原型对象</li>
<li>举例：<br><img src="/2020/07/05/JavaScript/js%E5%8E%9F%E5%9E%8B.png" alt="原型图解"></li>
<li><strong>作用：如果将构造函数中的函数定义在全局作用域中，污染了全局作用域的命名空间，而且定义在全局作用域中很不安全，所以我们可以将对象共有的属性和方法放在原型对象中，这样既不用分别为每一个对象添加，也不会影响全局作用域，就可以使每个对啊ing都具有这些属性和方法了</strong></li>
<li>hasOwnProperty()<blockquote>
<p>这个方法可以用来检查对象自身中是否含有某个属性</p>
<blockquote>
<p>语法：对象.hasOwnProperty(“属性名”)</p>
</blockquote>
</blockquote>
</li>
<li>原型也是对象，所以他也有原型<blockquote>
<p>当我们使用一个对象或方法时，会先在自身中寻找，自身要是有就直接使用</p>
<blockquote>
<p>如果自身没有就去原型对象中寻找，如果有就直接使用</p>
<blockquote>
<p>如果原型对象中还没有，就去原型的原型中去寻找，直到找到object对象（object没有以原型），如果还没找到就返回undefined<br><img src="/2020/07/05/JavaScript/%E5%8E%9F%E5%9E%8B%E7%9A%84%E5%8E%9F%E5%9E%8B.png" alt="原型图解"> </p>
</blockquote>
</blockquote>
</blockquote>
</li>
</ul>
<h2 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h2><ul>
<li>当我们直接在页面中打印一个对象时，事实上是输出的对象的toString()方法的返回值<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//修改Person原型的toString方法的返回值  </span></span><br><span class="line">   Person.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="string">"Person[name="</span>+<span class="keyword">this</span>.name+<span class="string">",age="</span>+<span class="keyword">this</span>.age+<span class="string">",gender="</span>+<span class="keyword">this</span>.gender+<span class="string">"]"</span>;  </span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2></li>
<li>就像人生活的时间长了会产生垃圾一样，程序运行过程中也会产生垃圾,这些垃圾积攒过多以后，会导致程序运行的速度过慢，所以我们需要一个垃圾回收的机制，来处理程序运行过程中产生垃圾</li>
<li>当一个对象没有任何的变量或属性对它进行引用，此时我们将永远无法操作该对象，此时这种对象就是一个垃圾，这种对象过多会占用大量的内存空间，导致程序运行变慢，所以这种垃圾必须进行清理。</li>
<li>在JS中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁，我们不需要也不能进行垃圾回收的操作，<strong>我们需要做的只是要将不再使用的对象设置null即可</strong></li>
</ul>
<h1 id="未完待续···"><a href="#未完待续···" class="headerlink" title="未完待续···"></a>未完待续···</h1></div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a></div><nav id="pagination"><div class="next-post pull-right"><a href="/2020/07/04/htmlcss/"><span>HTML CSS</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'true' == true ? true : false;
var verify = 'true' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'YiMuUS8mJ9iQH4i0HKdegAjN-gzGzoHsz',
  appKey:'S42xmXqdEnhtc3ibq7F71WYu',
  placeholder:'Just go go',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10',
  lang: 'zh-cn'
})</script></div></div><footer class="footer-bg" style="background-image: url(http://www.xyx6.top/img/top/top.png)"><div class="layout" id="footer"><div class="copyright">&copy;2020 By XYX</div><div class="framework-info"></div><div class="footer_custom_text">hitokoto</div><div class="icp"><a><span>鲁ICP备20021450号</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>