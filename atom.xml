<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XYX&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xyx6.top/"/>
  <updated>2020-07-11T07:07:11.181Z</updated>
  <id>http://xyx6.top/</id>
  
  <author>
    <name>XYX</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>jQuery</title>
    <link href="http://xyx6.top/2020/07/10/jQuery/"/>
    <id>http://xyx6.top/2020/07/10/jQuery/</id>
    <published>2020-07-10T07:31:36.000Z</published>
    <updated>2020-07-11T07:07:11.181Z</updated>
    
    <content type="html"><![CDATA[<h1 id="了解jQuery"><a href="#了解jQuery" class="headerlink" title="了解jQuery"></a>了解jQuery</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>一个JS函数库: write less, do more</li><li>封装简化DOM操作(CRUD) / Ajax<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2></li><li>强大选择器: 方便快速查找DOM元素</li><li>隐式遍历(迭代): 一次操作多个元素</li><li>读写合一: 读数据/写数据用的是一个函数</li><li>链式调用: 可以通过.不断调用jQuery对象的方法</li><li>事件处理</li><li>DOM操作(CUD)</li><li>样式操作</li><li>动画</li><li>浏览器兼容<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2></li><li>引入jQuery库<ul><li>本地引入与CDN远程引入<ul><li>CDN远程引入网站：<a href="https://www.bootcdn.cn/" target="_blank" rel="noopener">BootCDN</a></li></ul></li><li>测试版与生产版(压缩版)</li></ul></li><li>使用jQuery<ul><li>使用jQuery函数: $/jQuery</li><li>使用jQuery对象: $xxx(执行$()得到的)<h2 id="多库共存"><a href="#多库共存" class="headerlink" title="多库共存"></a>多库共存</h2></li></ul></li><li>问题 : 如果有2个库都有$, 就存在冲突</li><li>解决 : jQuery库可以释放$的使用权, 让另一个库可以正常使用, 此时jQuery库只能使用jQuery了</li><li>API : jQuery.noConflict()</li></ul><h1 id="jQuery的2把利器"><a href="#jQuery的2把利器" class="headerlink" title="jQuery的2把利器"></a>jQuery的2把利器</h1><h2 id="jQuery函数-jQuery"><a href="#jQuery函数-jQuery" class="headerlink" title="jQuery函数: $/jQuery"></a>jQuery函数: $/jQuery</h2><ul><li><p>jQuery向外暴露的就是jQuery函数, 可以直接使用</p></li><li><p>当成一般函数使用人: $(param)</p><ul><li>param是function: 相当于window.onload = function(文档加载完成的监听)</li><li>param是选择器字符串: 查找所有匹配的DOM元素, 返回包含所有DOM元素的jQuery对象</li><li>param是DOM元素: 将DOM元素对象包装为jQuery对象返回  $(this)</li><li>param是标签字符串: 创建标签DOM元素对象并包装为jQuery对象返回<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  例子：</span><br><span class="line">    <span class="comment">//1). 参数为函数 : 当DOM加载完成后，执行其中的函数     回调函数</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//2). 参数为选择器(selector)字符串: 查找所有匹配的标签, 并将它们封装成jQuery对象</span></span><br><span class="line">  <span class="keyword">var</span> $btn = $(<span class="string">"#btn"</span>)</span><br><span class="line">  $btn.click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//this就是发生事件的dom元素对象(也就是button)</span></span><br><span class="line">    <span class="comment">//3). 参数为DOM对象: 将dom对象封装成jQuery对象</span></span><br><span class="line">    <span class="keyword">var</span> text = $(<span class="keyword">this</span>).html()</span><br><span class="line">    alert(text)</span><br><span class="line">    <span class="comment">//4). 参数为html标签字符串 (用得少): 创建标签对象并封装成jQuery对象</span></span><br><span class="line">    $(<span class="string">'&lt;input type="text" name="msg3" /&gt;&lt;br /&gt;'</span>).appendTo(<span class="string">'div'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>当成对象使用: $.xxx</p><ul><li>each(obj/arr, function(key, value){})</li><li>trim(str)  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  例子：</span><br><span class="line">    <span class="comment">/*需求2. 遍历输出数组中所有元素值*/</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">123</span>, <span class="string">'xxx'</span>, <span class="literal">true</span>]</span><br><span class="line"><span class="comment">// 1). $.each() : 隐式遍历数组</span></span><br><span class="line">$.each(arr, <span class="function"><span class="keyword">function</span> (<span class="params">index, item</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'第'</span> + (index + <span class="number">1</span>) + <span class="string">'个元素的值为'</span> + item)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*需求3. 去掉"  my atguigu  "两端的空格*/</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"  my xxx  "</span></span><br><span class="line"><span class="comment">// 2). $.trim() : 去除两端的空格</span></span><br><span class="line"><span class="built_in">console</span>.log(str.trim() === <span class="string">'my xxx'</span>)</span><br><span class="line"><span class="built_in">console</span>.log($.trim(str) === <span class="string">'my xxx'</span>) <span class="comment">//true</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="jQuery对象"><a href="#jQuery对象" class="headerlink" title="jQuery对象"></a>jQuery对象</h2><ul><li>包含所有匹配的n个DOM元素的伪数组对象</li><li>执行$()返回的就是jQuery对象</li><li>基本行为:<ul><li>length/size(): 得到dom元素的个数</li><li>[index] : 得到指定下标对应的dom元素</li><li>each(function(index, domEle){}): 遍历所有dom元素</li><li>index(): 得到当前dom元素在所有兄弟中的下标<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> $btns = $(<span class="string">'button'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log($btns)</span><br><span class="line">  <span class="comment">// 需求1. 统计一共有多少个按钮</span></span><br><span class="line">    <span class="comment">/*size()/length: 包含的DOM元素个数*/</span></span><br><span class="line">  <span class="built_in">console</span>.log($btns.size(), $btns.length)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 需求2. 取出第2个button的文本</span></span><br><span class="line">    <span class="comment">/*[index]/get(index): 得到对应位置的DOM元素*/</span></span><br><span class="line">  <span class="built_in">console</span>.log($btns[<span class="number">1</span>].innerHTML, $btns.get(<span class="number">1</span>).innerHTML)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 需求3. 输出所有button标签的文本</span></span><br><span class="line">    <span class="comment">/*each(): 遍历包含的所有DOM元素*/</span></span><br><span class="line">  $btns.each(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.innerHTML)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 需求4. 输出'测试三'按钮是所有按钮中的第几个</span></span><br><span class="line">    <span class="comment">/*index(): 得到在所在兄弟元素中的下标*/</span></span><br><span class="line">  <span class="built_in">console</span>.log($(<span class="string">'#btn3'</span>).index())</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li><li>伪数组<ol><li>object对象</li><li>length属性</li><li>数值下标属性</li><li><strong>没有数组特别的方法</strong>：例如foreach()<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义一个位数组</span></span><br><span class="line"><span class="keyword">var</span> weiarr=&#123;&#125;</span><br><span class="line">weiarr.length=<span class="number">0</span></span><br><span class="line">weiarr[<span class="number">0</span>]=<span class="string">'xxxx'</span></span><br><span class="line">weiarr.length=<span class="number">1</span></span><br><span class="line">weiarr[<span class="number">0</span>]=<span class="number">123</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><h1 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><ul><li>有特定语法规则(css选择器)的字符串</li><li>用来查找某个/些DOM元素: $(selector)<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2></li><li>基本选择器<ul><li>#id: id选择器</li><li>element : 元素选择器</li><li>.class: 属性选择器</li><li>selector1,selector2,selector3: 并集</li><li>selector1selector2selector3: 交集</li><li>: 任意标签</li></ul></li><li>层次选择器<ul><li>查找子元素, 后代元素, 兄弟元素的选择器</li><li>selector1&gt;selector2: 子元素</li><li>selector1 selector2: 后代元素</li><li>prev+next<ul><li>匹配所有紧接在 prev 元素后的 next 元素</li></ul></li><li>prev~siblings<ul><li>匹配 prev 元素之后的所有 siblings 元素</li></ul></li></ul></li><li>过滤选择器<ul><li>在原有选择器匹配的元素中进一步进行过滤的选择器</li><li>:first  获取第一个元素</li><li>:last 获取最后个元素</li><li>:eq(index) 匹配一个给定索引值的元素</li><li>:lt 匹配所有小于给定索引值的元素</li><li>:gt 匹配所有大于给定索引值的元素</li><li>:odd 匹配所有索引值为奇数的元素，从 0 开始计数</li><li>:even 匹配所有索引值为偶数的元素，从 0 开始计数</li><li>:not(selector) 去除所有与给定选择器匹配的元素</li><li>:hidden 匹配所有不可见元素，或者type为hidden的元素</li><li>:visible  匹配所有的可见元素</li><li>:contains(text) 匹配包含给定文本的元素</li><li>[属性] 匹配包含给定属性的元素</li><li>[属性=属性值] 匹配给定的属性是某个特定值的元素</li></ul></li><li>表单选择器<ul><li>:input 匹配所有 input, textarea, select 和 button 元素</li><li>:text 匹配所有的单行文本框</li><li>:checkbox 匹配所有复选框</li><li>:radio 匹配所有单选按钮</li><li>:checked:匹配所有选中的被选中元素(复选框、单选框等，不包括select中的option)</li></ul></li></ul><h2 id="工具方法"><a href="#工具方法" class="headerlink" title="$工具方法"></a>$工具方法</h2><ol><li>$.each(): 遍历数组或对象中的数据</li><li>$.trim(): 去除字符串两边的空格</li><li>$.type(obj): 得到数据的类型</li><li>$.isArray(obj): 判断是否是数组</li><li>$.isFunction(obj): 判断是否是函数</li><li>$.parseJSON(json) : 解析json字符串转换为js对象/数组</li></ol><h1 id="属性-文本"><a href="#属性-文本" class="headerlink" title="属性/文本"></a>属性/文本</h1><ul><li>操作标签的属性, 标签体文本</li><li>attr(name) / attr(name, value): 读写非布尔值的标签属性</li><li>prop(name) / prop(name, value): 读写布尔值的标签属性</li><li>removeAttr(name)/removeProp(name): 删除属性</li><li>addClass(classValue): 添加class</li><li>removeClass(classValue): 移除指定class</li><li>val() / val(value): 读写标签的value</li><li>html() / html(htmlString): 读写标签体文本</li></ul><h1 id="CSS模块"><a href="#CSS模块" class="headerlink" title="CSS模块"></a>CSS模块</h1><h2 id="style样式"><a href="#style样式" class="headerlink" title="style样式"></a>style样式</h2><ul><li>css(styleName): 根据样式名得到对应的值</li><li>css(styleName, value): 设置一个样式</li><li>css({多个样式对}): 设置多个样式<h2 id="位置坐标"><a href="#位置坐标" class="headerlink" title="位置坐标"></a>位置坐标</h2></li><li>offset(): 读/写当前元素坐标(原点是页面左上角)</li><li>position(): 读当前元素坐标(原点是父元素左上角)</li><li>scrollTop()/scrollLeft(): 读/写元素/页面的滚动条坐标<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//jquery实现backup</span></span><br><span class="line">&lt;script src=<span class="string">"jquery-1.10.1.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">  $(function () &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/回到顶部</span></span><br><span class="line"><span class="regexp">    $('#to_top').click(function () &#123;</span></span><br><span class="line"><span class="regexp">      var $body = $(document.body)</span></span><br><span class="line"><span class="regexp">      var $html = $(document.documentElement)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/使用scrollTop(): 瞬间滚动到顶部</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ $('html,body').scrollTop(0)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/使用scrollTop(): 平滑滚动到顶部</span></span><br><span class="line"><span class="regexp">      var offset = $body.scrollTop() + $html.scrollTop()/</span><span class="regexp">/总距离</span></span><br><span class="line"><span class="regexp">      if(offset===0) &#123;</span></span><br><span class="line"><span class="regexp">        return</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">      var totalTime = 300/</span><span class="regexp">/总时间</span></span><br><span class="line"><span class="regexp">      var intervalTime = 30/</span><span class="regexp">/间隔时间</span></span><br><span class="line"><span class="regexp">      var itemOffset = offset/</span>(totalTime/intervalTime)<span class="comment">//每一段间隔时间内滚多少距离</span></span><br><span class="line">      <span class="keyword">var</span> intervalId = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        offset -= itemOffset<span class="comment">//总距离减去一次间隔时间内的距离</span></span><br><span class="line">        <span class="keyword">if</span>(offset&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">          offset = <span class="number">0</span></span><br><span class="line">          clearInterval(intervalId)</span><br><span class="line">        &#125;</span><br><span class="line">        $(<span class="string">'html,body'</span>).scrollTop(offset)</span><br><span class="line">      &#125;, intervalTime)</span><br><span class="line"></span><br><span class="line">      <span class="comment">//使用动画: 平滑滚动到顶部</span></span><br><span class="line">     $(<span class="string">'body,html'</span>).animate(&#123;<span class="attr">scrollTop</span>:<span class="number">0</span>&#125;,<span class="number">300</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h2></li></ul><ol><li>内容尺寸</li></ol><ul><li>height(): height</li><li>width(): width</li></ul><ol start="2"><li>内部尺寸</li></ol><ul><li>innerHeight(): height+padding</li><li>innerWidth(): width+padding</li></ul><ol start="3"><li>外部尺寸</li></ol><ul><li>outerHeight(false/true): height+padding+border  如果是true, 加上margin</li><li>outerWidth(false/true): width+padding+border 如果是true, 加上margin</li></ul><h1 id="筛选模块"><a href="#筛选模块" class="headerlink" title="筛选模块"></a>筛选模块</h1><h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><ul><li>在jQuery对象内部的元素中找出部分匹配的元素, 并封装成新的jQuery对象返回</li><li>first()：获取第一个元素</li><li>last()：获取最后一个元素</li><li>eq(index)：获取第N个元素</li><li>filter(selector): 筛选出与指定表达式匹配的元素集合</li><li>not(selector): 指定表达式匹配的元素，并取反</li><li>has(selector): 保留包含特定后代的元素，去掉那些不含有指定后代的元素</li></ul><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><ul><li>查找jQuery对象内部的元素的子孙/兄弟/父母元素, 并封装成新的jQuery对象返回</li><li>children(selector): 子元素</li><li>parent(): 父元素</li><li>find(selector): 后代元素</li><li>preAll(selector): 查找当前元素之前所有的同辈元素</li><li>siblings(selector): 取得一个包含匹配的元素集合中每一个元素的所有唯一同辈元素的元素集合。可以用可选的表达式进行筛选</li></ul><h1 id="文档处理-CUD-模块"><a href="#文档处理-CUD-模块" class="headerlink" title="文档处理(CUD)模块"></a>文档处理(CUD)模块</h1><h2 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h2><ul><li>append() / appendTo(): 向当前匹配的所有元素内部的最后插入指定内容</li><li>preppend() / preppendTo(): 向当前匹配的所有元素内部的最前面插入指定内容</li><li>before(): 将指定内容插入到当前所有匹配元素的前面</li><li>after(): 在每个匹配的元素之后插入内容<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2></li><li>remove(): 将自己及内部的孩子都删除</li><li>empty(): 掏空(自己还在)<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2></li><li>replaceWith()：将所有匹配的元素替换成指定的HTML或DOM元素</li></ul><h1 id="事件模块"><a href="#事件模块" class="headerlink" title="事件模块"></a>事件模块</h1><h2 id="绑定事件"><a href="#绑定事件" class="headerlink" title="绑定事件"></a>绑定事件</h2><ul><li>eventName(function(){})<ul><li>绑定对应事件名的监听,    例如：$(‘#div’).click(function(){});</li></ul></li><li>on(‘eventName’, function(){})<ul><li>通用的绑定事件监听, 例如：$(‘#div’).on(‘click’, function(){})</li></ul></li><li>常用: click, mouseenter/mouseleave mouseover/mouseout focus/blur</li><li>hover(function(){}, function(){})</li></ul><h2 id="解绑事件"><a href="#解绑事件" class="headerlink" title="解绑事件"></a>解绑事件</h2><ul><li>off(‘eventName’)<h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2></li><li>理解<ul><li>将多个子元素的事件监听委托给父辈元素处理</li><li>监听回调是加在了父辈元素上</li><li>当操作任何一个子元素时, 事件会冒泡到父辈元素</li><li>父辈元素不会直接处理事件, 而是根据event.target得到发生事件的子元素, 通过这个子元素调用事件回调函数</li></ul></li><li>好处<ul><li>添加新的子元素, 自动有事件响应处理</li><li>减少事件监听的数量: n==&gt;1</li></ul></li><li>jQuery的事件委托API<ul><li>设置事件委托: $(parentSelector).delegate(childrenSelector, eventName, callback)// 回调函数中的this是子元素</li><li>移除事件委托: $(parentSelector).undelegate(eventName)</li></ul></li></ul><h2 id="事件坐标"><a href="#事件坐标" class="headerlink" title="事件坐标"></a>事件坐标</h2><ul><li>event.offsetX: 原点是当前元素左上角</li><li>event.clientX: 原点是窗口左上角</li><li>event.pageX: 原点是页面左上角</li></ul><h2 id="事件相关"><a href="#事件相关" class="headerlink" title="事件相关"></a>事件相关</h2><ul><li>停止事件冒泡: event.stopPropagation()</li><li>阻止事件的默认行为: event.preventDefault()</li></ul><h2 id="区别mouseover与mouseenter"><a href="#区别mouseover与mouseenter" class="headerlink" title="区别mouseover与mouseenter?"></a>区别mouseover与mouseenter?</h2><ul><li>mouseover: 在移入子元素时也会触发, 对应mouseout</li><li>mouseenter: 只在移入当前元素时才触发, 对应mouseleave</li><li>hover()使用的就是mouseenter()和mouseleave()</li></ul><h1 id="动画效果"><a href="#动画效果" class="headerlink" title="动画效果"></a>动画效果</h1><ul><li>在一定的时间内, 不断改变元素样式<h2 id="淡入淡出-不断改变元素的透明度来实现的"><a href="#淡入淡出-不断改变元素的透明度来实现的" class="headerlink" title="淡入淡出: 不断改变元素的透明度来实现的"></a>淡入淡出: 不断改变元素的透明度来实现的</h2><ol><li>fadeIn(): 带动画的显示</li><li>fadeOut(): 带动画隐藏</li><li>fadeToggle(): 带动画切换显示/隐藏</li></ol></li></ul><h2 id="滑动动画"><a href="#滑动动画" class="headerlink" title="滑动动画"></a>滑动动画</h2><ol><li>slideDown(): 带动画的展开</li><li>slideUp(): 带动画的收缩</li><li>slideToggle(): 带动画的切换展开/收缩</li></ol><h2 id="显示隐藏，默认没有动画"><a href="#显示隐藏，默认没有动画" class="headerlink" title="显示隐藏，默认没有动画"></a>显示隐藏，默认没有动画</h2><ol><li>show(): (不)带动画的显示</li><li>hide(): (不)带动画的隐藏</li><li>toggle(): (不)带动画的切换显示/隐藏</li></ol><h2 id="jQuery动画本质-在指定时间内不断改变元素样式值来实现的"><a href="#jQuery动画本质-在指定时间内不断改变元素样式值来实现的" class="headerlink" title="jQuery动画本质 : 在指定时间内不断改变元素样式值来实现的"></a>jQuery动画本质 : 在指定时间内不断改变元素样式值来实现的</h2><ol><li>animate(): 自定义动画效果的动画</li><li>stop(): 停止动画</li></ol><h1 id="插件机制"><a href="#插件机制" class="headerlink" title="插件机制"></a>插件机制</h1><h2 id="扩展jQuery函数对象的方法"><a href="#扩展jQuery函数对象的方法" class="headerlink" title="扩展jQuery函数对象的方法"></a>扩展jQuery函数对象的方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$.extend(&#123;</span><br><span class="line">  xxx: fuction () &#123;&#125; <span class="comment">// this是$</span></span><br><span class="line">&#125;)</span><br><span class="line">$.xxx()</span><br></pre></td></tr></table></figure><h2 id="扩展jQuery对象的方法"><a href="#扩展jQuery对象的方法" class="headerlink" title="扩展jQuery对象的方法"></a>扩展jQuery对象的方法</h2>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$.fn.extend(&#123;</span><br><span class="line">  xxx: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;  <span class="comment">// this是jQuery对象</span></span><br><span class="line">&#125;)</span><br><span class="line">$obj.xxx()</span><br></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="window-onload与-document-ready-的区别"><a href="#window-onload与-document-ready-的区别" class="headerlink" title="window.onload与 $(document).ready()的区别"></a>window.onload与 $(document).ready()的区别</h2><ul><li>window.onload<ul><li>包括页面的图片加载完后才会回调(晚)</li><li>只能有一个监听回调</li></ul></li><li>$(document).ready()<ul><li>等同于: $(function(){})</li><li>页面加载完就回调(早)</li><li>可以有多个监听回调</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;了解jQuery&quot;&gt;&lt;a href=&quot;#了解jQuery&quot; class=&quot;headerlink&quot; title=&quot;了解jQuery&quot;&gt;&lt;/a&gt;了解jQuery&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="jQuery" scheme="http://xyx6.top/categories/jQuery/"/>
    
    
      <category term="jQuery" scheme="http://xyx6.top/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>JS高级</title>
    <link href="http://xyx6.top/2020/07/08/JS%E9%AB%98%E7%BA%A7/"/>
    <id>http://xyx6.top/2020/07/08/JS%E9%AB%98%E7%BA%A7/</id>
    <published>2020-07-07T17:20:50.000Z</published>
    <updated>2020-07-10T07:03:20.378Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>序<br><br>js进阶-&gt;上流JS</p></blockquote><a id="more"></a><h1 id="JS基础总结深入"><a href="#JS基础总结深入" class="headerlink" title="JS基础总结深入"></a>JS基础总结深入</h1><h2 id="数据类型的分类和判断"><a href="#数据类型的分类和判断" class="headerlink" title="数据类型的分类和判断"></a>数据类型的分类和判断</h2><table><thead><tr><th>数据类型</th><th>定义</th><th>类型判断</th></tr></thead><tbody><tr><td>基本(值)类型</td><td></td><td></td></tr><tr><td>Number</td><td>任意数值</td><td>typeof</td></tr><tr><td>String</td><td>任意字符串</td><td>typeof</td></tr><tr><td>Boolean</td><td>true/false</td><td>typeof</td></tr><tr><td>undefined</td><td>undefined</td><td>typeof/===</td></tr><tr><td>null</td><td>null</td><td>===</td></tr><tr><td>对象(引用)类型</td><td></td><td></td></tr><tr><td>Object</td><td>任意对象</td><td>typeof/instanceof</td></tr><tr><td>Array</td><td>一种特别的对象(索引，内部是有序的)</td><td>instanceof</td></tr><tr><td>Function</td><td>一种特别的对象(可以执行)</td><td>typeof</td></tr></tbody></table><ul><li>判断<ul><li>typeof:<ul><li>可以区别: 数值, 字符串, 布尔值, undefined, function</li><li>不能区别: null与对象, 一般对象与数组</li></ul></li><li>instanceof<ul><li>专门用来判断对象数据的类型: Object, Array与Function</li></ul></li><li>===<ul><li>可以判断: undefined和null</li></ul></li></ul></li></ul><ul><li><strong>相关问题</strong></li></ul><ol><li>undefined与null的区别?</li></ol><ul><li>undefined代表没有赋值</li><li>null代表赋值了, 只是值为null</li></ul><ol start="2"><li>什么时候给变量赋值为null呢?</li></ol><ul><li>var a = null //初始赋值为null，表明将要赋值为对象，a将指向一个对象, 但对象此时还没有确定</li><li>a = null //让a指向的对象成为垃圾对象(被垃圾回收器回收)</li></ul><ol start="3"><li>严格区别变量类型与数据类型?</li></ol><ul><li>js的变量本身是没有类型的, 变量的类型实际上是变量内存中数据的类型</li><li>变量类型:<ul><li>基本类型: 保存基本类型数据</li><li>引用类型: 保存对象地址值</li></ul></li><li>数据对象<ul><li>基本类型</li><li>对象类型</li></ul></li></ul><h2 id="数据-变量-内存的理解"><a href="#数据-变量-内存的理解" class="headerlink" title="数据,变量, 内存的理解"></a>数据,变量, 内存的理解</h2><ol><li>什么是数据?<ul><li>存储于内存中代表特定信息的’东东’, 本质就是0101二进制</li><li>具有可读和可传递的基本特性</li><li>万物(一切)皆数据, 函数也是数据</li><li>程序中所有操作的目标: 数据<ul><li>算术运算</li><li>逻辑运算</li><li>赋值</li><li>调用函数传参<br>…</li></ul></li></ul></li><li>什么是内存?<ul><li>内存条通电后产生的存储空间(临时的)</li><li>产生和死亡: 内存条(集成电路板)==&gt;通电==&gt;产生一定容量的存储空间==&gt;存储各种数据==&gt;断电==&gt;内存全部消失</li><li>内存的空间是临时的, 而硬盘的空间是持久的</li><li>一块内存包含2个数据<ul><li>内部存储的数据(一般数据/地址数据)</li><li>内存地址值数据</li></ul></li><li>内存分类<ul><li>栈: 全局变量, 局部变量 (空间较小)</li><li>堆: 对象 (空间较大)</li></ul></li></ul></li><li>什么是变量?<ul><li>值可以变化的量, 由变量名与变量值组成</li><li>一个变量对应一块小内存, 变量名用来查找到内存, 变量值就是内存中保存的内容</li></ul></li><li>内存,数据, 变量三者之间的关系<ul><li>内存是一个容器, 用来存储程序运行需要操作的数据</li><li>变量是内存的标识, 我们通过变量找到对应的内存, 进而操作(读/写)内存中的数据</li></ul></li></ol><ul><li><strong>相关问题</strong></li></ul><ol><li><p>var a = xxx, a内存中到底保存的是什么?</p><ul><li>xxx是一个基本数据，保存的就是数据</li><li>xxx是一个对象，保存的是对象的地址值</li><li>xxx是一个变量，保存的内存内容可能是地址值，也可能是数据值</li></ul></li><li><p>关于引用变量赋值问题</p><ul><li>2个引用变量指向同一个对象, 通过一个引用变量修改对象内部数据, 另一个引用变量看到的是修改之后的数据</li><li>2个引用变量指向同一个对象,让一个引用变量指向另一个对象, 另一个引用变量还是指向前面的对象</li></ul></li><li><p>在js调用函数时传递变量参数时, 是值传递还是引用传递?</p><ul><li>只有值传递, 没有引用传递, 传递的都是变量的值, 只是这个值可能是基本数据, 也可能是地址(引用)数据</li><li>如果后一种看成是引用传递, 那就值传递和引用传递都可以有</li></ul></li><li><p>JS引擎如何管理内存?</p><ol><li>内存生命周期<ol><li>分配小内存空间，得到他的使用权</li><li>存储数据。进行反复操作</li><li>不需要时将其释放/归还</li></ol></li><li>释放内存<ul><li>为执行函数分配的栈空间内存: 函数执行完自动释放</li><li>存储对象的堆空间内存: 当内存没有引用指向时, 对象成为垃圾对象, 垃圾回收器后面就会回收释放此内存</li></ul></li></ol></li></ol><h2 id="对象的理解和使用"><a href="#对象的理解和使用" class="headerlink" title="对象的理解和使用"></a>对象的理解和使用</h2><ol><li>什么是对象?<ul><li>代表现实中的某个事物, 是该事物在编程中的抽象</li><li>多个数据的集合体(封装体)</li><li>用于保存多个数据的容器</li></ul></li><li>为什么要用对象?<ul><li>便于对多个数据进行统一管理</li></ul></li><li>对象的组成<ul><li>属性<ul><li>代表现实事物的状态数据</li><li>由属性名和属性值组成</li><li>属性名都是字符串类型, 属性值是任意类型</li></ul></li><li>方法<ul><li>代表现实事物的行为数据</li><li>是特别的属性==&gt;属性值是函数</li></ul></li></ul></li><li>如何访问对象内部数据?<ul><li>.属性名: 编码简单, 但有时不能用</li><li>[‘属性名’]: 编码麻烦, 但通用</li></ul></li></ol><ul><li><strong>相关问题</strong></li></ul><ol><li>什么时候必须使用[‘属性名’]的方式?<ul><li>属性名不是合法的标识名</li><li>属性名不确定</li></ul></li></ol><h2 id="函数的理解和使用"><a href="#函数的理解和使用" class="headerlink" title="函数的理解和使用"></a>函数的理解和使用</h2><ul><li>什么是函数?<ul><li>用来实现特定功能的, n条语句的封装体</li><li>只有函数类型的数据是可以执行的, 其它的都不可以</li></ul></li><li>为什么要用函数?<ul><li>提高复用性</li><li>便于阅读交流</li></ul></li><li>函数也是对象<ul><li>instanceof Object===true</li><li>函数有属性: prototype</li><li>函数有方法: call()/apply()</li><li>可以添加新的属性/方法</li></ul></li><li>函数的3种不同角色<ul><li>一般函数 : 直接调用</li><li>构造函数 : 通过new调用</li><li>对象 : 通过.调用内部的属性/方法</li></ul></li><li>匿名函数自调用:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function(w, obj)&#123;</span><br><span class="line">  &#x2F;&#x2F;实现代码</span><br><span class="line">&#125;)(window, obj)</span><br></pre></td></tr></table></figure><ul><li>专业术语为: IIFE (Immediately Invoked Function Expression) 立即调用函数表达式</li><li>作用<ul><li>隐藏内部实现</li><li>不污染外部命名空间</li><li>用它来编写js模块                          </li></ul></li></ul></li><li>回调函数的理解<ul><li>什么函数才是回调函数?<ul><li>你定义的</li><li>你没有调用</li><li>但它最终执行了(在一定条件下或某个时刻)</li></ul></li><li>常用的回调函数<ul><li>dom事件回调函数</li><li>定时器回调函数</li><li>ajax请求回调函数</li><li>生命周期回调函数</li></ul></li></ul></li><li>函数中的this<ul><li>显式指定谁:obj.xxx()</li><li>通过call/apply指定谁调用: xxx.call(obj)</li><li>不指定谁调用: xxx(): window</li><li>回调函数: 看背后是通过谁来调用的: window/其它</li></ul></li></ul><h1 id="函数高级"><a href="#函数高级" class="headerlink" title="函数高级"></a>函数高级</h1><h2 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h2><blockquote><ol><li>函数的prototype属性<ul><li>每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象)</li><li>原型对象中有一个属性constructor, 它指向函数对象</li></ul></li><li>给原型对象添加属性(一般都是方法)<ul><li>作用: 函数的所有实例对象自动拥有原型中的属性(方法)</li></ul></li></ol></blockquote><ul><li><p>所有函数都有一个特别的属性:</p><ul><li><code>prototype</code> : 显式原型属性</li></ul></li><li><p>所有实例对象都有一个特别的属性:</p><ul><li><code>__proto__</code> : 隐式原型属性</li></ul></li><li><p>显式原型与隐式原型的关系</p><ul><li>函数的prototype: 定义函数时被自动赋值, 值默认为{}, 即用为原型对象</li><li>实例对象的<strong>proto</strong>: 在创建实例对象时被自动添加, 并赋值为构造函数的prototype值</li><li>原型对象即为当前实例对象的父对象</li><li>例子:<br><img src="/2020/07/08/JS%E9%AB%98%E7%BA%A7/%E6%98%BE%E5%BC%8F%E5%8E%9F%E5%9E%8B%E4%B8%8E%E9%9A%90%E5%BC%8F%E5%8E%9F%E5%9E%8B.png" alt></li></ul></li><li><p>原型链</p><ul><li>访问一个对象的属性时，<ul><li>先在自身属性中查找，找到返回</li><li>如果没有, 再沿着<strong>proto</strong>这条链向上查找, 找到返回</li><li>如果最终没找到, 返回undefined(下图中函数列表的尽头<strong>proto</strong>=null就表示没找到返回undefined)</li></ul></li><li>别名: 隐式原型链</li><li>作用: 查找对象的属性(方法)</li><li>所有的实例对象都有<strong>proto</strong>属性, 它指向的就是原型对象</li><li>这样通过<strong>proto</strong>属性就形成了一个链的结构—-&gt;原型链</li><li>当查找对象内部的属性/方法时, js引擎自动沿着这个原型链查找</li><li><strong>当给对象属性赋值时不会使用原型链, 而只是在当前对象中进行操作</strong></li><li>函数的prototype属性指向实例的<strong>proto</strong>属性</li><li>所有的函数都是 Function的实例(包括Function)<br><img src="/2020/07/08/JS%E9%AB%98%E7%BA%A7/%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%88%86%E6%9E%90.png" alt></li></ul></li><li><p>instanceof是如何判断的?</p><ul><li>表达式: A instanceof B</li><li>如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false</li></ul></li><li><p>测试题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">原型测试题：</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  测试题1</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">var</span> A = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  A.prototype.n = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> b = <span class="keyword">new</span> A()</span><br><span class="line"></span><br><span class="line">  A.prototype = &#123;</span><br><span class="line">    n: <span class="number">2</span>,</span><br><span class="line">    m: <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> c = <span class="keyword">new</span> A()</span><br><span class="line">  <span class="built_in">console</span>.log(b.n, b.m, c.n, c.m)</span><br><span class="line"><span class="comment">//1 undefined 2 3 </span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   测试题2</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">  <span class="built_in">Object</span>.prototype.a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a()'</span>)</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">Function</span>.prototype.b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'b()'</span>)</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="keyword">new</span> F();</span><br><span class="line">  f.a()</span><br><span class="line">  f.b()</span><br><span class="line">  F.a()</span><br><span class="line">  F.b()</span><br><span class="line">  <span class="comment">//a() </span></span><br><span class="line">  <span class="comment">// f.b is not a function</span></span><br><span class="line">  <span class="comment">//a()</span></span><br><span class="line">  <span class="comment">//b()</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/2020/07/08/JS%E9%AB%98%E7%BA%A7/%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt></p></li></ul><h2 id="执行上下文与执行上下文栈"><a href="#执行上下文与执行上下文栈" class="headerlink" title="执行上下文与执行上下文栈"></a>执行上下文与执行上下文栈</h2><ul><li>变量提升与函数提升<ul><li>变量提升: 在变量定义语句之前, 就可以访问到这个变量(undefined)，只是还没有赋值</li><li>函数提升: 在函数定义语句之前, 就可执行该函数</li><li>先有变量提升, 再有函数提升</li></ul></li></ul><ol><li>执行上下文</li></ol><ul><li>代码分类(位置)<ul><li>全局代码</li><li>函数代码</li></ul></li><li>全局执行上下文<ul><li>在执行全局代码前将window确定为全局执行上下文</li><li>对全局数据进行预处理<ul><li>var定义的全局变量==&gt;undefined, 添加为window的属性</li><li>function声明的全局函数==&gt;赋值(fun), 添加为window的方法</li><li>this==&gt;赋值(window)</li></ul></li><li>开始执行全局代码</li></ul></li><li>函数执行上下文<ul><li>在调用函数, 准备执行函数体之前, 创建对应的函数执行上下文对象</li><li>对局部数据进行预处理<ul><li>形参变量==&gt;赋值(实参)==&gt;添加为执行上下文的属性</li><li>arguments==&gt;赋值(实参列表), 添加为执行上下文的属性</li><li>var定义的局部变量==&gt;undefined, 添加为执行上下文的属性</li><li>function声明的函数 ==&gt;赋值(fun), 添加为执行上下文的方法</li><li>this==&gt;赋值(调用函数的对象)</li></ul></li><li>开始执行函数体代码</li></ul></li></ul><ol start="2"><li>执行上下文栈</li></ol><ul><li><p>在全局代码执行前, JS引擎就会创建一个栈来存储管理所有的执行上下文对象</p></li><li><p>在全局执行上下文(window)确定后, 将其添加到栈中(压栈)</p></li><li><p>在函数执行上下文创建后, 将其添加到栈中(压栈)</p></li><li><p>在当前函数执行完后,将栈顶的对象移除(出栈)</p></li><li><p>当所有的代码执行完后, 栈中只剩下window</p></li><li><p>例子：<br><img src="/2020/07/08/JS%E9%AB%98%E7%BA%A7/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88.png" alt></p></li><li><p>测试题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">执行上下文栈测试题：</span><br><span class="line"></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'global begin: '</span>+ i)</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line">  foo(<span class="number">1</span>);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'foo() begin:'</span> + i);</span><br><span class="line">    foo(i + <span class="number">1</span>);<span class="comment">//递归调用：在函数内部调用自己，一般会设置条件来终止函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'foo() end:'</span> + i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'global end: '</span> + i)</span><br><span class="line">  <span class="comment">// global begin: undefined</span></span><br><span class="line"><span class="comment">// foo() begin:1 由于递归输出1.2.3</span></span><br><span class="line"><span class="comment">// foo() begin:2</span></span><br><span class="line"><span class="comment">// foo() begin:3</span></span><br><span class="line"><span class="comment">// foo() end:3   因为foo begin执行完后要将栈顶的对象移除出栈</span></span><br><span class="line"><span class="comment">// foo() end:2</span></span><br><span class="line"><span class="comment">// foo() end:1</span></span><br><span class="line"><span class="comment">// global end: 1</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  测试题1: 先预处理变量, 后预处理函数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> a)<span class="comment">//function</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  测试题2: 变量预处理, in操作符</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (!(b <span class="keyword">in</span> <span class="built_in">window</span>)) &#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(b)<span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  测试题3: 预处理, 顺序执行</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">var</span> c = <span class="number">1</span><span class="comment">//var c;</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(c)</span><br><span class="line">    <span class="keyword">var</span> c = <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//c=1</span></span><br><span class="line">  c(<span class="number">2</span>)<span class="comment">//报错 会把c识别成变量而不是函数</span></span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="作用域与作用域链"><a href="#作用域与作用域链" class="headerlink" title="作用域与作用域链"></a>作用域与作用域链</h2></li><li><p>理解:</p><ul><li>作用域: 一块代码区域, 在编码时就确定了, 不会再变化</li><li>作用域链:<ul><li>多个上下级关系的作用域形成的链, 它的方向是从下向上的(从内到外)</li><li>查找变量时就是沿着作用域链来查找的</li></ul></li></ul></li><li><p>分类:</p><ul><li>全局</li><li>函数</li><li>js没有块作用域(在ES6之前)</li></ul></li><li><p>作用</p><ul><li>作用域: 隔离变量, 可以在不同作用域定义同名的变量不冲突</li><li>作用域链: 查找变量</li></ul></li><li><p>区别作用域与执行上下文</p><ol><li>区别1<ul><li>全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了，而不是在函数调用时</li><li>全局执行上下文环境是在全局作用域确定之后, js代码马上执行之前创建</li><li>函数执行上下文环境是在调用函数时, 函数体代码执行之前创建</li></ul></li><li>区别2<ul><li>作用域是静态的, 只要函数定义好了就一直存在, 且不会再变化</li><li>上下文环境是动态的, 调用函数时创建, 函数调用结束时上下文环境就会被释放</li></ul></li><li>联系<ul><li>上下文环境(对象)是从属于所在的作用域</li><li>全局上下文环境==&gt;全局作用域</li><li>函数上下文环境==&gt;对应的函数使用域</li></ul></li></ol></li><li><p>测试题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   问题: 结果输出多少?</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">20</span>;</span><br><span class="line">    f();</span><br><span class="line">  &#125;</span><br><span class="line">  show(fn);</span><br><span class="line">  <span class="comment">//10</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   说说它们的输出情况</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(fn)</span><br><span class="line">  &#125;</span><br><span class="line">  fn()<span class="comment">//函数作用域找不到，去外部作用域能找到fn</span></span><br><span class="line">  <span class="comment">//ƒ () &#123;</span></span><br><span class="line">  <span class="comment">//  console.log(fn)</span></span><br><span class="line">  <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> obj = &#123;</span><br><span class="line">    fn2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(fn2)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  obj.fn2()<span class="comment">//函数作用域找不到，全局作用域也找不到（只有obj，没有fn2）；修改为this.fn2或obj.fn2为正确</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2></li><li><p>理解</p><ul><li>当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时, 就产生了闭包</li><li>通过chrome工具得知: 闭包本质是内部函数中的一个对象, 这个对象中包含引用的变量属性</li><li>闭包的数量取决于调用外部函数的次数，只有调用外部函数的时候才会创建内部函数对象</li></ul></li><li><p>作用</p><ol><li>使用函数内部的变量在函数执行完后, 仍然存活在内存中(延长了局部变量的生命周期)</li><li>让函数外部可以操作(读写)到函数内部的数据(变量/函数)</li></ol></li><li><p>生命周期</p><ol><li>产生: 在嵌套内部函数定义执行完时就产生了(不是在调用)</li><li>死亡: 在嵌套的内部函数成为垃圾对象时<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//此处闭包已经产生(函数提升，内部函数对象已经创建了)</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      a++;</span><br><span class="line">      <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fun2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> f = fun1();</span><br><span class="line">  f();</span><br><span class="line">  f();</span><br><span class="line">  f = <span class="literal">null</span> <span class="comment">//此时闭包对象死亡</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>应用</p></li></ul><ol><li>定义JS模块<ul><li>具有特定功能的js文件</li><li>将所有的数据和功能都封装在一个函数内部(私有的)</li><li>只向外暴露一个包含n个方法的对象或函数</li><li>模块的使用者, 只需要通过模块暴露的对象调用方法来实现对应的功能</li></ul></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//Module.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义模块1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">coolModule</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//私有的数据</span></span><br><span class="line">  <span class="keyword">var</span> msg = <span class="string">'atguigu'</span></span><br><span class="line">  <span class="keyword">var</span> names = [<span class="string">'I'</span>, <span class="string">'Love'</span>, <span class="string">'you'</span>]</span><br><span class="line"></span><br><span class="line">  <span class="comment">//私有的操作数据的函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(msg.toUpperCase())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doOtherthing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(names.join(<span class="string">' '</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//向外暴露包含多个方法的对象，也可以用return(还需在调用时创建对象)</span></span><br><span class="line">  <span class="built_in">window</span>.module &#123;</span><br><span class="line">    doSomething: doSomething,</span><br><span class="line">    doOtherthing: doOtherthing</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用闭包</span></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"Module.js"</span>&gt;&lt;<span class="regexp">/script&gt;/</span><span class="regexp">/引入</span></span><br><span class="line"><span class="regexp">&lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">  module.doSomething()</span></span><br><span class="line"><span class="string">  module.doOtherthing()</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><ul><li>缺点及解决方案</li></ul><ol><li>缺点<ul><li>函数执行完后, 函数内的局部变量没有释放, 占用内存时间会变长</li><li>容易造成内存泄露</li></ul></li><li>解决<ul><li>能不用闭包就不用</li><li>及时释放: f = null; //让内部函数对象成为垃圾对象</li></ul></li></ol><h2 id="内存溢出与内存泄露"><a href="#内存溢出与内存泄露" class="headerlink" title="内存溢出与内存泄露"></a>内存溢出与内存泄露</h2><ol><li>内存溢出<ul><li>一种程序运行出现的错误</li><li>当程序运行需要的内存超过了剩余的内存时, 就出抛出内存溢出的错误</li></ul></li><li>内存泄露<ul><li>占用的内存没有及时释放</li><li>内存泄露积累多了就容易导致内存溢出</li><li>常见的内存泄露:<ul><li>意外的全局变量</li><li>没有及时清理的计时器或回调函数</li><li>闭包</li></ul></li></ul></li></ol><h1 id="面向对象高级"><a href="#面向对象高级" class="headerlink" title="面向对象高级"></a>面向对象高级</h1><h2 id="对象的创建模式"><a href="#对象的创建模式" class="headerlink" title="对象的创建模式"></a>对象的创建模式</h2><ul><li><p>Object构造函数模式</p><ul><li>套路: 先创建空Object对象, 再动态添加属性/方法</li><li>适用场景: 起始时不确定对象内部数据</li><li>问题: 语句太多<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.name = <span class="string">'Tom'</span></span><br><span class="line">obj.setName = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;<span class="keyword">this</span>.name=name&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>对象字面量模式</p><ul><li>套路: 使用{}创建对象, 同时指定属性/方法</li><li>适用场景: 起始时对象内部数据是确定的</li><li>问题: 如果创建多个对象, 有重复代码<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name : <span class="string">'Tom'</span>,</span><br><span class="line">  setName : <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;<span class="keyword">this</span>.name = name&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>工厂模式</p><ul><li>套路: 通过工厂函数动态创建对象并返回</li><li>适用场景: 需要创建多个对象</li><li>问题: 对象没有一个具体的类型, 都是Object类型<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 工厂函数: 返回一个需要的数据的函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p = &#123;</span><br><span class="line">      name: name,</span><br><span class="line">      age: age,</span><br><span class="line">      setName: <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> p1=createPerson(name, age);</span><br><span class="line">  <span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string">* 构造函数模式</span></span><br><span class="line"><span class="string">    * 套路: 自定义构造函数, 通过new创建对象</span></span><br><span class="line"><span class="string">    * 适用场景: 需要创建多个类型确定的对象</span></span><br><span class="line"><span class="string">    * 问题: 每个对象都有相同的数据, 浪费内存</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  `</span><span class="string">``</span>javascript</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.setName = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;<span class="keyword">this</span>.name=name;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">new</span> Person(<span class="string">'tom'</span>, <span class="number">12</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>构造函数+原型的组合模式</p><ul><li>套路: 自定义构造函数, 属性在函数中初始化, 方法添加到原型上</li><li>适用场景: 需要创建多个类型确定的对象<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setName = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;<span class="keyword">this</span>.name=name;&#125;;</span><br><span class="line"><span class="keyword">new</span> Person(<span class="string">'tom'</span>, <span class="number">12</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="继承模式"><a href="#继承模式" class="headerlink" title="继承模式"></a>继承模式</h2><ul><li><p><strong>原型链继承</strong> : 得到方法</p><ul><li>套路<ol><li>定义父类型构造函数</li><li>给父类型的原型添加方法</li><li>定义子类型的构造函数</li><li>创建父类型的对象赋值给子类型的原型</li><li>将子类型原型的构造属性设置为子类型</li><li>给子类型原型添加方法</li><li>创建子类型的对象: 可以调用父类型的方法</li></ol></li><li>关键<ol><li>子类型的原型为父类型的一个实例对象<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Parent.prototype.test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent(); <span class="comment">// 子类型的原型指向父类型实例(让子类的原型成为父类的实例对象)</span></span><br><span class="line">Child.prototype.constructor = Child<span class="comment">//让子类型的原型的constructor指向子类型</span></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child(); <span class="comment">//有test()</span></span><br></pre></td></tr></table></figure><ul><li>例子<br><img src="/2020/07/08/JS%E9%AB%98%E7%BA%A7/%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF.png" alt></li></ul></li></ol></li></ul></li><li><p>借用构造函数 : 得到属性</p><ul><li>套路:<ol><li>定义父类型构造函数</li><li>定义子类型构造函数</li><li>在子类型构造函数中调用父类型构造</li></ol></li><li>关键:<ol><li>在子类型构造函数中通用super()调用父类型构造函数<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">xxx</span>)</span>&#123;<span class="keyword">this</span>.xxx = xxx&#125;</span><br><span class="line">Parent.prototype.test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">xxx,yyy</span>)</span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>, xxx);<span class="comment">//借用构造函数  this.Parent(xxx)不能这样写，但是意思相同</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child(<span class="string">'a'</span>, <span class="string">'b'</span>);  <span class="comment">//child.xxx为'a', 但child没有test()</span></span><br></pre></td></tr></table></figure></li></ol></li></ul></li><li><p>原型链+借用构造函数的组合继承</p><ol><li>利用原型链实现对父类型对象的方法继承</li><li>利用call()借用父类型构建函数初始化相同属性<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">xxx</span>)</span>&#123;<span class="keyword">this</span>.xxx = xxx&#125;</span><br><span class="line">Parent.prototype.test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">xxx,yyy</span>)</span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>, xxx);<span class="comment">//借用构造函数 this.Parent(xxx)</span></span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent(); <span class="comment">//得到test()</span></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child(); <span class="comment">//child.xxx为'a', 也有test()</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>new一个对象背后做了些什么?</p><ul><li>创建一个空对象</li><li>给对象设置<strong>proto</strong>, 值为构造函数对象的prototype属性值   this.<strong>proto</strong> = Fn.prototype</li><li>执行构造函数体(给对象添加属性/方法)</li></ul></li></ul><h1 id="线程机制与事件机制"><a href="#线程机制与事件机制" class="headerlink" title="线程机制与事件机制"></a>线程机制与事件机制</h1><h2 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h2><ul><li>进程:<ul><li>程序的一次执行, 它占有一片独有的内存空间</li><li>可以通过windows任务管理器查看进程</li></ul></li><li>线程:<ul><li>是进程内的一个独立执行单元</li><li>是程序执行的一个完整流程</li><li>是CPU的最小的调度单元</li></ul></li><li>关系<ul><li>程序是在某个进程中的某个线程执行的</li><li>一个进程中一般至少有一个运行的线程: 主线程</li><li>一个进程中也可以同时运行多个线程, 我们会说程序是多线程运行的</li><li>一个进程内的数据可以供其中的多个线程直接共享</li><li>多个进程之间的数据是不能直接共享的</li><li>线程池：保存多个线程对象的容器，实现线程对象的反复利用</li></ul></li></ul><h2 id="浏览器内核模块组成"><a href="#浏览器内核模块组成" class="headerlink" title="浏览器内核模块组成"></a>浏览器内核模块组成</h2><ol><li><p>什么是浏览器内核?</p><ul><li>支持浏览器运行的最核心的程序</li></ul></li><li><p>不同的浏览器可能不太一样</p><ul><li>Chrome, Safari: webkit</li><li>firefox: Gecko</li><li>IE: Trident</li><li>360,搜狗等国内浏览器: Trident + webkit</li></ul></li><li><p>内核由很多模块组成 </p><ul><li>主线程<ul><li>js引擎模块 : 负责js程序的编译与运行</li><li>html,css文档解析模块 : 负责页面文本的解析</li><li>DOM/CSS模块 : 负责dom/css在内存中的相关处理 </li><li>布局和渲染模块 : 负责页面的布局和效果的绘制(内存中的对象)</li></ul></li><li>分线程<ul><li>定时器模块 : 负责定时器的管理</li><li>DOM事件模块 : 负责事件的管理</li><li>网络请求模块 : 负责Ajax请求</li></ul></li></ul></li></ol><h2 id="定时器问题"><a href="#定时器问题" class="headerlink" title="定时器问题:"></a>定时器问题:</h2><ol><li>定时器真是定时执行的吗?<ul><li>定时器并不能保证真正定时执行</li><li>一般会延迟一丁点(可以接受), 也有可能延迟很长时间(不能接受)</li></ul></li><li>定时器回调函数是在分线程执行的吗?<ul><li>在主线程执行的, js是单线程的</li></ul></li><li>定时器是如何实现的?<ul><li>事件循环模型</li></ul></li></ol><h2 id="js线程"><a href="#js线程" class="headerlink" title="js线程"></a>js线程</h2><ul><li>js是单线程执行的(回调函数也是在主线程)</li><li>H5提出了实现多线程的方案: Web Workers</li><li>只能是主线程更新界面</li></ul><ol><li><p>如何证明js执行是单线程的?</p><ul><li>setTimeout()的回调函数是在主线程执行的</li><li>定时器回调函数只有在运行栈中的代码全部执行完后才有可能执行</li></ul></li><li><p>为什么js要用单线程模式, 而不用多线程模式?</p><ul><li>JavaScript的单线程，与它的用途有关。</li><li>作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。</li><li>这决定了它只能是单线程，否则会带来很复杂的同步问题</li></ul></li><li><p>代码的分类:</p><ul><li>初始化代码</li><li>回调代码</li></ul></li><li><p>js引擎执行代码的基本流程</p><ul><li>先执行初始化代码: 包含一些特别的代码<ul><li>设置定时器</li><li>绑定监听</li><li>发送ajax请求</li></ul></li><li>后面在某个时刻才会执行回调代码</li></ul></li></ol><h2 id="事件循环模型"><a href="#事件循环模型" class="headerlink" title="事件循环模型"></a>事件循环模型</h2><ol><li>所有代码分类<ul><li>初始化执行代码(同步代码): 包含绑定dom事件监听, 设置定时器, 发送ajax请求的代码</li><li>回调执行代码(异步代码): 处理回调逻辑</li></ul></li><li>js引擎执行代码的基本流程:<ul><li>初始化代码===&gt;回调代码</li></ul></li><li>模型的2个重要组成部分:<ul><li>事件管理模块</li><li>回调队列</li></ul></li><li>模型的运转流程<ul><li>执行初始化代码, 将事件回调函数交给对应模块管理</li><li>当事件发生时, 管理模块会将回调函数及其数据添加到回调列队中</li><li>只有当初始化代码执行完后(可能要一定时间), 才会遍历读取回调队列中的回调函数执行<br><img src="/2020/07/08/JS%E9%AB%98%E7%BA%A7/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%A8%A1%E5%9E%8B.png" alt></li></ul></li></ol><h2 id="H5-Web-Workers-多线程"><a href="#H5-Web-Workers-多线程" class="headerlink" title="H5 Web Workers(多线程)"></a>H5 Web Workers(多线程)</h2><ol><li>H5规范提供了js分线程的实现, 取名为: Web Workers</li></ol><ul><li>Worker<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(<span class="string">'worker.js'</span>);</span><br><span class="line">worker.onMessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;event.data&#125; : 用来接收另一个线程发送过来的数据的回调<span class="comment">//用来绑定消息监听（主线程接收分线程返回的数据）</span></span><br><span class="line">worker.postMessage(data1) : 主线程向分线程发送数据</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>相关API<ul><li>Worker: 构造函数, 加载分线程执行的js文件</li><li>Worker.prototype.onmessage: 用于接收另一个线程的回调函数</li><li>Worker.prototype.postMessage: 向另一个线程发送消息</li></ul></li><li>不足<ul><li>worker内代码不能操作DOM(更新UI)</li><li>不能跨域加载JS</li><li>不是每个浏览器都支持这个新特性</li></ul></li></ol><p><img src="/2020/07/08/JS%E9%AB%98%E7%BA%A7/H5WebWorkers.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;序&lt;br&gt;&lt;br&gt;js进阶-&amp;gt;上流JS&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="前端三大块" scheme="http://xyx6.top/categories/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%A4%A7%E5%9D%97/"/>
    
    
      <category term="JavaScript" scheme="http://xyx6.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript</title>
    <link href="http://xyx6.top/2020/07/05/JavaScript/"/>
    <id>http://xyx6.top/2020/07/05/JavaScript/</id>
    <published>2020-07-05T11:08:05.000Z</published>
    <updated>2020-07-09T07:33:42.189Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>序<br><br>终于开始学前端的核心内容了！学好JS才能为后面的jQuery( JavaScript 库)和JS框架(React,Vue,Angular)打好基础，冲冲冲！</p></blockquote><a id="more"></a><h1 id="js基本语法"><a href="#js基本语法" class="headerlink" title="js基本语法"></a>js基本语法</h1><h2 id="引入js"><a href="#引入js" class="headerlink" title="引入js"></a>引入js</h2><ul><li><p>可以编写到标签的onclick属性中，也可以写在标签的属性中，但是他们属于行为和结构耦合，不方便维护，不推荐</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"alert('xxx')"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:alert('xxx')"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>可以写在标签或者外部文件中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>js标签一旦引入外部文件了，就不能再编码了，即使编写了浏览器也会忽略；如果需要则可以再创建一个新的script标签用于编写内部代码，执行顺序按从上至下依次执行。</p></li></ul><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><ul><li>在js中所有的可以由我们自主命名的都可以成为标识符</li><li>例如：变量名，函数名，属性名等等</li><li>命名一个标识符需要遵守如下规则：<ol><li>标识符可以包含字母，数字，_，$</li><li>标识符不能以数字开头</li><li>标识符不能是关键字和保留字</li></ol></li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>数据类型</li></ul><p>String，Number，Boolean，Null，Undefined，Object(object不属于基本数据类型)</p><ul><li><p>数组</p><blockquote><p>用方括号书写，数组的项目由逗号分隔。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">下面的代码声明（创建）了名为 cars 的数组，包含三个项目（汽车品牌）：</span><br><span class="line"><span class="keyword">var</span> cars = [<span class="string">"Porsche"</span>, <span class="string">"Volvo"</span>, <span class="string">"BMW"</span>];</span><br></pre></td></tr></table></figure></li><li><p>typeof 运算符</p></li></ul><p>可使用typeof 来确定 JavaScript 变量的类型,typeof 运算符返回变量或表达式的类型</p><ul><li>进制</li></ul><ol><li>表示16进制的数字，需要0x开头</li><li>表示8进制的数字，需要0开头</li><li>表示2进制的数字，需要0b开头</li></ol><ul><li>强制转换<ol><li>将其他数据类型转换为String<ul><li>方法一：调用被转换数据类型的toString()方法</li><li>该方法不影响原变量，他会将转换的结果返回</li><li>但是注意null和undefined这两个值没有toString()方法，会报错</li><li>方法二：调用String()函数，并将被转换的数据作为参数传递给函数</li><li>使用String()函数强制转换时，对于Number和Boolean实际上就是调用toString()方法，但是对于null和undefined就会将他们转换为字符串”null”和”undefined”</li></ul></li><li>将其他数据类型转换为Number<ul><li>方法一：使用Number()函数</li><li>如果字符串中有非数字的内容，则转换为NaN</li><li>如果字符串是空或者是全空格，则转换为0</li><li>方法二：这种方法专用于字符串</li><li>parseInt()把一个字符串转换为一个整数 //将一个字符串中的有效内容的整数内容读取出来转换为Number</li><li>parseFloat()把一个字符串转换为一个浮点数//将一个字符串中的有效内容的小数内容读取出来转换为Number</li><li>可以用一元的+来进行隐式的类型转换</li></ul></li><li>将其他数据类型转换为Boolean<ul><li>使用Boolean()函数<pre><code>* 数字-&gt;布尔(除了0和NaN，其余都是true)* 字符串-&gt;布尔(除了空串，其余都是true)* null和undefined都会转换为false* 对象也会转换为true</code></pre></li></ul></li></ol></li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul><li><p>逻辑运算符</p><ul><li><p>!</p><p>非运算可以对一个布尔值进行取反，true变false false边true<br>当对非布尔值使用!时，会先将其转换为布尔值然后再取反<br>我们可以利用!来将其他的数据类型转换为布尔值</p></li><li><p>&amp;&amp;</p><p>&amp;&amp;可以对符号两侧的值进行与运算<br>只有两端的值都为true时，才会返回true。只要有一个false就会返回false。<br>与是一个短路的与，如果第一个值是false，则不再检查第二个值<br>对于非布尔值，它会将其转换为布尔值然后做运算，并返回原值<br>规则：</p></li></ul><p> 1.如果第一个值为false，则返回第一个值<br> 2.如果第一个值为true，则返回第二个值</p><ul><li><p>||</p><p>||可以对符号两侧的值进行或运算<br>只有两端都是false时，才会返回false。只要有一个true，就会返回true。<br>或是一个短路的或，如果第一个值是true，则不再检查第二个值<br>对于非布尔值，它会将其转换为布尔值然后做运算，并返回原值<br>规则：1. 如果第一个值为true，则返回第一个值2. 如果第一个值为false，则返回第二个值</p></li></ul></li></ul><h2 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h2><ul><li>break关键字可以用来退出switch或循环语句</li><li>不能在if语句中使用break和continue</li><li>break关键字，会立即终止离他最近的那个循环语句</li><li>continue可以跳过当次循环</li></ul><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><blockquote><p>对象属于一种复合的数据类型，在对象中可以保存多个不同数据类型的属性</p></blockquote><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ol><li>内建对象</li></ol><ul><li>由ES标准中定义的对象，在任何的ES的实现中都可以使用</li><li>比如：Math String Number Boolean Function Object…</li></ul><ol start="2"><li>宿主对象</li></ol><ul><li>由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象</li><li>比如：BOM DOM</li></ul><ol start="3"><li>自定义对象</li></ol><ul><li>由开发人员自己创建的对象</li></ul><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><ol><li>方法一<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure></li></ol><ul><li>基本数据类型的数据，变量是直接保存的它的值。</li><li>变量与变量之间是互相独立的，修改一个变量不会影响其他的变量。</li><li>引用数据类型的数据，对象是保存在堆内存中的，每创建一个新对象，就会在堆内存中开辟一个新的空间，而变量保存的是对象的内存地址，如果两个变量保存的是同一个对象引用，当我们通过一个变量修改属性时，另一个也会受到影响</li><li>当两个引用数据类型比较时，比较的是对象的内存地址</li></ul><ol start="2"><li>方法二<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br></pre></td></tr></table></figure></li></ol><ul><li>使用对象字面量可以在创建对象的时候，直接指定对象中的属性</li><li>语法：{属性名：属性值，属性名：属性值，···}//要是属性名过于特殊，则要加引号</li></ul><ol start="3"><li>向对象中添加属性<ul><li>语法：对象.属性名=属性值;</li><li>对象[“属性名”] = 属性值; 这种方式能够使用特殊的属性名</li><li>对象的属性名没有任何要求，不需要遵守标识符的规范，但是在开发中，尽量按照标识符的要求去写。属性值也可以任意的数据类型。</li></ul></li><li>读取对象中的属性<ul><li>语法：对象.属性名</li><li>对象[“属性名”] ;“属性名”可以使字符串常量，也可以是字符串变量</li><li>如果读取一个对象中没有的属性，它不会报错，而是返回一个undefined</li></ul></li><li>修改对象中的属性<ul><li>语法：对象.属性值=新值</li></ul></li><li>删除对象中的属性<ul><li>语法：delete 对象.属性名  <pre><code>delete 对象[&quot;属性名&quot;]</code></pre></li></ul></li></ol><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><blockquote><p>函数也是一个对象，函数主要用来封装一些功能</p></blockquote><ol><li>创建函数<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">函数声明</span><br><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params">形参<span class="number">1</span>,形参<span class="number">2.</span>..形参N</span>)</span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">语句...  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">函数表达式：将要封装的代码以字符串的形式传递给构造函数</span><br><span class="line"><span class="keyword">var</span> 函数名 = <span class="function"><span class="keyword">function</span>(<span class="params">形参<span class="number">1</span>,形参<span class="number">2.</span>..形参N</span>)</span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">语句...  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>立即执行函数<ul><li>函数定义完，立即被调用，这种函数叫做立即执行函数</li><li>立即执行函数往往只会执行一次<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;  </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"a = "</span>+a);  </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"b = "</span>+b);  </span><br><span class="line">&#125;)(<span class="number">123</span>,<span class="number">456</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li>枚举对象中的属性<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> 变量 <span class="keyword">in</span> 对象)&#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><ol><li>全局作用域<ul><li>直接在script标签中编写的代码都运行在全局作用域中 </li><li>全局作用域在页面打开时创建，在页面关闭时销毁</li><li>在全局作用域中有一个全局对象window，他代表的是一个浏览器的窗口，他由浏览器创建时我们可以直接使用</li><li>在全局作用域中创建的变量都会作为window对象的属性保存</li><li>在全局作用域中创建的函数都会作为window对象的方法保存</li><li>在全局作用域中创建的变量和函数可以在页面的任意位置访问</li><li>在函数作用域中也可以访问到全局作用域的变量</li></ul></li><li>函数作用域<ul><li>调用函数时创建函数作用域，函数执行完毕后，函数作用域销毁</li><li>每调用一个函数就会创建一个新的函数作用域，他们之间是相互独立的</li><li>在函数作用域中可以访问到全局作用域的变量</li><li>在全局作用域中无法访问到函数作用域的变量</li><li>当在函数作用域中操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用，如果没有就向上一级的作用域中寻找，直到找到全局作用域，若全局作用域中还没有，则会报错</li></ul></li><li>变量的声明提前<ul><li>在全局作用域中，使用var关键字声明的变量会在所有代码执行前被声明(但是不会被赋值)，但是如果声明变量不使用var关键字，则变量不会被声明提前</li><li>在函数作用域中，也具有同上特性，使用var关键字声明的变量会在函数所有的代码执行前被声明，如果没有使用var关键字声明变量，则变量会变成全局变量</li></ul></li><li>函数的声明提前<ul><li>使用函数声明形式创建的函数function 函数名(){},他会在所有代码执行前被创建，所以我们可以在函数声明前调用函数；使用函数表达式(var fun = function(){})创建的函数没有该特性</li><li>在函数作用域中，使用函数声明创建的函数，会在所有的函数中的代码执行之前就被创建好了</li></ul></li></ol><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><blockquote><p>我们每次调用函数时，解析器都会将一个上下文对象作为隐含的参数传递进函数。<br>使用this来引用上下文对象，根据函数的调用形式不同，this的值也不同。</p></blockquote><ul><li>this的不同的情况：<ol><li>以函数的形式调用时，this是window</li><li>以方法的形式调用时，this就是调用方法的对象</li><li>以构造函数的形式调用时，this就是新创建的对象</li><li>在事件的响应函数中，响应函数是给谁绑定的this，那么这个this就是谁</li></ol></li></ul><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ul><li>一个构造函数我们也可以称为一个类</li><li>通过一个构造函数创建的对象，我们称该对象时这个构造函数的实例</li><li>可以用 instanceof 用来检查一个对象是否是一个类的实例</li><li>通过同一个构造函数创建的对象，我们称为一类对象</li><li>构造函数就是一个普通的函数，只是他的调用方式不同，如果直接调用，它就是一个普通函数，如果使用new来调用，则它就是一个构造函数</li><li>构造函数的执行流程：<ol><li>创建一个新的对象</li><li>将新建的对象设置为函数中的this，在构造函数中用this来引用新建的对象</li><li>执行函数中的代码</li><li>将新建的对象返回<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name , age , gender</span>)</span>&#123;  </span><br><span class="line"><span class="keyword">this</span>.name = name;  </span><br><span class="line"><span class="keyword">this</span>.age = age;  </span><br><span class="line"><span class="keyword">this</span>.gender = gender;  </span><br><span class="line"><span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">   alert(<span class="keyword">this</span>.name);  </span><br><span class="line">&#125;;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="原型-prototype"><a href="#原型-prototype" class="headerlink" title="原型 prototype"></a>原型 prototype</h2><ul><li>我们所创建的每一个函数，解析器都会像函数中添加一个属性prototype</li><li>prototype属性指向的是一个对象，这个对象我们称为原型对象</li><li>当函数作为构造函数使用，<strong>它所创建的对象中都会有一个隐含的属性执行该原型对象</strong>，并且这个隐含的属性可以通过对象.<strong>proto</strong>来访问</li><li>当我们访问对象的一个属性或者是方法是，他会先在对象自身中寻找，如果有就直接使用；如果没有就回去原型对象中寻找，找到则直接使用</li><li>原型对象就相当于一个公共的区域，凡是通过同一个构造函数创建的对象他们通常都可以访问到相同的原型对象</li><li>举例：<br><img src="/2020/07/05/JavaScript/js%E5%8E%9F%E5%9E%8B.png" alt></li><li><strong>作用：如果将构造函数中的函数定义在全局作用域中，污染了全局作用域的命名空间，而且定义在全局作用域中很不安全，所以我们可以将对象共有的属性和方法放在原型对象中，这样既不用分别为每一个对象添加，也不会影响全局作用域，就可以使每个对啊ing都具有这些属性和方法了</strong></li><li>hasOwnProperty()<blockquote><p>这个方法可以用来检查对象自身中是否含有某个属性</p><blockquote><p>语法：对象.hasOwnProperty(“属性名”)</p></blockquote></blockquote></li><li>原型也是对象，所以他也有原型<blockquote><p>当我们使用一个对象或方法时，会先在自身中寻找，自身要是有就直接使用</p><blockquote><p>如果自身没有就去原型对象中寻找，如果有就直接使用</p><blockquote><p>如果原型对象中还没有，就去原型的原型中去寻找，直到找到object对象（object没有以原型），如果还没找到就返回undefined<br> <img src="/2020/07/05/JavaScript/%E5%8E%9F%E5%9E%8B%E7%9A%84%E5%8E%9F%E5%9E%8B.png" alt> </p></blockquote></blockquote></blockquote></li></ul><h2 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h2><ul><li>当我们直接在页面中打印一个对象时，事实上是输出的对象的toString()方法的返回值<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改Person原型的toString方法的返回值  </span></span><br><span class="line">   Person.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="string">"Person[name="</span>+<span class="keyword">this</span>.name+<span class="string">",age="</span>+<span class="keyword">this</span>.age+<span class="string">",gender="</span>+<span class="keyword">this</span>.gender+<span class="string">"]"</span>;  </span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2></li><li>就像人生活的时间长了会产生垃圾一样，程序运行过程中也会产生垃圾,这些垃圾积攒过多以后，会导致程序运行的速度过慢，所以我们需要一个垃圾回收的机制，来处理程序运行过程中产生垃圾</li><li>当一个对象没有任何的变量或属性对它进行引用，此时我们将永远无法操作该对象，此时这种对象就是一个垃圾，这种对象过多会占用大量的内存空间，导致程序运行变慢，所以这种垃圾必须进行清理。</li><li>在JS中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁，我们不需要也不能进行垃圾回收的操作，<strong>我们需要做的只是要将不再使用的对象设置null即可</strong></li></ul><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><ul><li>数组也是一个对象，是一个用来存储数据的对象和Object类似，但是它的存储效率比普通对象要高，数组中保存的内容我们称为元素<h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">方法一：</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();  </span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">123</span>;  </span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">"hello"</span>;</span><br><span class="line">方法二：</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">123</span>,<span class="string">"hello"</span>];</span><br></pre></td></tr></table></figure><h2 id="数组的方法"><a href="#数组的方法" class="headerlink" title="数组的方法"></a>数组的方法</h2>FunctionName | Function</li></ul><p>–|–<br>push() | 用来向数组的末尾添加一个或多个元素，并返回数组新的长度<br>pop()    | 用来删除数组的最后一个元素，并返回被删除的元素<br>unshift()|向数组的开头添加一个或多个元素，并返回数组的新的长度<br>shift()|删除数组的开头的一个元素，并返回被删除的元素<br>slice(start,end)|可以从一个数组中截取指定的元素，该方法不会影响原数组，而是将截取到的内容封装为一个新的数组并返回<br>splice()|可以用来删除数组中指定元素，并使用新的元素替换，该方法会将删除的元素封装到新数组中返回，第三个及以后，都是替换的元素，这些元素将会插入到开始位置索引的前边<br>concat()|可以连接两个或多个数组，它不会影响原数组，而是连接数组作为返回值返回<br>join()|可以将一个数组转换为一个字符串,它不会影响原数组，而是转换后的数组作为返回值返回<br>reverse()|可以用来反转一个数组，它会对原数组产生影响<br>sort()|可以对一个数组中的内容进行排序，默认是按照Unicode编码进行排序，他会对原数组产生影响，我们可以自己来指定排序的规则我们可以在sort()添加一个回调函数【数组.sort(functiom(a,b){});】，来指定排序规则，回调函数中需要定义两个形参</p><h2 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h2><ol><li><p>用for循环来遍历数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">方法一：</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span> ; i&lt;数组.length ; i++)&#123;  </span><br><span class="line">    <span class="comment">//数组[i]  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用forEach()方法来遍历数组（不兼容IE8）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">数组.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value , index , obj</span>)</span>&#123;  </span><br><span class="line">  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">value:正在遍历的元素</span><br><span class="line">index:正在遍历元素的索引</span><br><span class="line">obj:被遍历对象</span><br></pre></td></tr></table></figure></li></ol><ul><li>forEach()方法需要一个回调函数作为参数，<br>数组中有几个元素，回调函数就会被调用几次，<br>每次调用时，都会将遍历到的信息以实参的形式传递进来，<br>我们可以定义形参来获取这些信息</li></ul><h1 id="常用类和方法"><a href="#常用类和方法" class="headerlink" title="常用类和方法"></a>常用类和方法</h1><h2 id="call-和apply"><a href="#call-和apply" class="headerlink" title="call()和apply()"></a>call()和apply()</h2><ul><li>这两个方法都是函数对象的方法，需要通过函数对象调用</li><li>当对函数调用call()和apply()都会调用函数执行</li><li>在调用call()和apply()可以将一个对象指定为第一个参数，此时这个对象将会成为函数执行时的this</li><li>call()方法可以将实参在对象之后一次传递</li><li>apply()方法需要将实参封装到一个数组中统一传递</li></ul><h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><ul><li>arguments是一个类数组对象，它可以通过索引来操作数据，也可以获取长度</li><li>在调用函数是，我们所传递的实参都会在arguments中保存</li><li>arguements.length可以用来获取实参长度</li><li>还可以用arguements来使用实参，arguements[0]表示第一个实参，arguements[1]表示第二个实参···</li><li>它里面有一个属性交callee，这个属性对应一个函数对象，就是当前正在指向的函数对象</li></ul><h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><ul><li>日期的对象，在JS中通过Date对象来表示一个时间</li><li>如果直接用构造函数创建一个Date对象，则封装为当前代码执行的时间</li><li>创建对象<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">创建一个当前的时间对象</span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line">创建一个指定的时间对象</span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">"月/日/年 时:分:秒"</span>);</span><br></pre></td></tr></table></figure></li><li>方法</li></ul><table><thead><tr><th>name</th><th>function</th></tr></thead><tbody><tr><td>getDate()</td><td>当前日期对象是几日（1-31）</td></tr><tr><td>getDay()</td><td>返回当前日期对象时周几（0-6），0 周日，1 周一 ···</td></tr><tr><td>getMonth()</td><td>返回当前日期对象的月份（0-11），0 一月， 1 二月 ···</td></tr><tr><td>getFullYear()</td><td>从 Date 对象以四位数字返回年份</td></tr><tr><td>getHours()</td><td>返回 Date 对象的小时 (0 ~ 23)</td></tr><tr><td>getMinutes()</td><td>返回 Date 对象的分钟 (0 ~ 59)</td></tr><tr><td>getSeconds()</td><td>返回 Date 对象的秒数 (0 ~ 59)</td></tr><tr><td>getMilliseconds()</td><td>返回 Date 对象的毫秒(0 ~ 999)</td></tr><tr><td>getTime()</td><td>返回当前日期对象的时间戳，时间戳，指的是从1970年月1日 0时0分0秒，到现在时间的毫秒数，计算机底层保存时间都是以时间戳的形式保存的</td></tr><tr><td>Date.now()</td><td>可以获取当前代码执行时的时间戳</td></tr></tbody></table><h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><ul><li>Math属于一个工具类，它不需要我们创建对象，它里边封装了属性运算相关的常量和方法,我们可以直接使用它来进行数学运算相关的操作</li><li>方法</li></ul><table><thead><tr><th>name</th><th>function</th></tr></thead><tbody><tr><td>Math.PI</td><td>常量，圆周率</td></tr><tr><td>Math.abs()</td><td>绝对值运算</td></tr><tr><td>Math.cell()</td><td>向上取整</td></tr><tr><td>Math.floor()</td><td>向下取整</td></tr><tr><td>Math.round()</td><td>四舍五入取整</td></tr><tr><td>Math.random()</td><td>生成一个01之间的随机数</td></tr><tr><td>Math.round(Math.random()*(y-x)+x)</td><td>生成一个xy之间的随机数</td></tr><tr><td>Math.pow(x,y)</td><td>求x的y次幂</td></tr><tr><td>Math.sqrt()</td><td>对一个数进行开方</td></tr><tr><td>Math.max()</td><td>求多个数中最大值</td></tr><tr><td>Math.min()</td><td>求多个数中的最小值</td></tr></tbody></table><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><ul><li>在JS中为我们提供了三个包装类，通过这三个包装类可以将基本的数据类型的数据转换为对象： String() Boolean() Number()通过这三个包装类可以创建基本数据类型的对象<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">通过包装类创建基本数据类型的对象：</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">2</span>);  </span><br><span class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"hello"</span>);  </span><br><span class="line"><span class="keyword">var</span> bool = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure></li><li>但是在实际应用中千万不要这么干。当我们去操作一个基本数据类型的属性和方法时，解析器会临时将其转换为对应的包装类，然后再去操作属性和方法，操作完成以后再将这个临时对象进行销毁</li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul><li>在底层字符串是以字符数组的形式保存的</li><li>方法</li></ul><table><thead><tr><th>name</th><th>function</th></tr></thead><tbody><tr><td>length</td><td>获取字符串的长度</td></tr><tr><td>charAt()</td><td>根据索引获取指定的字符</td></tr><tr><td>charCodeAt()</td><td>根据索引获取指定的字符编码(Unicode编码)</td></tr><tr><td>String.fromCharCode()</td><td>根据字符编码获取字符</td></tr><tr><td>indexof()</td><td>可以检索一个字符串是否含有指定内容，需要一个字符串作为参数，这个字符串就是要检索的内容，如果找到该内容，则会返回其第一次出现的索引，如果没有找到则返回-1，可以指定一个第二个参数，来表示开始查找的位置</td></tr><tr><td>lastIndexOf()</td><td>功能同indexof，indexOf()是从前向后找，lastIndexOf()是从后向前找</td></tr><tr><td>slice(start,end)</td><td>可以从一个字符串中截取指定的内容，并将截取到内容返回，不会影响原变量，参数：第一个：截取开始的位置（包括开始），第二个：截取结束的位置（不包括结束）可以省略第二个参数，如果省略则一直截取到最后，可以传负数，如果是负数则从后往前数</td></tr><tr><td>substr()</td><td>和slice()基本一致，不同的是它第二个参数不是索引，而是截取的数量</td></tr><tr><td>substring()</td><td>和slice()基本一致，不同的是它不能接受负值作为参数，如果设置一个负值，则会自动修正为0，substring()中如果第二个参数小于第一个，自动调整位置</td></tr><tr><td>toLowerCase()</td><td>将字符串转换为小写并返回</td></tr><tr><td>toUpperCase()</td><td>将字符串转换为大写并返回</td></tr><tr><td>正则表达式相关方法:</td><td></td></tr><tr><td>split()</td><td>可以将一个字符串拆分成一个数组，方法中可以传一个正则表达式作为参数，这样方法就会根据正则表达式去拆分字符串</td></tr><tr><td>search()</td><td>可以搜索字符串中是否含有指定内容，如果搜索到指定内容，则会返回第一次出现的索引，如果没有则返回-1，它可以接受正则表达式作为参数，然后根据正则表达式去检索字符串,search只会查找第一个，即使设置全局匹配也没用</td></tr><tr><td>match()</td><td>可以根据正则表达式，从一个字符串中将符合条件的内容提取出来，默认情况下我们的match只会找到第一个符合要求的内容，找到以后就停止检索，我们可以设置正则表达式为全局匹配模式，这样就会匹配到所有的内容，可以为一个正则表达式设置多个匹配模式，且顺序无所谓，match()会将匹配到的内容封装到一个数组中返回，即使只查询到一个结果</td></tr><tr><td>replace()</td><td>可以将字符串中指定内容替换为新的内容,参数：1.被替换的内容，可以接受一个正则表达式作为参数2.新的内容；替换为””则为删除,默认只会替换第一个</td></tr></tbody></table><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><ul><li><p>用于定义一些字符串的规则，计算机可以根据正则表达式来检查一个字符串是否符合规则，并将字符串中符合规则的内容提取出来</p></li><li><p>创建正则表达式</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">方法一：</span><br><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(“正则”,”匹配模式”); </span><br><span class="line"></span><br><span class="line">方法二：</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/正则表达式/</span>匹配模式; </span><br><span class="line"><span class="comment">//（匹配模式可以多个一起写：/gi）</span></span><br><span class="line"></span><br><span class="line">匹配模式：</span><br><span class="line">i:忽略大小写（ignore）</span><br><span class="line">g:全局匹配模式（默认为<span class="number">1</span>次）</span><br><span class="line">m:执行多行匹配</span><br><span class="line">设置匹配模式时，可以都不设置，也可以设置<span class="number">1</span>个，也可以全设置，设置时没有顺序要求</span><br></pre></td></tr></table></figure><ul><li>test()<ul><li>语法：正则表达式.test(字符串)</li><li>可以用来检查一个字符串是否符合正则表达式，如果符合返回true，否则返回false</li></ul></li></ul></li><li><p>正则语法</p><ul><li>| 或</li><li>[] 或   //[]里的内容也是或的关系</li><li>[^···] 除了 //除了···都为true</li><li><strong>[x-y] x的ascii到y的ascii码之间的值</strong>  </li><li>[a-z] 小写字母 （也可以[e-i])</li><li>[A-Z] 大写字母</li><li>[A-z] 任意字母,但是还包括了其他ASCII在此之中的</li><li>[0-9] 任意数字</li></ul></li><li><p>量词</p><ul><li>通过量词可以设置一个内容出现的次数，<strong>量词只对它前边的一个内容起作用</strong></li><li>{n} &nbsp;&nbsp;&nbsp;&nbsp;正好出现n次</li><li>{m,n} &nbsp;&nbsp;&nbsp;出现m~n次</li><li>{m,} &nbsp;&nbsp;&nbsp;出现m次以上</li><li>+&nbsp;&nbsp;&nbsp;至少一个，相当于{1,}</li><li>*&nbsp;&nbsp;&nbsp;0个或多个，相当于{0,}</li><li>?&nbsp;&nbsp;&nbsp;0个或1个，相当于{0,1}</li></ul></li><li><p>边界表达式</p><ul><li>^表示开头</li><li>$表示结尾</li><li>在正则表达式中同时使用^$则要求字符串必须符合正则表达式<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line">reg = <span class="regexp">/^a/</span>;  <span class="comment">//以a开头</span></span><br><span class="line">reg = <span class="regexp">/b$/</span>;  <span class="comment">//以b接位</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>元符号</p><ul><li>. &nbsp;&nbsp;&nbsp;&nbsp;表示任意字符</li><li>\ &nbsp;. &nbsp;表示 .</li><li>&amp;nbsp;\ &nbsp;表示 \</li><li>\w&nbsp;&nbsp;任意字母、数字、_ [A-z0-9_]</li><li>\W&nbsp;&nbsp;除了字母、数字、_ [ ^A-z0-9_]</li><li>\d&nbsp;&nbsp;任意的数字 [0-9]</li><li>\D&nbsp;&nbsp;除了数字 [ ^0-9]</li><li>\s&nbsp;&nbsp;空格</li><li>\S&nbsp;&nbsp;除了空格</li><li>\b&nbsp;&nbsp;单词边界</li><li>\B&nbsp;&nbsp;除了单词边界</li></ul></li><li><p>正则表达式应用举例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">去掉字符串两端的空格:</span><br><span class="line"><span class="keyword">var</span> s = <span class="string">"        he    llo    "</span>;   </span><br><span class="line">s = s.replace(<span class="regexp">/^\s*|\s*$/g</span>,<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">邮件的正则:</span><br><span class="line">hello.nihao@abc.com.cn</span><br><span class="line">任意字母下划线 . 任意字母下划线  @ 任意字母数字 .任意字母(<span class="number">2</span><span class="number">-5</span>位) .任意字母(<span class="number">2</span><span class="number">-5</span>位)</span><br><span class="line">\w&#123;<span class="number">3</span>,&#125;  (\.\w+)*  @  [A-z0<span class="number">-9</span>]+  (\.[A-z]&#123;<span class="number">2</span>,<span class="number">5</span>&#125;)&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>Document Object Model文档对象模型,通过DOM可以来任意来修改网页中各个内容</p></blockquote><ul><li>文档<ul><li>文档指的是网页，一个网页就是一个文档</li></ul></li><li>对象<ul><li>对象指将网页中的每一个节点都转换为对象,转换完对象以后，就能以一种纯面向对象的形式来操作网页了</li></ul></li><li>模型<ul><li>模型用来表示节点和节点之间的关系，方便操作页面</li></ul></li><li>节点（Node）<ul><li>节点是构成网页的最基本的单元，网页中的每一个部分都可以称为是一个节点</li><li>虽然都是节点，但是节点的类型却是不同的</li><li>常用的节点：<ol><li>文档节点 （Document），代表整个网页</li><li>元素节点（Element），代表网页中的标签</li><li>属性节点（Attribute），代表标签中的属性</li><li>文本节点（Text），代表网页中的文本内容<br><img src="/2020/07/05/JavaScript/node.png" alt></li></ol></li></ul></li></ul><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><blockquote><p>就是用户和浏览器的交互行为，我们可以在事件对应的属性中设置一些js代码，事件被触发时执行代码</p></blockquote><ul><li><p>浏览器加载一个页面时，是按照从上至下的顺序加载的，如果把script标签放在页面上面，在代码执行时，页面还没有加载，就无法获取到dom对象，解决方法如下：</p><ol><li>解决方式一：可以将js代码编写到body的下边</li><li>解决方式二：将js代码编写到window.onload = function(){}，window.onload 对应的回调函数会在整个页面加载完毕以后才执行，所以可以确保代码执行时，DOM对象已经加载完毕了<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"> <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">     <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"btn"</span>);  </span><br><span class="line">     btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">     &#125;;  </span><br><span class="line"> &#125;;  </span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="DOM操作HTML"><a href="#DOM操作HTML" class="headerlink" title="DOM操作HTML"></a>DOM操作HTML</h2></li></ol></li><li><p>document对象获取元素节点对象</p><ol><li>getElementById()<ul><li>通过元素的id属性获取一个元素节点对象：</li></ul></li><li>getElementsByTagName()<ul><li>通过标签名获取一组元素节点对象</li></ul></li><li>getElementsByName()<ul><li>通过name属性获取一组元素节点对象</li></ul></li></ol></li><li><p>document对象的其他的属性和方法</p><ol><li>document.all<ul><li>获取页面中的所有元素，相当于document.getElementsByTagName(“*”);</li></ul></li><li>document.documentElement<ul><li>获取页面中html根元素</li></ul></li><li>document.body<ul><li>获取页面中的body元素</li></ul></li><li>document.getElementsByClassName()<ul><li>根据元素的class属性值查询一组元素节点对象//这个方法不支持IE8及以下的浏览器</li></ul></li><li>document.querySelector()<ul><li>根据CSS选择器去页面中查询一个元素，如果匹配到的元素有多个，则它会返回查询到的第一个元素</li></ul></li><li>document.querySelectorAll()<ul><li>用法同5，根据CSS选择器去页面中查询一组元素，会将匹配到所有元素封装到一个数组中返回，即使只匹配到一个</li></ul></li></ol></li><li><p>元素的属性：</p><ul><li><p>读取元素的属性：</p><ul><li>语法：元素.属性名</li><li>注意：class属性不能采用这种方式，读取class属性时需要使用 元素.className</li></ul></li><li><p>修改元素的属性：<br>语法：元素.属性名 = 属性值</p></li></ul></li><li><p>innerHTML</p><blockquote><p>使用该属性可以获取或设置元素内部的HTML代码</p></blockquote></li><li><p>获取元素节点的子节点</p><ul><li><p>元素.getElementsByTagName()</p><ul><li>通过标签名查询当前元素的指定后代元素</li></ul></li><li><p>子节点包括便签元素中的文本，子元素自包含标签元素</p></li><li><p>元素.childNodes</p><ul><li>获取当前元素的所有子节点，会获取到空白的文本子节点</li><li>childNodes属性会获取包括文本节点在内的所有节点，根据DOM标签标签间空白也会当成文本节点【注意：在IE8及以下的浏览器中，不会将空白文本当成子节点，所以该属性在IE8中会返回4个子元素而其他浏览器是9个】</li></ul></li><li><p>元素.children</p><ul><li>获取当前元素的所有子元素</li></ul></li><li><p>元素.firstChild</p><ul><li>获取当前元素的第一个子节点，会获取到空白的文本子节点</li></ul></li><li><p>元素.lastChild</p><ul><li>获取当前元素的最后一个子节点</li></ul></li><li><p>元素.parentNode</p><ul><li>获取当前元素的父元素</li></ul></li><li><p>元素.previousSibling</p><ul><li>获取当前元素的前一个兄弟节点</li><li>previousElementSibling获取前一个兄弟元素，IE8及以下不支持</li></ul></li><li><p>元素.nextSibling</p><ul><li>获取当前元素的后一个兄弟节点</li></ul></li><li><p>firstElementChild</p><ul><li>获取当前元素的第一个子元素</li><li>firstElementChild不支持IE8及以下的浏览器，如果需要兼容他们尽量不要使用</li></ul></li><li><p>innerHTML和innerText</p><ul><li>这两个属性并没有在DOM标准定义，但是大部分浏览器都支持这两个属性<br>两个属性作用类似，都可以获取到标签内部的内容，<br>不同是innerHTML会获取到html标签，而innerText会自动去除标签<br>如果使用这两个属性来设置标签内部的内容时，没有任何区别的</li></ul></li><li><p>读取标签内部的文本内容</p><ul><li>元素.firstChild.nodeValue</li></ul></li></ul></li></ul><h2 id="DOM修改"><a href="#DOM修改" class="headerlink" title="DOM修改"></a>DOM修改</h2><ul><li><p>document.createElement()</p><ul><li>可以用于创建一个元素节点对象，它需要一个标签名作为参数，将会根据该标签名创建元素节点对象，并将创建好的对象作为返回值返回</li></ul></li><li><p>document.createTextNode()</p><ul><li>可以根据文本内容创建一个文本节点对象</li></ul></li><li><p>父节点.appendChild(子节点)</p><ul><li>向父节点中添加指定的子节点</li></ul></li><li><p>父节点.insertBefore(新节点,旧节点)</p><ul><li>将一个新的节点插入到旧节点的前边</li></ul></li><li><p>父节点.replaceChild(新节点,旧节点)</p><ul><li>使用一个新的节点去替换旧节点</li></ul></li><li><p>父节点.removeChild(子节点)</p><ul><li>删除指定的子节点</li><li>推荐方式：子节点.parentNode.removeChild(子节点)</li></ul></li></ul><h2 id="DOM操作CSS"><a href="#DOM操作CSS" class="headerlink" title="DOM操作CSS"></a>DOM操作CSS</h2><ul><li><p>读取和修改内联样式</p><ul><li>使用style属性来操作元素的内联样式</li><li>读取内联样式：</li><li>语法：元素.style.样式名<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">元素.style.width</span><br><span class="line">元素.style.height</span><br><span class="line">注意：如果样式名中带有-，则需要将样式名修改为驼峰命名法将-去掉，然后后的字母改大写</span><br><span class="line">比如：backgroundcolor &gt; backgroundColor</span><br><span class="line">borderwidth &gt; borderWidth</span><br></pre></td></tr></table></figure></li></ul></li><li><p>修改内联样式：</p><ul><li>语法：元素.style.样式名 = 样式值</li><li>通过style修改和读取的样式都是内联样式，由于内联样式的优先级比较高，所以我们通过JS来修改的样式，往往会立即生效，但是如果样式中设置了!important，则内联样式将不会生效。</li></ul></li><li><p>读取元素的当前样式</p><ol><li>正常浏览器</li></ol><ul><li>使用getComputedStyle()</li><li>这个方法是window对象的方法，可以返回一个对象，这个对象中保存着当前元素生效样式</li><li>参数：<ul><li>1.要获取样式的元素</li><li>2.可以传递一个伪元素，一般传null</li><li>例子：<ul><li>获取元素的宽度</li><li>getComputedStyle(box , null)[“width”];</li><li>通过该方法读取到样式都是只读的不能修改</li></ul></li></ul></li><li>可以通过对象.样式名来读取样式</li><li>如果获取的样式没有设置，则会获取到真实的值，而不是默认值</li></ul><ol start="2"><li>IE8</li></ol><ul><li>使用currentStyle</li><li>语法：<ul><li>元素.currentStyle.样式名</li><li>例子：<ul><li>box.currentStyle[“width”]</li><li>通过这个属性读取到的样式是只读的不能修改</li></ul></li></ul></li></ul></li><li><p>实现兼容性</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">* 定义一个函数，用来获取指定元素的当前的样式  </span></span><br><span class="line"><span class="comment">* 参数：  </span></span><br><span class="line"><span class="comment">* obj 要获取样式的元素  </span></span><br><span class="line"><span class="comment">* name 要获取的样式名  </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStyle</span>(<span class="params">obj , name</span>)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.getComputedStyle)&#123;  </span><br><span class="line">        <span class="comment">//正常浏览器的方式，具有getComputedStyle()方法  </span></span><br><span class="line">        <span class="keyword">return</span> getComputedStyle(obj , <span class="literal">null</span>)[name];  </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">        <span class="comment">//IE8的方式，没有getComputedStyle()方法  </span></span><br><span class="line">        <span class="keyword">return</span> obj.currentStyle[name];  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//简写：return window.getComputedStyle?getComputedStyle(obj , null)[name]:obj.currentStyle[name];  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>其他的样式相关的属性<blockquote><p>注意：以下样式都是只读的，不能修改，未指明偏移量都是相对于当前窗口左上角</p></blockquote></li></ul><table><thead><tr><th>name</th><th>function</th></tr></thead><tbody><tr><td>clientHeight</td><td>元素的可见高度，包括元素的内容区和内边距的高度</td></tr><tr><td>clientWidth</td><td>元素的可见宽度，包括元素的内容区和内边距的宽度</td></tr><tr><td>offsetHeight</td><td>整个元素的高度，包括内容区、内边距、边框</td></tr><tr><td>offfsetWidth</td><td>整个元素的宽度，包括内容区、内边距、边框</td></tr><tr><td>offsetParent</td><td>当前元素的定位父元素,离他最近的开启了定位的祖先元素，如果所有的元素都没有开启定位，则返回body</td></tr><tr><td>offsetLeft</td><td>当前元素和定位父元素之间的偏移量(水平偏移量)</td></tr><tr><td>offsetTop</td><td>当前元素和定位父元素之间的偏移量(垂直偏移量)</td></tr><tr><td>scrollHeight</td><td>获取元素整个滚动区域的高度</td></tr><tr><td>scrollWidth</td><td>获取元素整个滚动区域的宽度</td></tr><tr><td>scrollTop</td><td>获取元素垂直滚动条滚动的距离</td></tr><tr><td>scrollLeft</td><td>获取元素水平滚动条滚动的距离</td></tr><tr><td>scrollHeight -scrollTop = clientHeight</td><td>判断滚动条是否滚动到底(垂直滚动条)</td></tr><tr><td>scrollWidth -scrollLeft = clientWidth</td><td>判断滚动条是否滚动到底(水平滚动条)</td></tr></tbody></table><h1 id="事件-1"><a href="#事件-1" class="headerlink" title="事件"></a>事件</h1><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><ul><li><p>当响应函数被调用时，浏览器每次都会将一个事件对象作为实参传递进响应函数中，这个事件对象中封装了当前事件的相关信息，比如：鼠标的坐标，键盘的按键，鼠标的按键，滚轮的方向。。</p></li><li><p>可以在响应函数中定义一个形参，来使用事件对象，但是在IE8以下浏览器中事件对象没有做完实参传递，而是作为window对象的属性保存</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">元素.事件 = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;  </span><br><span class="line">    event = event || <span class="built_in">window</span>.event;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">元素.事件 = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;  </span><br><span class="line">e = e || event;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>获取到鼠标的坐标</p><ol><li><p>clientX和clientY</p><ul><li>用于获取鼠标在当前的可见窗口的坐标</li><li>div的偏移量，是相对于整个页面的</li></ul></li><li><p>pageX和pageY </p><ul><li>可以获取鼠标相对于当前页面的坐标但是这个两个属性在IE8中不支持，所以如果需要兼容IE8，则不要使用var left = event.clientX;var　top = event.clientY;</li></ul></li></ol></li></ul><h2 id="事件的冒泡"><a href="#事件的冒泡" class="headerlink" title="事件的冒泡"></a>事件的冒泡</h2><ul><li>事件的冒泡指的是事件向上传导，当后代元素上的事件被触发时，将会导致其祖先元素上的同类事件也会触发</li><li>事件的冒泡大部分情况下都是有益的，如果需要取消冒泡，则需要使用事件对象来取消<br>可以将事件对象的cancelBubble设置为true，即可取消冒泡<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">元素.事件 = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;  </span><br><span class="line">    event = event || <span class="built_in">window</span>.event;  </span><br><span class="line">    event.cancelBubble = <span class="literal">true</span>;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="事件的委派"><a href="#事件的委派" class="headerlink" title="事件的委派"></a>事件的委派</h2></li><li>指将事件统一绑定给元素的共同的祖先元素，这样当后代元素上的事件触发时，会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件。</li><li>事件委派是利用了冒泡，通过委派可以减少事件绑定的次数，提高程序的性能</li><li>我们希望，只绑定一次事件，即可应用到多个的元素上，即使元素是后添加的<br>我们可以尝试将其绑定给元素的共同的祖先元素</li><li>target : event中的target表示的触发事件的对象</li></ul><h2 id="事件的绑定"><a href="#事件的绑定" class="headerlink" title="事件的绑定"></a>事件的绑定</h2><ul><li><p>addEventListener()</p></li><li><p>通过这个方法也可以为元素绑定响应函数</p></li><li><p>参数：</p><ol><li>事件的字符串，不要on</li><li>回调函数，当事件触发时该函数会被调用</li><li>是否在捕获阶段触发事件，需要一个布尔值，一般都传false</li></ol></li><li><p>使用addEventListener()可以同时为一个元素的相同事件同时绑定多个响应函数，<br>这样当事件被触发时，响应函数将会按照函数的绑定顺序执行,<strong>这个方法不支持IE8及以下的浏览器</strong></p></li><li><p>attachEvent()</p></li><li><p>在IE8中可以使用attachEvent()来绑定事件</p></li><li><p>参数：</p><ol><li>事件的字符串，要on</li><li>回调函数</li></ol></li><li><p>这个方法也可以同时为一个事件绑定多个处理函数，不同的是它是后绑定是事件先执行，执行顺序和addEventListener()相反</p></li><li><p>兼容模式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个函数，用来为指定元素绑定响应函数  </span></span><br><span class="line">            <span class="comment">/*  </span></span><br><span class="line"><span class="comment"> * addEventListener()中的this，是绑定事件的对象  </span></span><br><span class="line"><span class="comment"> * attachEvent()中的this，是window  </span></span><br><span class="line"><span class="comment"> *  需要统一两个方法this  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line">            <span class="comment">/*  </span></span><br><span class="line"><span class="comment"> * 参数：  </span></span><br><span class="line"><span class="comment"> * obj 要绑定事件的对象  </span></span><br><span class="line"><span class="comment"> * eventStr 事件的字符串(不要on)  </span></span><br><span class="line"><span class="comment"> *  callback 回调函数  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">obj , eventStr , callback</span>)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(obj.addEventListener)&#123;  </span><br><span class="line">        <span class="comment">//大部分浏览器兼容的方式  </span></span><br><span class="line">        obj.addEventListener(eventStr , callback , <span class="literal">false</span>);  </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">                     <span class="comment">/*  </span></span><br><span class="line"><span class="comment"> * this是谁由调用方式决定  </span></span><br><span class="line"><span class="comment"> * callback.call(obj)  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line">        <span class="comment">//IE8及以下  </span></span><br><span class="line">        obj.attachEvent(<span class="string">"on"</span>+eventStr , <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">            <span class="comment">//在匿名函数中调用回调函数  </span></span><br><span class="line">            callback.call(obj);  </span><br><span class="line">        &#125;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事件的传播"><a href="#事件的传播" class="headerlink" title="事件的传播"></a>事件的传播</h2></li><li><p>关于事件的传播网景公司和微软公司有不同的理解：</p><ul><li>微软公司认为事件应该是由内向外传播，也就是当事件触发时，应该先触发当前元素上的事件，然后再向当前元素的祖先元素上传播，也就说事件应该在冒泡阶段执行</li><li>网景公司认为事件应该是由外向内传播的，也就是当前事件触发时，应该先触发当前元素的最外层的祖先元素的事件，然后在向内传播给后代元素</li></ul></li><li><p>W3C综合了两个公司的方案，将事件传播分成了三个阶段：</p><ol><li>捕获阶段<ul><li>在捕获阶段时从最外层的祖先元素，向目标元素进行事件的捕获，但是默认此时不会触发事件</li></ul></li><li>目标阶段<ul><li>事件捕获到目标元素，捕获结束开始在目标元素上触发事件</li></ul></li><li>冒泡阶段<ul><li>事件从目标元素向他的祖先元素传递，依次触发祖先元素上的事件</li></ul></li></ol></li><li><p>如果希望在捕获阶段就触发事件，可以将addEventListener()的第三个参数设置为true</p></li><li><p>一般情况下我们不会希望在捕获阶段触发事件，所以这个参数一般都是false</p></li><li><p>IE8及以下的浏览器中没有捕获阶段</p></li></ul><h2 id="常用的事件"><a href="#常用的事件" class="headerlink" title="常用的事件"></a>常用的事件</h2><ul><li><p>拖拽事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;  </span><br><span class="line">    &lt;html&gt;  </span><br><span class="line">    &lt;head&gt;  </span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;  </span><br><span class="line">        &lt;title&gt;&lt;<span class="regexp">/title&gt;  </span></span><br><span class="line"><span class="regexp">&lt;style type="text/</span>css<span class="string">"&gt;  </span></span><br><span class="line"><span class="string">    #box1&#123;  </span></span><br><span class="line"><span class="string">width: 100px;  </span></span><br><span class="line"><span class="string">height: 100px;  </span></span><br><span class="line"><span class="string">background-color: red;  </span></span><br><span class="line"><span class="string">position: absolute;  </span></span><br><span class="line"><span class="string">&#125;  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">#box2&#123;  </span></span><br><span class="line"><span class="string">width: 100px;  </span></span><br><span class="line"><span class="string">height: 100px;  </span></span><br><span class="line"><span class="string">background-color: yellow;  </span></span><br><span class="line"><span class="string">position: absolute;  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">left: 200px;  </span></span><br><span class="line"><span class="string">top: 200px;  </span></span><br><span class="line"><span class="string">&#125;  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">    &lt;/style&gt;  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">&lt;script type="</span>text/javascript<span class="string">"&gt;  </span></span><br><span class="line"><span class="string">    window.onload = function()&#123;  </span></span><br><span class="line"><span class="string">    /*  </span></span><br><span class="line"><span class="string"> * 拖拽box1元素  </span></span><br><span class="line"><span class="string"> *  - 拖拽的流程  </span></span><br><span class="line"><span class="string"> * 1.当鼠标在被拖拽元素上按下时，开始拖拽  onmousedown  </span></span><br><span class="line"><span class="string"> * 2.当鼠标移动时被拖拽元素跟随鼠标移动 onmousemove  </span></span><br><span class="line"><span class="string"> * 3.当鼠标松开时，被拖拽元素固定在当前位置onmouseup  </span></span><br><span class="line"><span class="string"> */  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">    //获取box1  </span></span><br><span class="line"><span class="string">    var box1 = document.getElementById("</span>box1<span class="string">");  </span></span><br><span class="line"><span class="string">    var box2 = document.getElementById("</span>box2<span class="string">");  </span></span><br><span class="line"><span class="string">    //开启box1的拖拽  </span></span><br><span class="line"><span class="string">    drag(box1);  </span></span><br><span class="line"><span class="string">    //开启box2的  </span></span><br><span class="line"><span class="string">    drag(box2);  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">&#125;;  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">/*  </span></span><br><span class="line"><span class="string"> * 提取一个专门用来设置拖拽的函数  </span></span><br><span class="line"><span class="string"> * 参数：开启拖拽的元素  </span></span><br><span class="line"><span class="string"> */  </span></span><br><span class="line"><span class="string">function drag(obj)&#123;  </span></span><br><span class="line"><span class="string">    //当鼠标在被拖拽元素上按下时，开始拖拽  onmousedown  </span></span><br><span class="line"><span class="string">    obj.onmousedown = function(event)&#123;  </span></span><br><span class="line"><span class="string">        //设置box1捕获所有鼠标按下的事件  </span></span><br><span class="line"><span class="string">        /*  </span></span><br><span class="line"><span class="string"> * setCapture()  </span></span><br><span class="line"><span class="string"> * - 只有IE支持，但是在火狐中调用时不会报错，  </span></span><br><span class="line"><span class="string"> * 而如果使用chrome调用，会报错  </span></span><br><span class="line"><span class="string"> */  </span></span><br><span class="line"><span class="string">        /*if(box1.setCapture)&#123;  </span></span><br><span class="line"><span class="string">box1.setCapture();  </span></span><br><span class="line"><span class="string">&#125;*/  </span></span><br><span class="line"><span class="string">        //当调用setcapture方法之后，这个元素将会把下一次所有的鼠标按下相关事件捕获到自身上</span></span><br><span class="line"><span class="string">        obj.setCapture &amp;&amp; obj.setCapture();  </span></span><br><span class="line"><span class="string">        event = event || window.event;  </span></span><br><span class="line"><span class="string">        //div的偏移量 鼠标.clentX - 元素.offsetLeft  </span></span><br><span class="line"><span class="string">        //div的偏移量 鼠标.clentY - 元素.offsetTop  </span></span><br><span class="line"><span class="string">        var ol = event.clientX - obj.offsetLeft;  </span></span><br><span class="line"><span class="string">        var ot = event.clientY - obj.offsetTop;  </span></span><br><span class="line"><span class="string">        //为document绑定一个onmousemove事件  </span></span><br><span class="line"><span class="string">        document.onmousemove = function(event)&#123;  </span></span><br><span class="line"><span class="string">            event = event || window.event;  </span></span><br><span class="line"><span class="string">            //当鼠标移动时被拖拽元素跟随鼠标移动 onmousemove  </span></span><br><span class="line"><span class="string">            //获取鼠标的坐标  </span></span><br><span class="line"><span class="string">            var left = event.clientX - ol;  </span></span><br><span class="line"><span class="string">            var top = event.clientY - ot;  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">            //修改box1的位置  </span></span><br><span class="line"><span class="string">            obj.style.left = left+"</span>px<span class="string">";  </span></span><br><span class="line"><span class="string">            obj.style.top = top+"</span>px<span class="string">";  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">        &#125;;  </span></span><br><span class="line"><span class="string">        //为document绑定一个鼠标松开事件  </span></span><br><span class="line"><span class="string">        document.onmouseup = function()&#123;  </span></span><br><span class="line"><span class="string">            //当鼠标松开时，被拖拽元素固定在当前位置onmouseup  </span></span><br><span class="line"><span class="string">            //取消document的onmousemove事件  </span></span><br><span class="line"><span class="string">            document.onmousemove = null;  </span></span><br><span class="line"><span class="string">            //取消document的onmouseup事件  </span></span><br><span class="line"><span class="string">            document.onmouseup = null;  </span></span><br><span class="line"><span class="string">            //当鼠标松开时，取消对事件的捕获  </span></span><br><span class="line"><span class="string">            obj.releaseCapture &amp;&amp; obj.releaseCapture();  </span></span><br><span class="line"><span class="string">        &#125;;  </span></span><br><span class="line"><span class="string"> /*  </span></span><br><span class="line"><span class="string">* 当我们拖拽一个网页中的内容时，浏览器会默认去搜索引擎中搜索内容，  </span></span><br><span class="line"><span class="string">* 此时会导致拖拽功能的异常，这个是浏览器提供的默认行为，  </span></span><br><span class="line"><span class="string">* 如果不希望发生这个行为，则可以通过return false来取消默认行为  </span></span><br><span class="line"><span class="string">*   </span></span><br><span class="line"><span class="string">* 但是这招对IE8不起作用  </span></span><br><span class="line"><span class="string">*/  </span></span><br><span class="line"><span class="string">        return false;  </span></span><br><span class="line"><span class="string">    &#125;;  </span></span><br><span class="line"><span class="string">&#125;  </span></span><br><span class="line"><span class="string">&lt;/script&gt;  </span></span><br><span class="line"><span class="string">&lt;/head&gt;  </span></span><br><span class="line"><span class="string">&lt;body&gt;   </span></span><br><span class="line"><span class="string">我是一段文字   </span></span><br><span class="line"><span class="string">&lt;div id="</span>box1<span class="string">"&gt;&lt;/div&gt;  </span></span><br><span class="line"><span class="string">&lt;div id="</span>box2<span class="string">"&gt;&lt;/div&gt;  </span></span><br><span class="line"><span class="string">&lt;/body&gt;  </span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>滚轮事件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;  </span><br><span class="line">    &lt;html&gt;  </span><br><span class="line">    &lt;head&gt;  </span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;  </span><br><span class="line">        &lt;title&gt;&lt;<span class="regexp">/title&gt;  </span></span><br><span class="line"><span class="regexp">&lt;style type="text/</span>css<span class="string">"&gt;  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">    #box1&#123;  </span></span><br><span class="line"><span class="string">width: 100px;  </span></span><br><span class="line"><span class="string">height: 100px;  </span></span><br><span class="line"><span class="string">background-color: red;  </span></span><br><span class="line"><span class="string">&#125;  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">    &lt;/style&gt;  </span></span><br><span class="line"><span class="string">&lt;script type="</span>text/javascript<span class="string">"&gt;  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">    window.onload = function()&#123;  </span></span><br><span class="line"><span class="string">    //获取id为box1的div  </span></span><br><span class="line"><span class="string">    var box1 = document.getElementById("</span>box1<span class="string">");  </span></span><br><span class="line"><span class="string">    //为box1绑定一个鼠标滚轮滚动的事件  </span></span><br><span class="line"><span class="string">    /*  </span></span><br><span class="line"><span class="string"> * onmousewheel鼠标滚轮滚动的事件，会在滚轮滚动时触发，  </span></span><br><span class="line"><span class="string"> * 但是火狐不支持该属性  </span></span><br><span class="line"><span class="string"> *   </span></span><br><span class="line"><span class="string"> * 在火狐中需要使用 DOMMouseScroll 来绑定滚动事件  </span></span><br><span class="line"><span class="string"> * 注意该事件需要通过addEventListener()函数来绑定  </span></span><br><span class="line"><span class="string"> */  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">    box1.onmousewheel = function(event)&#123;  </span></span><br><span class="line"><span class="string">        event = event || window.event;  </span></span><br><span class="line"><span class="string">        //event.wheelDelta 可以获取鼠标滚轮滚动的方向  </span></span><br><span class="line"><span class="string">        //向上滚 120   向下滚 -120  </span></span><br><span class="line"><span class="string">        //wheelDelta这个值我们不看大小，只看正负  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">        //alert(event.wheelDelta);  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">        //wheelDelta这个属性火狐中不支持  </span></span><br><span class="line"><span class="string">        //在火狐中使用event.detail来获取滚动的方向  </span></span><br><span class="line"><span class="string">        //向上滚 -3  向下滚 3  </span></span><br><span class="line"><span class="string">        //alert(event.detail);  </span></span><br><span class="line"><span class="string">        /*  </span></span><br><span class="line"><span class="string"> * 当鼠标滚轮向下滚动时，box1变长  </span></span><br><span class="line"><span class="string"> * 当滚轮向上滚动时，box1变短  </span></span><br><span class="line"><span class="string"> */  </span></span><br><span class="line"><span class="string">        //判断鼠标滚轮滚动的方向  </span></span><br><span class="line"><span class="string">        if(event.wheelDelta &gt; 0 || event.detail &lt; 0)&#123;  </span></span><br><span class="line"><span class="string">            //向上滚，box1变短  </span></span><br><span class="line"><span class="string">            box1.style.height = box1.clientHeight - 10 + "</span>px<span class="string">";  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">        &#125;else&#123;  </span></span><br><span class="line"><span class="string">            //向下滚，box1变长  </span></span><br><span class="line"><span class="string">            box1.style.height = box1.clientHeight + 10 + "</span>px<span class="string">";  </span></span><br><span class="line"><span class="string">        &#125;  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">        /*  </span></span><br><span class="line"><span class="string"> * 使用addEventListener()方法绑定响应函数，取消默认行为时不能使用return false  </span></span><br><span class="line"><span class="string"> * 需要使用event来取消默认行为event.preventDefault();  </span></span><br><span class="line"><span class="string"> * 但是IE8不支持event.preventDefault();这个玩意，如果直接调用会报错  </span></span><br><span class="line"><span class="string"> */  </span></span><br><span class="line"><span class="string">        event.preventDefault &amp;&amp; event.preventDefault();  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        /*  </span></span><br><span class="line"><span class="string"> * 当滚轮滚动时，如果浏览器有滚动条，滚动条会随之滚动，  </span></span><br><span class="line"><span class="string"> * 这是浏览器的默认行为，如果不希望发生，则可以取消默认行为  </span></span><br><span class="line"><span class="string"> */  </span></span><br><span class="line"><span class="string">        return false;  </span></span><br><span class="line"><span class="string">    &#125;;  </span></span><br><span class="line"><span class="string">    //为火狐绑定滚轮事件  </span></span><br><span class="line"><span class="string">    bind(box1,"</span>DOMMouseScroll<span class="string">",box1.onmousewheel);  </span></span><br><span class="line"><span class="string">&#125;;  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">function bind(obj , eventStr , callback)&#123;  </span></span><br><span class="line"><span class="string">    if(obj.addEventListener)&#123;  </span></span><br><span class="line"><span class="string">        //大部分浏览器兼容的方式  </span></span><br><span class="line"><span class="string">        obj.addEventListener(eventStr , callback , false);  </span></span><br><span class="line"><span class="string">    &#125;else&#123;  </span></span><br><span class="line"><span class="string">        /*  </span></span><br><span class="line"><span class="string"> * this是谁由调用方式决定  </span></span><br><span class="line"><span class="string"> * callback.call(obj)  </span></span><br><span class="line"><span class="string"> */  </span></span><br><span class="line"><span class="string">        //IE8及以下  </span></span><br><span class="line"><span class="string">        obj.attachEvent("</span>on<span class="string">"+eventStr , function()&#123;  </span></span><br><span class="line"><span class="string">            //在匿名函数中调用回调函数  </span></span><br><span class="line"><span class="string">            callback.call(obj);  </span></span><br><span class="line"><span class="string">        &#125;);  </span></span><br><span class="line"><span class="string">    &#125;  </span></span><br><span class="line"><span class="string">&#125;  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">&lt;/script&gt;  </span></span><br><span class="line"><span class="string">&lt;/head&gt;  </span></span><br><span class="line"><span class="string">&lt;body style="</span>height: <span class="number">2000</span>px;<span class="string">"&gt;   </span></span><br><span class="line"><span class="string">    &lt;div id="</span>box1<span class="string">"&gt;&lt;/div&gt;  </span></span><br><span class="line"><span class="string">&lt;/body&gt;  </span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>键盘事件</p></li></ul><ol><li>onkeydown<ul><li>按键被按下</li><li>对于onkeydown来说如果一直按着某个按键不松手，则事件会一直触发</li><li>当onkeydown连续触发时，第一次和第二次之间会间隔稍微长一点，其他的会非常的快，这种设计是为了防止误操作的发生</li></ul></li><li>onkeyup<ul><li>按键被松开</li><li>键盘事件一般都会绑定给一些可以获取到焦点的对象或者是document</li></ul></li><li>keyCode<ul><li>可以通过keyCode来获取按键的编码通过它可以判断哪个按键被按下</li><li>除了keyCode，事件对象中还提供了几个属性<ul><li>altKey</li><li>ctrlKey</li><li>shiftKey</li><li>这个三个用来判断alt ctrl 和 shift是否被按下，如果按下则返回true，否则返回false<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断一个y是否被按下  </span></span><br><span class="line"><span class="comment">//判断y和ctrl是否同时被按下  </span></span><br><span class="line"><span class="keyword">if</span>(event.keyCode === <span class="number">89</span> &amp;&amp; event.ctrlKey)&#123;  </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"ctrl和y都被按下了"</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使文本框中不能输入数字  </span></span><br><span class="line">input.onkeydown = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;  </span><br><span class="line">    event = event || <span class="built_in">window</span>.event;  </span><br><span class="line">    <span class="comment">//数字 48 - 57  </span></span><br><span class="line">    <span class="keyword">if</span>(event.keyCode &gt;= <span class="number">48</span> &amp;&amp; event.keyCode &lt;= <span class="number">57</span>) &#123;  </span><br><span class="line">        <span class="comment">//在文本框中输入内容，属于onkeydown的默认行为  </span></span><br><span class="line">        <span class="comment">//如果在onkeydown中取消了默认行为，则输入的内容，不会出现在文本框中  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><ul><li>浏览器对象模型(browser object model)</li><li>BOM可以使我们通过JS来操作浏览器</li><li>在BOM中为我们提供了一组对象，用来完成对浏览器的操作<h2 id="BOM对象"><a href="#BOM对象" class="headerlink" title="BOM对象"></a>BOM对象</h2></li><li>Window<ul><li>代表的是整个浏览器的窗口，同时window也是网页中的全局对象</li></ul></li><li>Navigator<ul><li>代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器</li></ul></li><li>Location<ul><li>代表当前浏览器的地址栏信息，通过Location可以获取地址栏信息，或者操作浏览器跳转页面</li></ul></li><li>History<ul><li>代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录<br>由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页，而且该操作只在当次访问时有效</li></ul></li><li>Screen<ul><li>代表用户的屏幕的信息，通过该对象可以获取到用户的显示器的相关的信息</li></ul></li><li>这些BOM对象在浏览器中都是作为window对象的属性保存的，可以通过window对象来使用，也可以直接使用</li></ul><h2 id="Navigator"><a href="#Navigator" class="headerlink" title="Navigator"></a>Navigator</h2><ul><li>代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器</li><li>由于历史原因，Navigator对象中的大部分属性都已经不能帮助我们识别浏览器了，一般我们只会使用userAgent来判断浏览器的信息，</li><li>userAgent是一个字符串，这个字符串中包含有用来描述浏览器信息的内容，不同的浏览器会有不同的userAgent</li></ul><table><thead><tr><th>浏览器</th><th>userAgent</th></tr></thead><tbody><tr><td>火狐</td><td>Mozilla5.0 (Windows NT 6.1; WOW64; rv:50.0) Gecko20100101 <strong>Firefox50.0</strong></td></tr><tr><td>Chrome</td><td>Mozilla5.0 (Windows NT 6.1; Win64; x64) AppleWebKit537.36 (KHTML, like Gecko) <strong>Chrome52.0.2743.82</strong> Safari537.36</td></tr><tr><td>IE8</td><td>Mozilla4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)</td></tr><tr><td>IE9</td><td>Mozilla5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)</td></tr><tr><td>IE10</td><td>Mozilla5.0 (compatible; MSIE 10.0; Windows NT 6.1; WOW64; Trident7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)</td></tr><tr><td>IE11</td><td>Mozilla5.0 (Windows NT 6.1; WOW64; Trident7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; rv:11.0) like Gecko</td></tr><tr><td>* 在IE11中已经将微软和IE相关的标识都已经去除了，所以我们基本已经不能通过UserAgent来识别一个浏览器是否是IE了</td><td></td></tr><tr><td><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过userAgent判断浏览器类型</span></span><br><span class="line"></span><br><span class="line">alert(navigator.appName);   </span><br><span class="line"><span class="keyword">var</span> ua = navigator.userAgent;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(firefoxi.test(ua))&#123;  </span><br><span class="line">alert(<span class="string">"你是火狐！！！"</span>);  </span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(chromei.test(ua))&#123;  </span><br><span class="line">alert(<span class="string">"你是Chrome"</span>);  </span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(msiei.test(ua))&#123;  </span><br><span class="line">alert(<span class="string">"你是IE浏览器~~~"</span>);  </span><br><span class="line"><span class="comment">//通过userAgent不能判断浏览器类型时，还可以通过一些浏览器特有的对象来判断浏览器信息，比如：ActiveXObject</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"ActiveXObject"</span> <span class="keyword">in</span> <span class="built_in">window</span>)&#123;  </span><br><span class="line">alert(<span class="string">"你是IE11，枪毙了你~~~"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td></td></tr></tbody></table><h2 id="History"><a href="#History" class="headerlink" title="History"></a>History</h2><ul><li>对象可以用来操作浏览器向前或向后翻页</li><li>length<ul><li>可以获取到当次访问的链接数量</li></ul></li><li>back()<ul><li>可以用来回退到上一个页面，作用和浏览器的回退按钮一样</li></ul></li><li>forward()<ul><li>可以跳转下一个页面，作用和浏览器的前进按钮一样</li></ul></li><li>go()<ul><li>可以用来跳转到指定的页面</li><li>它需要一个整数作为参数<ul><li>1:表示向前跳转一个页面 相当于forward()</li><li>2:表示向前跳转两个页面</li><li>-1:表示向后跳转一个页面</li><li>-2:表示向后跳转两个页面</li></ul></li></ul></li></ul><h2 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h2><ul><li>该对象中封装了浏览器的地址栏的信息</li><li>如果直接打印location，则可以获取到地址栏的信息（当前页面的完整路径）</li><li>alert(location);<ul><li>如果直接将location属性修改为一个完整的路径或相对路径，则我们页面会自动跳转到该路径，并且会生成相应的历史记录<ul><li>location = “http:<a href="http://www.baidu.com&quot;" target="_blank" rel="noopener">www.baidu.com&quot;</a>;</li><li>location = “01.BOM.html”;</li></ul></li></ul></li><li>assign()<ul><li>用来跳转到其他的页面，作用和直接修改location一样</li></ul></li><li>reload()<ul><li>用于重新加载当前页面，作用和刷新按钮一样</li><li>如果在方法中传递一个true，作为参数，则会强制清空缓存刷新页面<br>location.reload(true);</li></ul></li><li>replace()<ul><li>可以使用一个新的页面替换当前页面，调用完毕也会跳转页面<br>不会生成历史记录，不能使用回退按钮回退</li></ul></li></ul><h2 id="window"><a href="#window" class="headerlink" title="window"></a>window</h2><ul><li><p>定时调用</p></li><li><p>setInterval()</p><ul><li>可以将一个函数，每隔一段时间执行一次</li><li>参数：<ul><li>1.回调函数，该函数会每隔一段时间被调用一次</li><li>2.每次调用间隔的时间，单位是毫秒</li></ul></li><li>返回值：<ul><li>返回一个Number类型的数据</li><li>这个数字用来作为定时器的唯一标识</li></ul></li></ul></li><li><p>clearInterval()</p><ul><li>可以用来关闭一个定时器</li><li>方法中需要一个定时器的标识作为参数，这样将关闭标识对应的定时器</li><li>clearInterval()可以接收任意参数，如果参数是一个有效的定时器的标识，则停止对应的定时器,如果参数不是一个有效的标识，则什么也不做<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">1</span>;  </span><br><span class="line"><span class="keyword">var</span> timer = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">count.innerHTML = num++;  </span><br><span class="line"><span class="keyword">if</span>(num == <span class="number">11</span>) &#123;  </span><br><span class="line"><span class="comment">//关闭定时器  </span></span><br><span class="line">clearInterval(timer);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>延时调用</p></li><li><p>setTimeout</p><ul><li>参数：<ul><li>1.回调函数，该函数会在一段时间后被调用一次</li><li>2.每次调用的时间，单位是毫秒</li></ul></li><li>延时调用一个函数不马上执行，而是隔一段时间以后在执行，而且只会执行一次</li><li>延时调用和定时调用的区别，定时调用会执行多次，而延时调用只会执行一次，延时调用和定时调用实际上是可以互相代替的，在开发中可以根据自己需要去选择</li><li>使用clearTimeout()来关闭一个延时调用clearTimeout(timer);</li></ul></li></ul><h1 id="类的操作"><a href="#类的操作" class="headerlink" title="类的操作"></a>类的操作</h1><h2 id="直接修改元素的类css"><a href="#直接修改元素的类css" class="headerlink" title="直接修改元素的类css"></a>直接修改元素的类css</h2><ul><li>通过style属性来修改元素的样式，每修改一个样式，浏览器就需要重新渲染一次页面，这样的执行的性能是比较差的，而且这种形式当我们要修改多个样式时，也不太方便 我希望一行代码，可以同时修改多个样式，<strong>我们可以通过修改元素的class属性来间接的修改样式</strong>，这样一来，我们只需要修改一次，即可同时修改多个样式，浏览器只需要重新渲染页面一次，性能比较好，并且这种方式，可以使表现和行为进一步的分离</li></ul><h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><blockquote><p>JavaScript Object Notation JS对象表示法</p></blockquote><h2 id="JSON-格式"><a href="#JSON-格式" class="headerlink" title="JSON 格式"></a>JSON 格式</h2><ul><li>复合类型的值只能是数组或对象，<strong>不能是函数</strong>、正则表达式对象、日期对象</li><li>原始类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和null（不能使用NaN, Infinity, -Infinity和undefined）</li><li>字符串必须使用双引号表示，不能使用单引号。</li><li>对象的键名必须放在双引号里面。</li><li>数组或对象最后一个成员的后面，不能加逗号。</li><li>JS中的对象只有JS自己认识，其他的语言都不认识</li><li>JSON就是一个特殊格式的字符串，这个字符串可以被任意的语言所识别，并且可以转换为任意语言中的对象，JSON在开发中主要用来数据的交互</li><li>JSON和JS对象的格式一样，只不过JSON字符串中的属性名必须加双引号,其他的和JS语法一致</li></ul><h2 id="JSON分类："><a href="#JSON分类：" class="headerlink" title="JSON分类："></a>JSON分类：</h2><ol><li>对象 {}</li><li>数组 []</li></ol><h2 id="JSON中允许的值："><a href="#JSON中允许的值：" class="headerlink" title="JSON中允许的值："></a>JSON中允许的值：</h2><ol><li>字符串</li><li>数值</li><li>布尔值</li><li>null</li><li>对象</li><li>数组<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = <span class="string">'[1,2,3,"hello",true]'</span>;  </span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="string">'&#123;"arr":[1,2,3]&#125;'</span>;    </span><br><span class="line"><span class="keyword">var</span> arr2 =<span class="string">'[&#123;"name":"孙悟空","age":18,"gender":"男"&#125;,&#123;"name":"孙悟空","age":18,"gender":"男"&#125;]'</span>;</span><br></pre></td></tr></table></figure><h2 id="JSON工具类"><a href="#JSON工具类" class="headerlink" title="JSON工具类"></a>JSON工具类</h2></li></ol><ul><li><strong>JSON -&gt; JS对象</strong></li><li>JSON.parse()<ul><li>可以将以JSON字符串转换为js对象</li><li>它需要一个JSON字符串作为参数，会将该字符串转换为JS对象并返回<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="built_in">JSON</span>.parse(json);</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">JSON</span>.parse(arr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj3 = &#123;<span class="attr">name</span>:”猪八戒” , <span class="attr">age</span>:<span class="number">28</span> , <span class="attr">gender</span>:”男”&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>JS对象 -&gt; JSON</strong></li><li>JSON.stringify()<ul><li>可以将一个JS对象转换为JSON字符串</li><li>需要一个js对象作为参数，会返回一个JSON字符串<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="built_in">JSON</span>.stringify(obj3);</span><br></pre></td></tr></table></figure></li></ul></li><li>JSON这个对象在IE7及以下的浏览器中不支持，所以在这些浏览器中调用时会报错</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>eval()<ul><li>这个函数可以用来执行一段字符串形式的JS代码，并将执行结果返回</li><li>如果使用eval()执行的字符串中含有{},它会将{}当成是代码块</li><li>如果不希望将其当成代码块解析，则需要在字符串前后各加一个()</li><li>eval()这个函数的功能很强大，可以直接执行一个字符串中的js代码，但是在开发中尽量不要使用，首先它的执行性能比较差，然后它还具有安全隐患<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'&#123;"name":"孙悟空","age":18,"gender":"男"&#125;'</span>;  </span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">eval</span>(<span class="string">"("</span>+str+<span class="string">")"</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li>confirm()<ul><li>用于弹出一个带有确认和取消按钮的提示框，和alert一样，但是他有两个按钮</li><li>需要一个字符串作为参数，该字符串将会作为提示文字显示出来</li><li>如果用户点击确认则会返回true，如果点击取消则返回false</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;序&lt;br&gt;&lt;br&gt;终于开始学前端的核心内容了！学好JS才能为后面的jQuery( JavaScript 库)和JS框架(React,Vue,Angular)打好基础，冲冲冲！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="前端三大块" scheme="http://xyx6.top/categories/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%A4%A7%E5%9D%97/"/>
    
    
      <category term="JavaScript" scheme="http://xyx6.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>HTMLCSS基础</title>
    <link href="http://xyx6.top/2020/07/04/htmlcss/"/>
    <id>http://xyx6.top/2020/07/04/htmlcss/</id>
    <published>2020-07-04T10:22:07.000Z</published>
    <updated>2020-07-10T13:45:36.251Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>序<br><br>最近时间空闲比较多，想起来还没有系统的学习过html,css和js，刚好趁着最近复习巩固一下这块的知识，把自己学习的东西记录下来。let’s do it!</p></blockquote><a id="more"></a><h1 id="html"><a href="#html" class="headerlink" title="html"></a>html</h1><blockquote><p>div是块元素，他会独占一整行，无论他的内容有多少，主要用来页面布局。而像span,a,img,iframe这种的内联元素（行内元素）只占自身大小，不会占用一整行。<strong>块元素主要用来做页面的布局，内联元素用来选中文本设置样式</strong></p></blockquote><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><ol><li>无序列表<ul><li>使用ul标签来创建一个无序列表</li><li>使用li在ul中创建一个一个的列表项</li><li>通过type属性修改列表中的项目符号，也可以在css中用list-style:none来去掉项目符号</li></ul></li><li>有序列表<ul><li>有序列表和无序列表相似，只不过他用ol来代替ul</li></ul></li><li>定义列表<ul><li>使用dl来创建一个定义列表</li><li>dt: 被定义的内容</li><li>dd: 对定义内容的表述</li></ul></li></ol><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><ul><li>html中用table标签来创建单元格</li><li>table标签中用tr表示行，tr中用td表示列来创建单元格</li><li>colspan设置横向合并单元格，rowspan设置纵向合并单元格</li><li>table和td边框之间的默认距离可以用border-spacing：0或者是border-collapse：collapse来消除</li></ul><h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><ul><li>form标签中必须指定一个action属性，该属性指向一个服务器地址，当我们提交表单时将会提交到action属性对应的地址，在form中添加不同的表单项</li></ul><h2 id="框架集"><a href="#框架集" class="headerlink" title="框架集"></a>框架集</h2><ul><li>使用frameset来创建一个框架集，注意frameset和body不能出现在一个页面中</li><li>框架集和内敛框架的作用相似，都是引用外部页面，但是框架集可以同时引用多个，而内联框架只能引入一个</li><li>框架集中的框架：rows按行排列/cols按列排列</li><li>frameset中可以再嵌套frameset</li><li>frameset和iframe一样，他里面的内容都不会被搜索引擎所检索</li><li>使用frameset就意味着页面中不能有自己的内容，只能引入其他的页面，而我们所加载的每一个页面浏览器都需要重新发送一次请求，用户体验差</li></ul><h2 id="hack"><a href="#hack" class="headerlink" title="hack"></a>hack</h2><blockquote><p>hack其实时一个特殊的代码，这段代码只有在某些浏览器可以识别，而其他浏览器不能识别，通过这种方式，来为一些浏览器设置特殊代码</p></blockquote><ul><li><p>条件hack</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--if&lt;keywords&gt;?IE&lt;version&gt;?&gt;</span></span><br><span class="line"><span class="comment">html代码块</span></span><br><span class="line"><span class="comment">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>属性hack</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selector&#123;<span class="tag">&lt;<span class="name">hack</span>&gt;</span>?property:value<span class="tag">&lt;<span class="name">hack</span>&gt;</span>?;&#125;</span><br></pre></td></tr></table></figure></li></ul><p><a href="https://www.w3school.com.cn/html/index.asp" target="_blank" rel="noopener">html详细教程</a><br><br></p><h1 id="css"><a href="#css" class="headerlink" title="css"></a>css</h1><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><ol><li>元素选择器<ul><li>可以直接使用标签名做元素选择器</li></ul></li><li>id选择器<ul><li>【id=”p1”】-&gt;【#p1】</li></ul></li><li>class选择器<ul><li>【class=”p1”】-&gt;【.p1】</li><li><strong>class属性和id属性相似，只不过class属性可以重复拥有相同的class属性值元素，我们称它为一组元素</strong></li></ul></li><li>伪类选择器<blockquote><p>伪类专门用来表示元素的一种特殊的状态，当我们需要为处在特殊状态的元素设置样式时，就可以用伪类</p></blockquote><ul><li>a.link    没访问过的链接样式</li><li>a.visited 访问过的链接样式</li><li>a.hover   鼠标移入的状态</li><li>a.active  链接被点击的状态</li><li>a.focus 获取焦点的状态</li></ul></li><li>属性选择器<ul><li>可以根据元素的属性或属性值来选取制定的元素。</li><li><strong>选择器优先级：内联样式&gt;id选择器，class选择器&gt;伪类选择器&gt;元素选择器</strong></li></ul></li></ol><h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><ol><li>可以用英文单词表示</li><li>可以用rgb(xxx,xxx,xxx)表示，取自于红绿蓝三原色按照各自的浓度来配色，可以用截图工具取色</li><li>可以用rgb的十六进制表示 #000000，两位表示一个颜色</li></ol><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><ol><li>font-size设置大小</li><li>font-family设置字体</li><li>font-style设置斜体</li><li>font-weight设置加粗效果</li><li>font-variant设置大小写</li></ol><h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><blockquote><p>width和height只是设置内容区的大小，而不是盒子的大小<br><br>盒子的大小由内容区，内边距，边框共同决定</p></blockquote><ol><li>border边框<ul><li>border-width:边框的宽度</li><li>border-color:边框的颜色</li><li>边框的宽度和颜色可以设置四个值，分别代表边框上右下左(顺时针)的属性</li><li>border-style:边框的样式</li><li>简写形式border：颜色 样式 宽度</li></ul></li><li>padding内边框<ul><li>内边距会影响盒子可见框的大小</li><li>padding-top/right/bottom/left</li></ul></li><li>margin外边距<ul><li>外边距指的是当前盒子和其他盒子之间的距离</li><li>margin-top/right/bottom/left:正负表示相反方向</li></ul></li><li>垂直外边距的重叠<ul><li>在网页中垂直方向的相邻外边距会发生外边距的重叠</li><li>外边距重叠指兄弟元素之间的相邻外边距会取最大值而不是求和</li><li>如果父子元素的垂直外边距相邻了，则子元素的外边距会设置给父元素</li><li>解决方法：可以通过在父子元素中间加元素来隔开他们，使他们不在相邻；也可以通过设置父元素的内边距来实现</li></ul></li><li>内联元素可以设置内边距和边框，水平方向影响布局，垂直方向不影响布局；还可以设置外边距，水平方向相邻外边距是求和的，但不支持垂直方向的外边距</li></ol><p><img src="/2020/07/04/htmlcss/htmlcss.jpg" alt></p><h2 id="display"><a href="#display" class="headerlink" title="display"></a>display</h2><blockquote><p>display可以将行内元素变成块元素，可以用来改变行内元素的宽高</p></blockquote><ol><li>display：inline 可以将一个元素作为内联元素显示</li><li>display：block  可以将一个元素设置为块元素</li><li>display：inline-block 将一个行内元素转换为块元素，可以使一个元素既可以设置宽高，又不会独占一行（既有行内元素的特点又有块元素的特点）<ul><li>如果想要元素消失后位置保留，可以用visibility：hidden</li></ul></li><li>display：none 不显示元素，并且元素不会再页面中继续占有位置</li></ol><h2 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h2><blockquote><p>文档流处在网页的底层，他表示的是一个页面中的位置，我们所创建的元素默认都处在文档流中</p></blockquote><ol><li>块元素在文档流中的特点<ul><li>块元素在文档流中会独占一行，快元素会自上向下排列</li><li>块元素在文档流中默认宽度是父元素的100%</li><li>块元素在文档流中的高度默认被内容撑开</li></ul></li><li>内联元素在文档流中的特点<ul><li>如果一行中不足以容纳所有的内联元素，则换到下一行，继续从左向右</li></ul></li><li>当元素的宽度的值为auto时，此时会指定内边距不影响可见框的大小，而是会自动修改宽度来适应内边距</li></ol><h2 id="float"><a href="#float" class="headerlink" title="float"></a>float</h2><blockquote><p>使用float来使元素浮动，从而脱离文档流</p></blockquote><ol><li>none：默认值，元素默认在文档流中排列</li><li>left：元素立即脱离文档流，向页面的左侧浮动</li><li>right：元素立即脱离文档流，向页面的右侧浮动</li></ol><ul><li>元素脱离文档流后，它下面的元素立即向上移动，元素浮动以后，会尽量向页面的左上或者是右上移动，直到遇到父元素的边框或者是其他浮动元素</li><li>如果浮动元素的上边是一个没有浮动的块元素，则浮动元素不会超过块元素</li><li>浮动元素不会超过他上边的兄弟元素，最多和他上面的兄弟元素并列</li><li>浮动元素不会覆盖文字，文字会自动环绕在元素的周围</li><li>块元素脱离文档流后，高度和宽度都被内容撑开</li><li>内联元素脱离文档流后，就变成了块元素，高度和宽度都被内容撑开</li><li><strong>一旦脱离文档流后，内联元素和块元素全都是块元素，不做区分</strong><blockquote><p>clear可以用来清除浮动</p></blockquote></li></ul><ol><li>none：默认值，不清除浮动</li><li>left: 清除左侧浮动元素对当前元素的影响</li><li>right：清除右侧浮动元素对当前元素的影响</li><li>both：清除两侧浮动元素对当前元素的影响</li></ol><h2 id="高度塌陷问题"><a href="#高度塌陷问题" class="headerlink" title="高度塌陷问题"></a>高度塌陷问题</h2><blockquote><p>在文档流中，父元素的高度默认是被子元素撑开的，也就是子元素多高，父元素就多高，但是当子元素设置浮动以后，子元素脱离文档流，此时将会导致子元素无法撑起父元素的高度，导致父元素的高度塌陷。由于父元素的高度塌陷了，则父元素下的所有元素都会向上移动，导致页面布局混乱。</p></blockquote><ul><li>解决方法：<ol><li>我们可以将父元素的高度写死，来避免塌陷，但是我们一旦将高度写死，父元素就不能自适应子元素的高度，所以这种方法不推荐</li><li>在页面中的元素都有一个隐含的属性叫block formatting contex，简称bfc，该属性可以设置打开或者关闭，默认是关闭的<ul><li>开启bfc后，元素具有以下特征：<ol><li>父元素的垂直外边距不会和子元素重叠</li><li>开启bfc的元素不会被浮动元素所覆盖</li><li>开启bfc的元素可以包括浮动的子元素</li></ol></li><li>如何开启元素的bfc<ol><li>设置元素浮动<ul><li>使用这种方式开启，虽然可以撑开父元素，但是会导致父元素的宽度丢失，而且使用这种方式也会导致下边的元素上移，不能解决问题，不推荐</li></ul></li><li>设置元素绝对定位<ul><li>效果同1，不推荐</li></ul></li><li>设置元素为inline-block<ul><li>可以解决问题，但是会导致宽度丢失，不推荐</li></ul></li><li>将元素的overflow设置为一个非visible的值<ul><li><strong>推荐方式：将overflow设置为hidden是副作用最小的开启bfc的方式</strong></li></ul></li></ol></li></ul></li><li>但是在IE6及以下版本不支持bfc，所以在IE6中我们通过开haslayout来解决问题，开启方式：直接将元素的zoom设置为1</li><li>还可以在高度塌陷的父元素的最后，添加一个空白的div，由于这个div没有浮动，所以他是可以撑开父元素的高度的，然后对其进行清除浮动，这样就可以通过空白的div来撑开父元素，基本没有副作用，但是会产生一个多余的div结构，所以我们还可以用div的after伪类在元素的最后添加一个空白的块元素来实现同样的效果</li><li>clearfix<blockquote><p>既可以解决高度塌陷,又可以确保父元素和子元素的垂直外边距不会重叠</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.clearfix:before,</span><br><span class="line">.clearfix:after&#123;</span><br><span class="line">   content:"";</span><br><span class="line">   display:table;</span><br><span class="line">   clear:both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><blockquote><p>定位就是将指定的定位摆放到页面的任意位置</p></blockquote><ol><li>相对定位(position：relative)<ul><li>当开启了元素的相对定位以后，而不设置偏移量时，元素不会发生变化</li><li>当元素开启定位后，可以通过left，right，top，bottom来设置元素相对于其定位位置的偏移量</li><li>相对定位是相对于元素在文档流中的位置进行定位</li><li>相对定位的元素不会脱离文档流</li><li>相对定位会使元素提升一个层级(覆盖低层级元素)</li><li>相对定位不会改变元素的性质，块还是块，内联还是内联</li></ul></li><li>绝对定位(position：absolute)<ul><li>开启绝对定位后会脱离文档流</li><li>开启绝对定位后，如果不设置偏移量，则元素的位置不发生改变</li><li>绝对定位是相当于离他最近的开启了定位的祖先元素进行定位的，如果所有的祖先元素都没有开启定位，则会相对于浏览器窗口进行定位</li><li>绝对定位也会使元素提升一个层级(覆盖低层级元素)</li><li>绝对定位会改变元素的性质，内联元素变成块元素，块的宽高被内容撑开</li></ul></li><li>固定定位(position：fixed)<ul><li>固定定位也是一种相对定位，他的绝大多数特点和绝对定位一样</li><li>不同的是：固定定位永远都会相对于浏览器窗口进行定位，它永远固定在窗口的某个位置，不会随着滚动条滚动</li></ul></li></ol><h2 id="层级"><a href="#层级" class="headerlink" title="层级"></a>层级</h2><blockquote><p>如果定位元素的层级是一样的，则下边的元素会盖住上边的，还可以通过z-inline属性来设置元素的层级(父元素的层级再高，也不会盖住子元素)，当然没有开启定位的元素不能使用z-inline</p></blockquote><h2 id="透明背景"><a href="#透明背景" class="headerlink" title="透明背景"></a>透明背景</h2><blockquote><p>opacity可以用来设置元素背景的透明,范围：0<del>1(完全透明</del>不透明)</p></blockquote><p><a href="https://www.w3school.com.cn/css/index.asp" target="_blank" rel="noopener">css详细教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;序&lt;br&gt;&lt;br&gt;最近时间空闲比较多，想起来还没有系统的学习过html,css和js，刚好趁着最近复习巩固一下这块的知识，把自己学习的东西记录下来。let’s do it!&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="前端三大块" scheme="http://xyx6.top/categories/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%A4%A7%E5%9D%97/"/>
    
    
      <category term="html css" scheme="http://xyx6.top/tags/html-css/"/>
    
  </entry>
  
  <entry>
    <title>hello world</title>
    <link href="http://xyx6.top/2020/07/02/hello-world/"/>
    <id>http://xyx6.top/2020/07/02/hello-world/</id>
    <published>2020-07-02T04:22:07.000Z</published>
    <updated>2020-07-04T16:49:08.113Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>序<br><br>偶尔有天在B站上刷到一段视频，内容是up主用hexo快速的搭建个人博客，虽然说作为软件专业的学生用这种快速的网站生成器实属有点说不过去，但是俗话说得好：强撸灰飞湮灭，要是真的手撸出来个人网站，一来按我这个渣渣水平都到猴年马月去了，二来就是想在学习的过程中记录下来一些东西来复习，所以出此下策才有了这个网站。</p></blockquote><a id="more"></a><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul><li>Git</li><li>Nginx</li><li>Nodejs</li><li>搭载环境<ol><li>阿里云服务器(学生白嫖服务器，不用白不用，地址：<a href="https://developer.aliyun.com/adc/student/" target="_blank" rel="noopener">https://developer.aliyun.com/adc/student/</a>)</li><li>域名（在万网根据个人喜欢挑选一个心仪的）</li><li>还可以用Github来部署（不需要域名和服务器且免费，不要问我为什么不用，问就是我傲娇，嫌用github后缀名太吃藕）</li></ol></li><li>hexo<ol><li>主角来了，hexo是基于node.js的一款轻量级的博客制作工具。它可以将我们在本地编写的markdown文档转化成html页面，然后我们将html页面上传到服务器上。</li><li>hexo还支持切换主题的功能，在本地下载主题文件，可以通过修改theme配置文件和hexo的配置文件实现网页的个性化。</li></ol></li></ul><p><strong><em>域名和服务器大概是在5月20号左右买的，买完以后就迎来了很多大大小小的考试，到最近一段时间才想起来还有这么茬事，就索性把这件事落实下来，整个过程还算顺利，已经有了大致的雏形，不过还有些小功能有待发掘，日后再一一填补上来。</em></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;序&lt;br&gt;&lt;br&gt;偶尔有天在B站上刷到一段视频，内容是up主用hexo快速的搭建个人博客，虽然说作为软件专业的学生用这种快速的网站生成器实属有点说不过去，但是俗话说得好：强撸灰飞湮灭，要是真的手撸出来个人网站，一来按我这个渣渣水平都到猴年马月去了，二来就是想在学习的过程中记录下来一些东西来复习，所以出此下策才有了这个网站。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="日常" scheme="http://xyx6.top/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="杂记" scheme="http://xyx6.top/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
</feed>
