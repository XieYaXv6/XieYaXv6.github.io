<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XYX&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xyx6.top/"/>
  <updated>2020-07-07T12:52:58.326Z</updated>
  <id>http://xyx6.top/</id>
  
  <author>
    <name>XYX</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>arr</title>
    <link href="http://xyx6.top/2020/07/07/arr/"/>
    <id>http://xyx6.top/2020/07/07/arr/</id>
    <published>2020-07-07T08:00:22.873Z</published>
    <updated>2020-07-07T12:52:58.326Z</updated>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Document</title>    <script>        // var arr=[1,2,2,3,3,4,3,2,5];        // for(var i=0;i<arr.length;i++)        // {                    //     for(var j=i+1;j<arr.length;j++)        //     {        //         if(arr[j]==arr[i]){        //             arr.splice(j,1);        //             j=j-1;        //         }                //     }        // }        // console.log(arr);        var ph="11061400306";        var reg=/^1[3-9][0-9]{9}$/        console.log(reg.test(ph));            </script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="XYX's Blog" type="application/atom+xml"></head><body>    </body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript</title>
    <link href="http://xyx6.top/2020/07/05/JavaScript/"/>
    <id>http://xyx6.top/2020/07/05/JavaScript/</id>
    <published>2020-07-05T11:08:05.000Z</published>
    <updated>2020-07-07T13:36:26.217Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>序<br><br>终于开始学前端的核心内容了！学好JS才能为后面的jQuery( JavaScript 库)和JS框架(React,Vue,Angular)打好基础，冲冲冲！</p></blockquote><a id="more"></a><h1 id="js基本语法"><a href="#js基本语法" class="headerlink" title="js基本语法"></a>js基本语法</h1><h2 id="引入js"><a href="#引入js" class="headerlink" title="引入js"></a>引入js</h2><ul><li><p>可以编写到标签的onclick属性中，也可以写在标签的属性中，但是他们属于行为和结构耦合，不方便维护，不推荐</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"alert('xxx')"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:alert('xxx')"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>可以写在标签或者外部文件中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>js标签一旦引入外部文件了，就不能再编码了，即使编写了浏览器也会忽略；如果需要则可以再创建一个新的script标签用于编写内部代码，执行顺序按从上至下依次执行。</p></li></ul><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><ul><li>在js中所有的可以由我们自主命名的都可以成为标识符</li><li>例如：变量名，函数名，属性名等等</li><li>命名一个标识符需要遵守如下规则：<ol><li>标识符可以包含字母，数字，_，$</li><li>标识符不能以数字开头</li><li>标识符不能是关键字和保留字</li></ol></li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>数据类型</li></ul><p>String，Number，Boolean，Null，Undefined，Object(object不属于基本数据类型)</p><ul><li><p>数组</p><blockquote><p>用方括号书写，数组的项目由逗号分隔。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">下面的代码声明（创建）了名为 cars 的数组，包含三个项目（汽车品牌）：</span><br><span class="line"><span class="keyword">var</span> cars = [<span class="string">"Porsche"</span>, <span class="string">"Volvo"</span>, <span class="string">"BMW"</span>];</span><br></pre></td></tr></table></figure></li><li><p>typeof 运算符</p></li></ul><p>可使用typeof 来确定 JavaScript 变量的类型,typeof 运算符返回变量或表达式的类型</p><ul><li>进制</li></ul><ol><li>表示16进制的数字，需要0x开头</li><li>表示8进制的数字，需要0开头</li><li>表示2进制的数字，需要0b开头</li></ol><ul><li>强制转换<ol><li>将其他数据类型转换为String<ul><li>方法一：调用被转换数据类型的toString()方法</li><li>该方法不影响原变量，他会将转换的结果返回</li><li>但是注意null和undefined这两个值没有toString()方法，会报错</li><li>方法二：调用String()函数，并将被转换的数据作为参数传递给函数</li><li>使用String()函数强制转换时，对于Number和Boolean实际上就是调用toString()方法，但是对于null和undefined就会将他们转换为字符串”null”和”undefined”</li></ul></li><li>将其他数据类型转换为Number<ul><li>方法一：使用Number()函数</li><li>如果字符串中有非数字的内容，则转换为NaN</li><li>如果字符串是空或者是全空格，则转换为0</li><li>方法二：这种方法专用于字符串</li><li>parseInt()把一个字符串转换为一个整数 //将一个字符串中的有效内容的整数内容读取出来转换为Number</li><li>parseFloat()把一个字符串转换为一个浮点数//将一个字符串中的有效内容的小数内容读取出来转换为Number</li><li>可以用一元的+来进行隐式的类型转换</li></ul></li><li>将其他数据类型转换为Boolean<ul><li>使用Boolean()函数<pre><code>* 数字-&gt;布尔(除了0和NaN，其余都是true)* 字符串-&gt;布尔(除了空串，其余都是true)* null和undefined都会转换为false* 对象也会转换为true</code></pre></li></ul></li></ol></li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul><li><p>逻辑运算符</p><ul><li><p>!</p><p>非运算可以对一个布尔值进行取反，true变false false边true<br>当对非布尔值使用!时，会先将其转换为布尔值然后再取反<br>我们可以利用!来将其他的数据类型转换为布尔值</p></li><li><p>&amp;&amp;</p><p>&amp;&amp;可以对符号两侧的值进行与运算<br>只有两端的值都为true时，才会返回true。只要有一个false就会返回false。<br>与是一个短路的与，如果第一个值是false，则不再检查第二个值<br>对于非布尔值，它会将其转换为布尔值然后做运算，并返回原值<br>规则：</p></li></ul><p> 1.如果第一个值为false，则返回第一个值<br> 2.如果第一个值为true，则返回第二个值</p><ul><li><p>||</p><p>||可以对符号两侧的值进行或运算<br>只有两端都是false时，才会返回false。只要有一个true，就会返回true。<br>或是一个短路的或，如果第一个值是true，则不再检查第二个值<br>对于非布尔值，它会将其转换为布尔值然后做运算，并返回原值<br>规则：1. 如果第一个值为true，则返回第一个值2. 如果第一个值为false，则返回第二个值</p></li></ul></li></ul><h2 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h2><ul><li>break关键字可以用来退出switch或循环语句</li><li>不能在if语句中使用break和continue</li><li>break关键字，会立即终止离他最近的那个循环语句</li><li>continue可以跳过当次循环</li></ul><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><blockquote><p>对象属于一种复合的数据类型，在对象中可以保存多个不同数据类型的属性</p></blockquote><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ol><li>内建对象</li></ol><ul><li>由ES标准中定义的对象，在任何的ES的实现中都可以使用</li><li>比如：Math String Number Boolean Function Object…</li></ul><ol start="2"><li>宿主对象</li></ol><ul><li>由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象</li><li>比如：BOM DOM</li></ul><ol start="3"><li>自定义对象</li></ol><ul><li>由开发人员自己创建的对象</li></ul><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><ol><li>方法一<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure></li></ol><ul><li>基本数据类型的数据，变量是直接保存的它的值。</li><li>变量与变量之间是互相独立的，修改一个变量不会影响其他的变量。</li><li>引用数据类型的数据，对象是保存在堆内存中的，每创建一个新对象，就会在堆内存中开辟一个新的空间，而变量保存的是对象的内存地址，如果两个变量保存的是同一个对象引用，当我们通过一个变量修改属性时，另一个也会受到影响</li><li>当两个引用数据类型比较时，比较的是对象的内存地址</li></ul><ol start="2"><li>方法二<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br></pre></td></tr></table></figure></li></ol><ul><li>使用对象字面量可以在创建对象的时候，直接指定对象中的属性</li><li>语法：{属性名：属性值，属性名：属性值，···}//要是属性名过于特殊，则要加引号</li></ul><ol start="3"><li>向对象中添加属性<ul><li>语法：对象.属性名=属性值;</li><li>对象[“属性名”] = 属性值; 这种方式能够使用特殊的属性名</li><li>对象的属性名没有任何要求，不需要遵守标识符的规范，但是在开发中，尽量按照标识符的要求去写。属性值也可以任意的数据类型。</li></ul></li><li>读取对象中的属性<ul><li>语法：对象.属性名</li><li>对象[“属性名”] ;“属性名”可以使字符串常量，也可以是字符串变量</li><li>如果读取一个对象中没有的属性，它不会报错，而是返回一个undefined</li></ul></li><li>修改对象中的属性<ul><li>语法：对象.属性值=新值</li></ul></li><li>删除对象中的属性<ul><li>语法：delete 对象.属性名  <pre><code>delete 对象[&quot;属性名&quot;]</code></pre></li></ul></li></ol><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><blockquote><p>函数也是一个对象，函数主要用来封装一些功能</p></blockquote><ol><li>创建函数<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">函数声明</span><br><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params">形参<span class="number">1</span>,形参<span class="number">2.</span>..形参N</span>)</span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">语句...  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">函数表达式：将要封装的代码以字符串的形式传递给构造函数</span><br><span class="line"><span class="keyword">var</span> 函数名 = <span class="function"><span class="keyword">function</span>(<span class="params">形参<span class="number">1</span>,形参<span class="number">2.</span>..形参N</span>)</span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">语句...  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>立即执行函数<ul><li>函数定义完，立即被调用，这种函数叫做立即执行函数</li><li>立即执行函数往往只会执行一次<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;  </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"a = "</span>+a);  </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"b = "</span>+b);  </span><br><span class="line">&#125;)(<span class="number">123</span>,<span class="number">456</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li>枚举对象中的属性<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> 变量 <span class="keyword">in</span> 对象)&#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><ol><li>全局作用域<ul><li>直接在script标签中编写的代码都运行在全局作用域中 </li><li>全局作用域在页面打开时创建，在页面关闭时销毁</li><li>在全局作用域中有一个全局对象window，他代表的是一个浏览器的窗口，他由浏览器创建时我们可以直接使用</li><li>在全局作用域中创建的变量都会作为window对象的属性保存</li><li>在全局作用域中创建的函数都会作为window对象的方法保存</li><li>在全局作用域中创建的变量和函数可以在页面的任意位置访问</li><li>在函数作用域中也可以访问到全局作用域的变量</li></ul></li><li>函数作用域<ul><li>调用函数时创建函数作用域，函数执行完毕后，函数作用域销毁</li><li>每调用一个函数就会创建一个新的函数作用域，他们之间是相互独立的</li><li>在函数作用域中可以访问到全局作用域的变量</li><li>在全局作用域中无法访问到函数作用域的变量</li><li>当在函数作用域中操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用，如果没有就向上一级的作用域中寻找，直到找到全局作用域，若全局作用域中还没有，则会报错</li></ul></li><li>变量的声明提前<ul><li>在全局作用域中，使用var关键字声明的变量会在所有代码执行前被声明(但是不会被赋值)，但是如果声明变量不使用var关键字，则变量不会被声明提前</li><li>在函数作用域中，也具有同上特性，使用var关键字声明的变量会在函数所有的代码执行前被声明，如果没有使用var关键字声明变量，则变量会变成全局变量</li></ul></li><li>函数的声明提前<ul><li>使用函数声明形式创建的函数function 函数名(){},他会在所有代码执行前被创建，所以我们可以在函数声明前调用函数；使用函数表达式(var fun = function(){})创建的函数没有该特性</li><li>在函数作用域中，使用函数声明创建的函数，会在所有的函数中的代码执行之前就被创建好了</li></ul></li></ol><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><blockquote><p>我们每次调用函数时，解析器都会将一个上下文对象作为隐含的参数传递进函数。<br>使用this来引用上下文对象，根据函数的调用形式不同，this的值也不同。</p></blockquote><ul><li>this的不同的情况：<ol><li>以函数的形式调用时，this是window</li><li>以方法的形式调用时，this就是调用方法的对象</li><li>以构造函数的形式调用时，this就是新创建的对象</li></ol></li></ul><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ul><li>一个构造函数我们也可以称为一个类</li><li>通过一个构造函数创建的对象，我们称该对象时这个构造函数的实例</li><li>可以用 instanceof 用来检查一个对象是否是一个类的实例</li><li>通过同一个构造函数创建的对象，我们称为一类对象</li><li>构造函数就是一个普通的函数，只是他的调用方式不同，如果直接调用，它就是一个普通函数，如果使用new来调用，则它就是一个构造函数</li><li>构造函数的执行流程：<ol><li>创建一个新的对象</li><li>将新建的对象设置为函数中的this，在构造函数中用this来引用新建的对象</li><li>执行函数中的代码</li><li>将新建的对象返回<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name , age , gender</span>)</span>&#123;  </span><br><span class="line"><span class="keyword">this</span>.name = name;  </span><br><span class="line"><span class="keyword">this</span>.age = age;  </span><br><span class="line"><span class="keyword">this</span>.gender = gender;  </span><br><span class="line"><span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">   alert(<span class="keyword">this</span>.name);  </span><br><span class="line">&#125;;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="原型-prototype"><a href="#原型-prototype" class="headerlink" title="原型 prototype"></a>原型 prototype</h2><ul><li>我们所创建的每一个函数，解析器都会像函数中添加一个属性prototype</li><li>prototype属性指向的是一个对象，这个对象我们称为原型对象</li><li>当函数作为构造函数使用，<strong>它所创建的对象中都会有一个隐含的属性执行该原型对象</strong>，并且这个隐含的属性可以通过对象.<strong>proto</strong>来访问</li><li>当我们访问对象的一个属性或者是方法是，他会先在对象自身中寻找，如果有就直接使用；如果没有就回去原型对象中寻找，找到则直接使用</li><li>原型对象就相当于一个公共的区域，凡是通过同一个构造函数创建的对象他们通常都可以访问到相同的原型对象</li><li>举例：<br><img src="/2020/07/05/JavaScript/js%E5%8E%9F%E5%9E%8B.png" alt></li><li><strong>作用：如果将构造函数中的函数定义在全局作用域中，污染了全局作用域的命名空间，而且定义在全局作用域中很不安全，所以我们可以将对象共有的属性和方法放在原型对象中，这样既不用分别为每一个对象添加，也不会影响全局作用域，就可以使每个对啊ing都具有这些属性和方法了</strong></li><li>hasOwnProperty()<pre><code>&gt;这个方法可以用来检查对象自身中是否含有某个属性&gt;&gt;语法：对象.hasOwnProperty(“属性名”)</code></pre></li><li>原型也是对象，所以他也有原型<blockquote><p>当我们使用一个对象或方法时，会先在自身中寻找，自身要是有就直接使用</p><blockquote><p>如果自身没有就去原型对象中寻找，如果有就直接使用</p><blockquote><p>如果原型对象中还没有，就去原型的原型中去寻找，直到找到object对象（object没有以原型），如果还没找到就返回undefined<br> <img src="/2020/07/05/JavaScript/%E5%8E%9F%E5%9E%8B%E7%9A%84%E5%8E%9F%E5%9E%8B.png" alt> </p></blockquote></blockquote></blockquote></li></ul><h2 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h2><ul><li>当我们直接在页面中打印一个对象时，事实上是输出的对象的toString()方法的返回值<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改Person原型的toString方法的返回值  </span></span><br><span class="line">   Person.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="string">"Person[name="</span>+<span class="keyword">this</span>.name+<span class="string">",age="</span>+<span class="keyword">this</span>.age+<span class="string">",gender="</span>+<span class="keyword">this</span>.gender+<span class="string">"]"</span>;  </span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2></li><li>就像人生活的时间长了会产生垃圾一样，程序运行过程中也会产生垃圾,这些垃圾积攒过多以后，会导致程序运行的速度过慢，所以我们需要一个垃圾回收的机制，来处理程序运行过程中产生垃圾</li><li>当一个对象没有任何的变量或属性对它进行引用，此时我们将永远无法操作该对象，此时这种对象就是一个垃圾，这种对象过多会占用大量的内存空间，导致程序运行变慢，所以这种垃圾必须进行清理。</li><li>在JS中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁，我们不需要也不能进行垃圾回收的操作，<strong>我们需要做的只是要将不再使用的对象设置null即可</strong></li></ul><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><ul><li>数组也是一个对象，是一个用来存储数据的对象和Object类似，但是它的存储效率比普通对象要高，数组中保存的内容我们称为元素<h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">方法一：</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();  </span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">123</span>;  </span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">"hello"</span>;</span><br><span class="line">方法二：</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">123</span>,<span class="string">"hello"</span>];</span><br></pre></td></tr></table></figure><h2 id="数组的方法"><a href="#数组的方法" class="headerlink" title="数组的方法"></a>数组的方法</h2>FunctionName | Function</li></ul><p>–|–<br>push() | 用来向数组的末尾添加一个或多个元素，并返回数组新的长度<br>pop()    | 用来删除数组的最后一个元素，并返回被删除的元素<br>unshift()|向数组的开头添加一个或多个元素，并返回数组的新的长度<br>shift()|删除数组的开头的一个元素，并返回被删除的元素<br>slice(start,end)|可以从一个数组中截取指定的元素，该方法不会影响原数组，而是将截取到的内容封装为一个新的数组并返回<br>splice()|可以用来删除数组中指定元素，并使用新的元素替换，该方法会将删除的元素封装到新数组中返回，第三个及以后，都是替换的元素，这些元素将会插入到开始位置索引的前边<br>concat()|可以连接两个或多个数组，它不会影响原数组，而是连接数组作为返回值返回<br>join()|可以将一个数组转换为一个字符串,它不会影响原数组，而是转换后的数组作为返回值返回<br>reverse()|可以用来反转一个数组，它会对原数组产生影响<br>sort()|可以对一个数组中的内容进行排序，默认是按照Unicode编码进行排序，他会对原数组产生影响，我们可以自己来指定排序的规则我们可以在sort()添加一个回调函数【数组.sort(functiom(a,b){});】，来指定排序规则，回调函数中需要定义两个形参</p><h2 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h2><ol><li><p>用for循环来遍历数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">方法一：</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span> ; i&lt;数组.length ; i++)&#123;  </span><br><span class="line">    <span class="comment">//数组[i]  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用forEach()方法来遍历数组（不兼容IE8）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">数组.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value , index , obj</span>)</span>&#123;  </span><br><span class="line">  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">value:正在遍历的元素</span><br><span class="line">index:正在遍历元素的索引</span><br><span class="line">obj:被遍历对象</span><br></pre></td></tr></table></figure></li></ol><ul><li>forEach()方法需要一个回调函数作为参数，<br>数组中有几个元素，回调函数就会被调用几次，<br>每次调用时，都会将遍历到的信息以实参的形式传递进来，<br>我们可以定义形参来获取这些信息</li></ul><h1 id="常用类和方法"><a href="#常用类和方法" class="headerlink" title="常用类和方法"></a>常用类和方法</h1><h2 id="call-和apply"><a href="#call-和apply" class="headerlink" title="call()和apply()"></a>call()和apply()</h2><ul><li>这两个方法都是函数对象的方法，需要通过函数对象调用</li><li>当对函数调用call()和apply()都会调用函数执行</li><li>在调用call()和apply()可以将一个对象指定为第一个参数，此时这个对象将会成为函数执行时的this</li><li>call()方法可以将实参在对象之后一次传递</li><li>apply()方法需要将实参封装到一个数组中统一传递</li></ul><h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><ul><li>arguments是一个类数组对象，它可以通过索引来操作数据，也可以获取长度</li><li>在调用函数是，我们所传递的实参都会在arguments中保存</li><li>arguements.length可以用来获取实参长度</li><li>还可以用arguements来使用实参，arguements[0]表示第一个实参，arguements[1]表示第二个实参···</li><li>它里面有一个属性交callee，这个属性对应一个函数对象，就是当前正在指向的函数对象</li></ul><h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><ul><li>日期的对象，在JS中通过Date对象来表示一个时间</li><li>如果直接用构造函数创建一个Date对象，则封装为当前代码执行的时间</li><li>创建对象<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">创建一个当前的时间对象</span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line">创建一个指定的时间对象</span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">"月/日/年 时:分:秒"</span>);</span><br></pre></td></tr></table></figure></li><li>方法</li></ul><table><thead><tr><th>name</th><th>function</th></tr></thead><tbody><tr><td>getDate()</td><td>当前日期对象是几日（1-31）</td></tr><tr><td>getDay()</td><td>返回当前日期对象时周几（0-6），0 周日，1 周一 ···</td></tr><tr><td>getMonth()</td><td>返回当前日期对象的月份（0-11），0 一月， 1 二月 ···</td></tr><tr><td>getFullYear()</td><td>从 Date 对象以四位数字返回年份</td></tr><tr><td>getHours()</td><td>返回 Date 对象的小时 (0 ~ 23)</td></tr><tr><td>getMinutes()</td><td>返回 Date 对象的分钟 (0 ~ 59)</td></tr><tr><td>getSeconds()</td><td>返回 Date 对象的秒数 (0 ~ 59)</td></tr><tr><td>getMilliseconds()</td><td>返回 Date 对象的毫秒(0 ~ 999)</td></tr><tr><td>getTime()</td><td>返回当前日期对象的时间戳，时间戳，指的是从1970年月1日 0时0分0秒，到现在时间的毫秒数，计算机底层保存时间都是以时间戳的形式保存的</td></tr><tr><td>Date.now()</td><td>可以获取当前代码执行时的时间戳</td></tr></tbody></table><h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><ul><li>Math属于一个工具类，它不需要我们创建对象，它里边封装了属性运算相关的常量和方法,我们可以直接使用它来进行数学运算相关的操作</li><li>方法</li></ul><table><thead><tr><th>name</th><th>function</th></tr></thead><tbody><tr><td>Math.PI</td><td>常量，圆周率</td></tr><tr><td>Math.abs()</td><td>绝对值运算</td></tr><tr><td>Math.cell()</td><td>向上取整</td></tr><tr><td>Math.floor()</td><td>向下取整</td></tr><tr><td>Math.round()</td><td>四舍五入取整</td></tr><tr><td>Math.random()</td><td>生成一个01之间的随机数</td></tr><tr><td>Math.round(Math.random()*(y-x)+x)</td><td>生成一个xy之间的随机数</td></tr><tr><td>Math.pow(x,y)</td><td>求x的y次幂</td></tr><tr><td>Math.sqrt()</td><td>对一个数进行开方</td></tr><tr><td>Math.max()</td><td>求多个数中最大值</td></tr><tr><td>Math.min()</td><td>求多个数中的最小值</td></tr></tbody></table><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><ul><li>在JS中为我们提供了三个包装类，通过这三个包装类可以将基本的数据类型的数据转换为对象： String() Boolean() Number()通过这三个包装类可以创建基本数据类型的对象<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">通过包装类创建基本数据类型的对象：</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">2</span>);  </span><br><span class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"hello"</span>);  </span><br><span class="line"><span class="keyword">var</span> bool = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure></li><li>但是在实际应用中千万不要这么干。当我们去操作一个基本数据类型的属性和方法时，解析器会临时将其转换为对应的包装类，然后再去操作属性和方法，操作完成以后再将这个临时对象进行销毁</li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul><li>在底层字符串是以字符数组的形式保存的</li><li>方法</li></ul><table><thead><tr><th>name</th><th>function</th></tr></thead><tbody><tr><td>length</td><td>获取字符串的长度</td></tr><tr><td>charAt()</td><td>根据索引获取指定的字符</td></tr><tr><td>charCodeAt()</td><td>根据索引获取指定的字符编码(Unicode编码)</td></tr><tr><td>String.fromCharCode()</td><td>根据字符编码获取字符</td></tr><tr><td>indexof()</td><td>可以检索一个字符串是否含有指定内容，需要一个字符串作为参数，这个字符串就是要检索的内容，如果找到该内容，则会返回其第一次出现的索引，如果没有找到则返回-1，可以指定一个第二个参数，来表示开始查找的位置</td></tr><tr><td>lastIndexOf()</td><td>功能同indexof，indexOf()是从前向后找，lastIndexOf()是从后向前找</td></tr><tr><td>slice(start,end)</td><td>可以从一个字符串中截取指定的内容，并将截取到内容返回，不会影响原变量，参数：第一个：截取开始的位置（包括开始），第二个：截取结束的位置（不包括结束）可以省略第二个参数，如果省略则一直截取到最后，可以传负数，如果是负数则从后往前数</td></tr><tr><td>substr()</td><td>和slice()基本一致，不同的是它第二个参数不是索引，而是截取的数量</td></tr><tr><td>substring()</td><td>和slice()基本一致，不同的是它不能接受负值作为参数，如果设置一个负值，则会自动修正为0，substring()中如果第二个参数小于第一个，自动调整位置</td></tr><tr><td>toLowerCase()</td><td>将字符串转换为小写并返回</td></tr><tr><td>toUpperCase()</td><td>将字符串转换为大写并返回</td></tr><tr><td>正则表达式相关方法:</td><td></td></tr><tr><td>split()</td><td>可以将一个字符串拆分成一个数组，方法中可以传一个正则表达式作为参数，这样方法就会根据正则表达式去拆分字符串</td></tr><tr><td>search()</td><td>可以搜索字符串中是否含有指定内容，如果搜索到指定内容，则会返回第一次出现的索引，如果没有则返回-1，它可以接受正则表达式作为参数，然后根据正则表达式去检索字符串,search只会查找第一个，即使设置全局匹配也没用</td></tr><tr><td>match()</td><td>可以根据正则表达式，从一个字符串中将符合条件的内容提取出来，默认情况下我们的match只会找到第一个符合要求的内容，找到以后就停止检索，我们可以设置正则表达式为全局匹配模式，这样就会匹配到所有的内容，可以为一个正则表达式设置多个匹配模式，且顺序无所谓，match()会将匹配到的内容封装到一个数组中返回，即使只查询到一个结果</td></tr><tr><td>replace()</td><td>可以将字符串中指定内容替换为新的内容,参数：1.被替换的内容，可以接受一个正则表达式作为参数2.新的内容 空串则为删除””,默认只会替换第一个</td></tr></tbody></table><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><ul><li><p>用于定义一些字符串的规则，计算机可以根据正则表达式来检查一个字符串是否符合规则，并将字符串中符合规则的内容提取出来</p></li><li><p>创建正则表达式</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">方法一：</span><br><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(“正则”,”匹配模式”); </span><br><span class="line"></span><br><span class="line">方法二：</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/正则表达式/</span>匹配模式; </span><br><span class="line"><span class="comment">//（匹配模式可以多个一起写：/gi）</span></span><br><span class="line"></span><br><span class="line">匹配模式：</span><br><span class="line">i:忽略大小写（ignore）</span><br><span class="line">g:全局匹配模式（默认为<span class="number">1</span>次）</span><br><span class="line">m:执行多行匹配</span><br><span class="line">设置匹配模式时，可以都不设置，也可以设置<span class="number">1</span>个，也可以全设置，设置时没有顺序要求</span><br></pre></td></tr></table></figure><ul><li>test()<ul><li>语法：正则表达式.test(字符串)</li><li>可以用来检查一个字符串是否符合正则表达式，如果符合返回true，否则返回false</li></ul></li></ul></li><li><p>正则语法</p><ul><li>| 或</li><li>[] 或   //[]里的内容也是或的关系</li><li>[^···] 除了 //除了···都为true</li><li><strong>[x-y] x的ascii到y的ascii码之间的值</strong>  </li><li>[a-z] 小写字母 （也可以[e-i])</li><li>[A-Z] 大写字母</li><li>[A-z] 任意字母,但是还包括了其他ASCII在此之中的</li><li>[0-9] 任意数字</li></ul></li><li><p>量词</p><ul><li>通过量词可以设置一个内容出现的次数，<strong>量词只对它前边的一个内容起作用</strong></li><li>{n} &nbsp;&nbsp;&nbsp;&nbsp;正好出现n次</li><li>{m,n} &nbsp;&nbsp;&nbsp;出现m~n次</li><li>{m,} &nbsp;&nbsp;&nbsp;出现m次以上</li><li>+&nbsp;&nbsp;&nbsp;至少一个，相当于{1,}</li><li>*&nbsp;&nbsp;&nbsp;0个或多个，相当于{0,}</li><li>?&nbsp;&nbsp;&nbsp;0个或1个，相当于{0,1}</li></ul></li><li><p>边界表达式</p><ul><li>^表示开头</li><li>$表示结尾</li><li>在正则表达式中同时使用^$则要求字符串必须符合正则表达式<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line">reg = <span class="regexp">/^a/</span>;  <span class="comment">//以a开头</span></span><br><span class="line">reg = <span class="regexp">/b$/</span>;  <span class="comment">//以b接位</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>元符号</p><ul><li>. &nbsp;&nbsp;&nbsp;&nbsp;表示任意字符</li><li>\ &nbsp;. &nbsp;表示 .</li><li>&amp;nbsp;\ &nbsp;表示 \</li><li>\w&nbsp;&nbsp;任意字母、数字、_ [A-z0-9_]</li><li>\W&nbsp;&nbsp;除了字母、数字、_ [ ^A-z0-9_]</li><li>\d&nbsp;&nbsp;任意的数字 [0-9]</li><li>\D&nbsp;&nbsp;除了数字 [ ^0-9]</li><li>\s&nbsp;&nbsp;空格</li><li>\S&nbsp;&nbsp;除了空格</li><li>\b&nbsp;&nbsp;单词边界</li><li>\B&nbsp;&nbsp;除了单词边界</li></ul></li><li><p>正则表达式应用举例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">去掉字符串两端的空格:</span><br><span class="line"><span class="keyword">var</span> s = <span class="string">"        he    llo    "</span>;   </span><br><span class="line">s = s.replace(<span class="regexp">/^\s*|\s*$/g</span>,<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">邮件的正则:</span><br><span class="line">hello.nihao@abc.com.cn</span><br><span class="line">任意字母下划线 . 任意字母下划线  @ 任意字母数字 .任意字母(<span class="number">2</span><span class="number">-5</span>位) .任意字母(<span class="number">2</span><span class="number">-5</span>位)</span><br><span class="line">\w&#123;<span class="number">3</span>,&#125;  (\.\w+)*  @  [A-z0<span class="number">-9</span>]+  (\.[A-z]&#123;<span class="number">2</span>,<span class="number">5</span>&#125;)&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="未完待续···"><a href="#未完待续···" class="headerlink" title="未完待续···"></a>未完待续···</h1>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;序&lt;br&gt;&lt;br&gt;终于开始学前端的核心内容了！学好JS才能为后面的jQuery( JavaScript 库)和JS框架(React,Vue,Angular)打好基础，冲冲冲！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="前端三大块" scheme="http://xyx6.top/categories/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%A4%A7%E5%9D%97/"/>
    
    
      <category term="JavaScript" scheme="http://xyx6.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>HTML CSS</title>
    <link href="http://xyx6.top/2020/07/04/htmlcss/"/>
    <id>http://xyx6.top/2020/07/04/htmlcss/</id>
    <published>2020-07-04T10:22:07.000Z</published>
    <updated>2020-07-07T06:06:40.611Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>序<br><br>最近时间空闲比较多，想起来还没有系统的学习过html,css和js，刚好趁着最近复习巩固一下这块的知识，把自己学习的东西记录下来。let’s do it!</p></blockquote><a id="more"></a><h1 id="html"><a href="#html" class="headerlink" title="html"></a>html</h1><blockquote><p>div是块元素，他会独占一整行，无论他的内容有多少，主要用来页面布局。而像span,a,img,iframe这种的内联元素（行内元素）只占自身大小，不会占用一整行。<strong>块元素主要用来做页面的布局，内联元素用来选中文本设置样式</strong></p></blockquote><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><ol><li>无序列表<ul><li>使用ul标签来创建一个无序列表</li><li>使用li在ul中创建一个一个的列表项</li><li>通过type属性修改列表中的项目符号，也可以在css中用list-style:none来去掉项目符号</li></ul></li><li>有序列表<ul><li>有序列表和无序列表相似，只不过他用ol来代替ul</li></ul></li><li>定义列表<ul><li>使用dl来创建一个定义列表</li><li>dt: 被定义的内容</li><li>dd: 对定义内容的表述</li></ul></li></ol><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><ul><li>html中用table标签来创建单元格</li><li>table标签中用tr表示行，tr中用td表示列来创建单元格</li><li>colspan设置横向合并单元格，rowspan设置纵向合并单元格</li><li>table和td边框之间的默认距离可以用border-spacing：0或者是border-collapse：collapse来消除</li></ul><h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><ul><li>form标签中必须指定一个action属性，该属性指向一个服务器地址，当我们提交表单时将会提交到action属性对应的地址，在form中添加不同的表单项</li></ul><h2 id="框架集"><a href="#框架集" class="headerlink" title="框架集"></a>框架集</h2><ul><li>使用frameset来创建一个框架集，注意frameset和body不能出现在一个页面中</li><li>框架集和内敛框架的作用相似，都是引用外部页面，但是框架集可以同时引用多个，而内联框架只能引入一个</li><li>框架集中的框架：rows按行排列/cols按列排列</li><li>frameset中可以再嵌套frameset</li><li>frameset和iframe一样，他里面的内容都不会被搜索引擎所检索</li><li>使用frameset就意味着页面中不能有自己的内容，只能引入其他的页面，而我们所加载的每一个页面浏览器都需要重新发送一次请求，用户体验差</li></ul><h2 id="hack"><a href="#hack" class="headerlink" title="hack"></a>hack</h2><blockquote><p>hack其实时一个特殊的代码，这段代码只有在某些浏览器可以识别，而其他浏览器不能识别，通过这种方式，来为一些浏览器设置特殊代码</p></blockquote><ul><li><p>条件hack</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--if&lt;keywords&gt;?IE&lt;version&gt;?&gt;</span></span><br><span class="line"><span class="comment">html代码块</span></span><br><span class="line"><span class="comment">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>属性hack</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selector&#123;<span class="tag">&lt;<span class="name">hack</span>&gt;</span>?property:value<span class="tag">&lt;<span class="name">hack</span>&gt;</span>?;&#125;</span><br></pre></td></tr></table></figure></li></ul><p><a href="https://www.w3school.com.cn/html/index.asp" target="_blank" rel="noopener">html详细教程</a><br><br></p><h1 id="css"><a href="#css" class="headerlink" title="css"></a>css</h1><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><ol><li>元素选择器<ul><li>可以直接使用标签名做元素选择器</li></ul></li><li>id选择器<ul><li>【id=”p1”】-&gt;【#p1】</li></ul></li><li>class选择器<ul><li>【class=”p1”】-&gt;【.p1】</li><li><strong>class属性和id属性相似，只不过class属性可以重复拥有相同的class属性值元素，我们称它为一组元素</strong></li></ul></li><li>伪类选择器<blockquote><p>伪类专门用来表示元素的一种特殊的状态，当我们需要为处在特殊状态的元素设置样式时，就可以用伪类</p></blockquote><ul><li>a.link    没访问过的链接样式</li><li>a.visited 访问过的链接样式</li><li>a.hover   鼠标移入的状态</li><li>a.active  链接被点击的状态</li><li>a.focus 获取焦点的状态</li></ul></li><li>属性选择器<ul><li>可以根据元素的属性或属性值来选取制定的元素。</li><li><strong>选择器优先级：内联样式&gt;id选择器，class选择器&gt;伪类选择器&gt;元素选择器</strong></li></ul></li></ol><h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><ol><li>可以用英文单词表示</li><li>可以用rgb(xxx,xxx,xxx)表示，取自于红绿蓝三原色按照各自的浓度来配色，可以用截图工具取色</li><li>可以用rgb的十六进制表示 #000000，两位表示一个颜色</li></ol><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><ol><li>font-size设置大小</li><li>font-family设置字体</li><li>font-style设置斜体</li><li>font-weight设置加粗效果</li><li>font-variant设置大小写</li></ol><h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><blockquote><p>width和height只是设置内容区的大小，而不是盒子的大小<br><br>盒子的大小由内容区，内边距，边框共同决定</p></blockquote><ol><li>border边框<ul><li>border-width:边框的宽度</li><li>border-color:边框的颜色</li><li>边框的宽度和颜色可以设置四个值，分别代表边框上右下左(顺时针)的属性</li><li>border-style:边框的样式</li><li>简写形式border：颜色 样式 宽度</li></ul></li><li>padding内边框<ul><li>内边距会影响盒子可见框的大小</li><li>padding-top/right/bottom/left</li></ul></li><li>margin外边距<ul><li>外边距指的是当前盒子和其他盒子之间的距离</li><li>margin-top/right/bottom/left:正负表示相反方向</li></ul></li><li>垂直外边距的重叠<ul><li>在网页中垂直方向的相邻外边距会发生外边距的重叠</li><li>外边距重叠指兄弟元素之间的相邻外边距会取最大值而不是求和</li><li>如果父子元素的垂直外边距相邻了，则子元素的外边距会设置给父元素</li><li>解决方法：可以通过在父子元素中间加元素来隔开他们，使他们不在相邻；也可以通过设置父元素的内边距来实现</li></ul></li><li>内联元素可以设置内边距和边框，水平方向影响布局，垂直方向不影响布局；还可以设置外边距，水平方向相邻外边距是求和的，但不支持垂直方向的外边距</li></ol><p><img src="/2020/07/04/htmlcss/htmlcss.jpg" alt></p><h2 id="display"><a href="#display" class="headerlink" title="display"></a>display</h2><blockquote><p>display可以将行内元素变成块元素，可以用来改变行内元素的宽高</p></blockquote><ol><li>display：inline 可以将一个元素作为内联元素显示</li><li>display：block  可以将一个元素设置为块元素</li><li>display：inline-block 将一个行内元素转换为块元素，可以使一个元素既可以设置宽高，又不会独占一行（既有行内元素的特点又有块元素的特点）<ul><li>如果想要元素消失后位置保留，可以用visibility：hidden</li></ul></li><li>display：none 不显示元素，并且元素不会再页面中继续占有位置</li></ol><h2 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h2><blockquote><p>文档流处在网页的底层，他表示的是一个页面中的位置，我们所创建的元素默认都处在文档流中</p></blockquote><ol><li>块元素在文档流中的特点<ul><li>块元素在文档流中会独占一行，快元素会自上向下排列</li><li>块元素在文档流中默认宽度是父元素的100%</li><li>块元素在文档流中的高度默认被内容撑开</li></ul></li><li>内联元素在文档流中的特点<ul><li>如果一行中不足以容纳所有的内联元素，则换到下一行，继续从左向右</li></ul></li><li>当元素的宽度的值为auto时，此时会指定内边距不影响可见框的大小，而是会自动修改宽度来适应内边距</li></ol><h2 id="float"><a href="#float" class="headerlink" title="float"></a>float</h2><blockquote><p>使用float来使元素浮动，从而脱离文档流</p></blockquote><ol><li>none：默认值，元素默认在文档流中排列</li><li>left：元素立即脱离文档流，向页面的左侧浮动</li><li>right：元素立即脱离文档流，向页面的右侧浮动</li></ol><ul><li>元素脱离文档流后，它下面的元素立即向上移动，元素浮动以后，会尽量向页面的左上或者是右上移动，直到遇到父元素的边框或者是其他浮动元素</li><li>如果浮动元素的上边是一个没有浮动的块元素，则浮动元素不会超过块元素</li><li>浮动元素不会超过他上边的兄弟元素，最多和他上面的兄弟元素并列</li><li>浮动元素不会覆盖文字，文字会自动环绕在元素的周围</li><li>块元素脱离文档流后，高度和宽度都被内容撑开</li><li>内联元素脱离文档流后，就变成了块元素，高度和宽度都被内容撑开</li><li><strong>一旦脱离文档流后，内联元素和块元素全都是块元素，不做区分</strong><blockquote><p>clear可以用来清除浮动</p></blockquote></li></ul><ol><li>none：默认值，不清除浮动</li><li>left: 清除左侧浮动元素对当前元素的影响</li><li>right：清除右侧浮动元素对当前元素的影响</li><li>both：清除两侧浮动元素对当前元素的影响</li></ol><h2 id="高度塌陷问题"><a href="#高度塌陷问题" class="headerlink" title="高度塌陷问题"></a>高度塌陷问题</h2><blockquote><p>在文档流中，父元素的高度默认是被子元素撑开的，也就是子元素多高，父元素就多高，但是当子元素设置浮动以后，子元素脱离文档流，此时将会导致子元素无法撑起父元素的高度，导致父元素的高度塌陷。由于父元素的高度塌陷了，则父元素下的所有元素都会向上移动，导致页面布局混乱。</p></blockquote><ul><li>解决方法：<ol><li>我们可以将父元素的高度写死，来避免塌陷，但是我们一旦将高度写死，父元素就不能自适应子元素的高度，所以这种方法不推荐</li><li>在页面中的元素都有一个隐含的属性叫block formatting contex，简称bfc，该属性可以设置打开或者关闭，默认是关闭的<ul><li>开启bfc后，元素具有以下特征：<ol><li>父元素的垂直外边距不会和子元素重叠</li><li>开启bfc的元素不会被浮动元素所覆盖</li><li>开启bfc的元素可以包括浮动的子元素</li></ol></li><li>如何开启元素的bfc<ol><li>设置元素浮动<ul><li>使用这种方式开启，虽然可以撑开父元素，但是会导致父元素的宽度丢失，而且使用这种方式也会导致下边的元素上移，不能解决问题，不推荐</li></ul></li><li>设置元素绝对定位<ul><li>效果同1，不推荐</li></ul></li><li>设置元素为inline-block<ul><li>可以解决问题，但是会导致宽度丢失，不推荐</li></ul></li><li>将元素的overflow设置为一个非visible的值<ul><li><strong>推荐方式：将overflow设置为hidden是副作用最小的开启bfc的方式</strong></li></ul></li></ol></li></ul></li><li>但是在IE6及以下版本不支持bfc，所以在IE6中我们通过开haslayout来解决问题，开启方式：直接将元素的zoom设置为1</li><li>还可以在高度塌陷的父元素的最后，添加一个空白的div，由于这个div没有浮动，所以他是可以撑开父元素的高度的，然后对其进行清除浮动，这样就可以通过空白的div来撑开父元素，基本没有副作用，但是会产生一个多余的div结构，所以我们还可以用div的after伪类在元素的最后添加一个空白的块元素来实现同样的效果</li><li>clearfix<blockquote><p>既可以解决高度塌陷,又可以确保父元素和子元素的垂直外边距不会重叠</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.clearfix:before,</span><br><span class="line">.clearfix:after&#123;</span><br><span class="line">   content:"";</span><br><span class="line">   display:table;</span><br><span class="line">   clear:both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><blockquote><p>定位就是将指定的定位摆放到页面的任意位置</p></blockquote><ol><li>相对定位(position：relative)<ul><li>当开启了元素的相对定位以后，而不设置偏移量时，元素不会发生变化</li><li>当元素开启定位后，可以通过left，right，top，bottom来设置元素相对于其定位位置的偏移量</li><li>相对定位是相对于元素在文档流中的位置进行定位</li><li>相对定位的元素不会脱离文档流</li><li>相对定位会使元素提升一个层级(覆盖低层级元素)</li><li>相对定位不会改变元素的性质，块还是块，内联还是内联</li></ul></li><li>绝对定位(position：absolute)<ul><li>开启绝对定位后会脱离文档流</li><li>开启绝对定位后，如果不设置偏移量，则元素的位置不发生改变</li><li>绝对定位是相当于离他最近的开启了定位的祖先元素进行定位的，如果所有的祖先元素都没有开启定位，则会相对于浏览器窗口进行定位</li><li>绝对定位也会使元素提升一个层级(覆盖低层级元素)</li><li>绝对定位会改变元素的性质，内联元素变成块元素，块的宽高被内容撑开</li></ul></li><li>固定定位(position：fixed)<ul><li>固定定位也是一种相对定位，他的绝大多数特点和绝对定位一样</li><li>不同的是：固定定位永远都会相对于浏览器窗口进行定位，它永远固定在窗口的某个位置，不会随着滚动条滚动</li></ul></li></ol><h2 id="层级"><a href="#层级" class="headerlink" title="层级"></a>层级</h2><blockquote><p>如果定位元素的层级是一样的，则下边的元素会盖住上边的，还可以通过z-inline属性来设置元素的层级(父元素的层级再高，也不会盖住子元素)，当然没有开启定位的元素不能使用z-inline</p></blockquote><h2 id="透明背景"><a href="#透明背景" class="headerlink" title="透明背景"></a>透明背景</h2><blockquote><p>opacity可以用来设置元素背景的透明,范围：0<del>1(完全透明</del>不透明)</p></blockquote><p><a href="https://www.w3school.com.cn/css/index.asp" target="_blank" rel="noopener">css详细教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;序&lt;br&gt;&lt;br&gt;最近时间空闲比较多，想起来还没有系统的学习过html,css和js，刚好趁着最近复习巩固一下这块的知识，把自己学习的东西记录下来。let’s do it!&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="前端三大块" scheme="http://xyx6.top/categories/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%A4%A7%E5%9D%97/"/>
    
    
      <category term="html css" scheme="http://xyx6.top/tags/html-css/"/>
    
  </entry>
  
  <entry>
    <title>hello world</title>
    <link href="http://xyx6.top/2020/07/02/hello-world/"/>
    <id>http://xyx6.top/2020/07/02/hello-world/</id>
    <published>2020-07-02T04:22:07.000Z</published>
    <updated>2020-07-04T16:49:08.113Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>序<br><br>偶尔有天在B站上刷到一段视频，内容是up主用hexo快速的搭建个人博客，虽然说作为软件专业的学生用这种快速的网站生成器实属有点说不过去，但是俗话说得好：强撸灰飞湮灭，要是真的手撸出来个人网站，一来按我这个渣渣水平都到猴年马月去了，二来就是想在学习的过程中记录下来一些东西来复习，所以出此下策才有了这个网站。</p></blockquote><a id="more"></a><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul><li>Git</li><li>Nginx</li><li>Nodejs</li><li>搭载环境<ol><li>阿里云服务器(学生白嫖服务器，不用白不用，地址：<a href="https://developer.aliyun.com/adc/student/" target="_blank" rel="noopener">https://developer.aliyun.com/adc/student/</a>)</li><li>域名（在万网根据个人喜欢挑选一个心仪的）</li><li>还可以用Github来部署（不需要域名和服务器且免费，不要问我为什么不用，问就是我傲娇，嫌用github后缀名太吃藕）</li></ol></li><li>hexo<ol><li>主角来了，hexo是基于node.js的一款轻量级的博客制作工具。它可以将我们在本地编写的markdown文档转化成html页面，然后我们将html页面上传到服务器上。</li><li>hexo还支持切换主题的功能，在本地下载主题文件，可以通过修改theme配置文件和hexo的配置文件实现网页的个性化。</li></ol></li></ul><p><strong><em>域名和服务器大概是在5月20号左右买的，买完以后就迎来了很多大大小小的考试，到最近一段时间才想起来还有这么茬事，就索性把这件事落实下来，整个过程还算顺利，已经有了大致的雏形，不过还有些小功能有待发掘，日后再一一填补上来。</em></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;序&lt;br&gt;&lt;br&gt;偶尔有天在B站上刷到一段视频，内容是up主用hexo快速的搭建个人博客，虽然说作为软件专业的学生用这种快速的网站生成器实属有点说不过去，但是俗话说得好：强撸灰飞湮灭，要是真的手撸出来个人网站，一来按我这个渣渣水平都到猴年马月去了，二来就是想在学习的过程中记录下来一些东西来复习，所以出此下策才有了这个网站。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="日常" scheme="http://xyx6.top/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="杂记" scheme="http://xyx6.top/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
</feed>
