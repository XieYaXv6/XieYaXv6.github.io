<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ES6-ES11</title>
    <url>/2020/07/14/ES6-ES11/</url>
    <content><![CDATA[<blockquote>
<p>序<br><br> ECMAScript 是由ECMA国际通过 ECMA-262标准化的脚本标准化的脚本程序设计语言，Ecma 国际制定了许多标准，而 ECMA-262 只是其中的一个，从 ES6 开始，每年发布一个版本，版本号比年份最后一位大 1，ECMA-262至今已发展到了第十一版。</p>
</blockquote>
<a id="more"></a>
<h1 id="ECMA"><a href="#ECMA" class="headerlink" title="ECMA"></a>ECMA</h1><ul>
<li><p>ECMA（European Computer Manufacturers Association）</p>
<ul>
<li>中文名称为欧洲计算机制 造商协会，这个组织的目标是评估、开发和认可电信计算机标准。1994年后该组织改名为 ECMA国际</li>
</ul>
</li>
<li><p>谁在维护 ECMA-262</p>
<ul>
<li>TC39（Technical Committee 39）是推进 ECMAScript 发展的委员会。其会员都是公司（其中主要是浏览器厂商，有苹果、谷歌、微软、因特尔等）。TC39 定期召开会议，会议由会员公司的代表与特邀专家出席</li>
</ul>
</li>
<li><p>兼容性</p>
</li>
<li><p><a href="http://kangax.github.io/compat-table/es6/" target="_blank" rel="noopener">http://kangax.github.io/compat-table/es6/</a> 可查看兼容性<br><img src="/2020/07/14/ES6-ES11/%E5%85%BC%E5%AE%B9%E6%80%A7.png" alt></p>
</li>
<li><p>红色表示不兼容，绿色表示兼容</p>
</li>
</ul>
<h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><ul>
<li>ES6 的版本变动内容最多，具有里程碑意义</li>
<li>ES6 加入许多新的语法特性，编程实现更简单、高效</li>
</ul>
<h2 id="let关键字"><a href="#let关键字" class="headerlink" title="let关键字"></a>let关键字</h2><ul>
<li>let 关键字用来声明变量，使用 let 声明的变量有几个特点：</li>
</ul>
<ol>
<li>不允许重复声明</li>
<li>块级作用域</li>
<li>不存在变量提升,不允许在变量声明之前使用</li>
<li>不影响作用域链的效果</li>
</ol>
<ul>
<li>应用场景：以后声明变量使用 let 就对了</li>
</ul>
<h2 id="const-关键字"><a href="#const-关键字" class="headerlink" title="const 关键字"></a>const 关键字</h2><ul>
<li>const 关键字用来声明常量，const 声明有以下特点</li>
</ul>
<ol>
<li>声明必须赋初始值</li>
<li>标识符一般为大写</li>
<li>不允许重复声明</li>
<li><strong>值不允许修改</strong></li>
<li>块级作用域</li>
</ol>
<ul>
<li>注意: 对象属性修改和数组元素变化不会触发const错误，因为地址没有改变</li>
<li>应用场景：声明对象类型使用 const，非对象类型声明选择 let</li>
</ul>
<h2 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h2><ul>
<li>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构赋值<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;数组的解构赋值</span><br><span class="line">const arr &#x3D; [&#39;张学友&#39;, &#39;刘德华&#39;, &#39;黎明&#39;, &#39;郭富城&#39;]; </span><br><span class="line">let [zhang, liu, li, guo] &#x3D; arr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;对象的解构赋值</span><br><span class="line">const lin &#x3D; &#123;</span><br><span class="line">name: &#39;林志颖&#39;,</span><br><span class="line">tags: [&#39;车手&#39;, &#39;歌手&#39;, &#39;小旋风&#39;, &#39;演员&#39;]</span><br><span class="line">&#125;;</span><br><span class="line">let &#123;name, tags&#125; &#x3D; lin;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;复杂解构</span><br><span class="line">let wangfei &#x3D; &#123;</span><br><span class="line">name: &#39;王菲&#39;, age: 18,</span><br><span class="line">songs: [&#39;红豆&#39;, &#39;流年&#39;, &#39;暧昧&#39;, &#39;传奇&#39;], </span><br><span class="line">history: [</span><br><span class="line">&#123;name: &#39;窦唯&#39;&#125;,</span><br><span class="line">&#123;name: &#39;李亚鹏&#39;&#125;,</span><br><span class="line">&#123;name: &#39;谢霆锋&#39;&#125;</span><br><span class="line">]&#125;;</span><br><span class="line">let &#123;songs: [one, two, three], history: [first, second, third]&#125; &#x3D;wangfei;</span><br></pre></td></tr></table></figure>
<h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2></li>
<li>模板字符串（template string）是增强版的字符串，用反引号（`）标识，特点：<br>1)    字符串中可以出现换行符<br>2)    可以使用 ${xxx} 形式输出变量<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 变量拼接</span><br><span class="line">let lovest &#x3D; &#39;魏翔&#39;;</span><br><span class="line">let out &#x3D; &#96;$&#123;lovest&#125;是我心目中最搞笑的演员!!&#96;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="简化对象写法"><a href="#简化对象写法" class="headerlink" title="简化对象写法"></a>简化对象写法</h2><ul>
<li>ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let name &#x3D; &#39;xxx&#39;;</span><br><span class="line">        let change &#x3D; function()&#123;</span><br><span class="line">            console.log(&#39;xxx!&#39;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        const school &#x3D; &#123;</span><br><span class="line">            name,</span><br><span class="line">            change,</span><br><span class="line">            improve()&#123;         &#x2F;&#x2F;可以省略function</span><br><span class="line">                console.log(&quot;xxx&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><ul>
<li>ES6 允许使用「箭头」（ =&gt; ）定义函数。<br>箭头函数的注意点:<br>1)    如果形参只有一个，则小括号可以省略<br>2)    函数体如果只有一条语句，则花括号可以省略，函数的返回值为该条语句的执行结果<br>3)    this 是静态的. this 始终指向函数声明时所在作用域下的 this 的值<br>4)    箭头函数不能作为构造函数实例化<br>5)    不能使用 arguments<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 1. 通用写法</span><br><span class="line">*&#x2F;</span><br><span class="line">let fn &#x3D; (arg1, arg2, arg3) &#x3D;&gt; &#123;</span><br><span class="line">return arg1 + arg2 + arg3;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 2. 省略小括号的情况, 当形参有且只有一个的时候</span><br><span class="line">*&#x2F;</span><br><span class="line">let fn2 &#x3D; num &#x3D;&gt; &#123;</span><br><span class="line">return num * 10;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 3. 省略花括号的情况,当代码体只有一条语句的时候, 此时 return 必须省略,语句的执行结果就是函数的返回值</span><br><span class="line">*&#x2F;</span><br><span class="line">let fn3 &#x3D; score &#x3D;&gt; score * 20;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 4. this 指向声明时所在作用域中 this 的值</span><br><span class="line">*&#x2F;</span><br><span class="line">let fn4 &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">console.log(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>注意：箭头函数不会更改 this 指向，用来指定回调函数会非常合适</li>
<li>ES6 允许给函数参数赋值初始值<ol>
<li>形参初始值 具有默认值的参数, 一般位置要靠后(潜规则)</li>
<li>默认值还可以与解构赋值结合</li>
</ol>
</li>
</ul>
<h2 id="rest-参数"><a href="#rest-参数" class="headerlink" title="rest 参数"></a>rest 参数</h2><ul>
<li>ES6 引入 rest 参数（…args），用于获取函数的实参，用来代替 arguments<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rest 参数必须要放到参数最后</span><br><span class="line">function fn(a,b,...args)&#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">    console.log(b);</span><br><span class="line">    console.log(args);</span><br><span class="line">    &#125;</span><br><span class="line">fn(1,2,3,4,5,6);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="spread-扩展运算符"><a href="#spread-扩展运算符" class="headerlink" title="spread 扩展运算符"></a>spread 扩展运算符</h2><ul>
<li>扩展运算符（spread）也是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列，对数组进行解包<ol>
<li>可以合并数组</li>
<li>可以克隆数组</li>
<li>将伪数组转为真正的数组<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 『...』 扩展运算符能将『数组』转换为逗号分隔的『参数序列』</span><br><span class="line">&#x2F;&#x2F;声明一个数组 ...</span><br><span class="line">const tfboys &#x3D; [&#39;易烊千玺&#39;,&#39;王源&#39;,&#39;王俊凯&#39;];</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &#39;易烊千玺&#39;,&#39;王源&#39;,&#39;王俊凯&#39;</span><br><span class="line">&#x2F;&#x2F; 声明一个函数</span><br><span class="line">function chunwan()&#123;</span><br><span class="line">    console.log(arguments);</span><br><span class="line">&#125;</span><br><span class="line">chunwan(...tfboys);&#x2F;&#x2F; chunwan(&#39;易烊千玺&#39;,&#39;王源&#39;,&#39;王俊凯&#39;)</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><ul>
<li>ES6 引入了一种新的原始数据类型 Symbol， 表示独一无二的值。它是JavaScript 语言的<strong>第七种</strong>数据类型，是一种类似于字符串的数据类型。<br>Symbol 特点<br>1)    Symbol 的值是唯一的，用来解决命名冲突的问题<br>2)    Symbol 值不能与其他数据进行运算<br>3)    Symbol 定义的对象属性不能使用 for…in 循环遍历， 但是可以使用<br>Reflect.ownKeys 来获取对象的所有键名</li>
<li>js数据类型：undefined string  symbol object null number boolean</li>
</ul>
<h2 id="Symbol-内置值"><a href="#Symbol-内置值" class="headerlink" title="Symbol 内置值"></a>Symbol 内置值</h2><ul>
<li>除了定义自己使用的 Symbol  值以外，ES6  还提供了11 个内置的Symbol 值，指向语言内部使用的方法。可以称这些方法为魔术方法，因为它们会在特定的场景下自动执行<br><img src="/2020/07/14/ES6-ES11/symbol%E5%86%85%E7%BD%AE%E5%80%BC.png" alt></li>
</ul>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><ul>
<li>遍历器（Iterator）就是一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作<br>1)    ES6 创造了一种新的遍历命令 for…of 循环，Iterator 接口主要供 for…of 消费<br>2)    原生具备 iterator 接口的数据(可用 for of 遍历)<ul>
<li>Array</li>
<li>Arguments</li>
<li>Set</li>
<li>Map</li>
<li>String</li>
<li>TypedArray</li>
<li>NodeList<br>3)    工作原理</li>
<li>创建一个指针对象，指向当前数据结构的起始位置</li>
<li>第一次调用对象的 next 方法，指针自动指向数据结构的第一个成员</li>
<li>接下来不断调用 next 方法，指针一直往后移动，直到指向最后一个成员</li>
<li>每调用 next 方法返回一个包含 value 和 done 属性的对象</li>
</ul>
</li>
<li>注: 需要自定义遍历数据的时候，要想到迭代器</li>
</ul>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><ul>
<li>生成器函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function * gen()&#123;</span><br><span class="line">yield &#39;一只没有耳朵&#39;;</span><br><span class="line">yield &#39;一只没有尾巴&#39;; return &#39;真奇怪&#39;;</span><br><span class="line">&#125;</span><br><span class="line">let iterator &#x3D; gen(); console.log(iterator.next()); console.log(iterator.next());</span><br><span class="line">console.log(iterator.next());</span><br></pre></td></tr></table></figure>
代码说明：<br>1)    *的位置没有限制<br>2)    生成器函数返回的结果是迭代器对象，调用迭代器对象的 next 方法可以得到<br>yield 语句后的值<br>3)    yield 相当于函数的暂停标记，也可以认为是函数的分隔符，每调用一次 next<br>方法，执行一段代码<br>4)    next 方法可以传递实参，作为 yield 语句的返回值</li>
</ul>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><ul>
<li>Promise 是 ES6 引入的异步编程的新解决方案。语法上Promise 是一个构造函数， 用来封装异步操作并可以获取其成功或失败的结果。<br>1)    Promise 构造函数: Promise (excutor) {}<ul>
<li>promise (function(resolve,reject){});<br>2)    Promise.prototype.then 方法</li>
<li>then(function(){value},function(reason){})</li>
<li>调用 then 方法  then方法的返回结果是 Promise 对象, 对象状态由回调函数的执行结果决定<ul>
<li>如果回调函数中返回的结果是 非 promise 类型的属性, 状态为成功, 返回值为对象的成功的值</li>
<li>如果是promise对象，promise返回的对象的状态就决定了then方法返回的promise的状态<br>3)    Promise.prototype.catch 方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><ul>
<li>ES6 提供了新的数据结构 Set（集合）。它类似于数组，但成员的值都是唯一的，集合实现了 iterator 接口，所以可以使用『扩展运算符』和『for…of…』进行遍历，集合的属性和方法：<br>1)    size    返回集合的元素个数<br>2)    add    增加一个新元素，返回当前集合<br>3)    delete    删除元素，返回 boolean 值<br>4)    has    检测集合中是否包含某个元素，返回 boolean 值<br>5)    clear    清空集合，返回 undefined</li>
</ul>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><ul>
<li>ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合。但是“键” 的范围不限于字符串，各种类型的值（包括对象）都可以当作键。Map 也实现了iterator 接口，所以可以使用『扩展运算符』和『for…of…』进行遍历。Map 的属性和方法：<br>1)    size    返回 Map 的元素个数<br>2)    set    增加一个新元素，返回当前 Map<br>3)    get    返回键名对象的键值<br>4)    has    检测 Map 中是否包含某个元素，返回 boolean 值<br>5)    clear    清空集合，返回 undefined</li>
</ul>
<h2 id="class-类"><a href="#class-类" class="headerlink" title="class 类"></a>class 类</h2><ul>
<li>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过 class 关键字，可以定义类。基本上，ES6 的 class 可以看作只是一个语法塘，它的绝大部分功能，ES5 都可以做到，新的 class 写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。<br>知识点：<br>1)    class 声明类<br>2)    constructor 定义构造函数初始化<br>3)    extends 继承父类<br>4)    super 调用父级构造方法<br>5)    static 定义静态方法和属性<br>6)    父类方法可以重写</li>
</ul>
<h2 id="数值扩展"><a href="#数值扩展" class="headerlink" title="数值扩展"></a>数值扩展</h2><ol>
<li><p>Number.EPSILON 是 JavaScript 表示的最小精度</p>
<ul>
<li>0.1+0.2===0.3不成立，因为浮点数运算是由误差的</li>
<li>EPSILON 属性的值接近于 2.2204460492503130808472633361816E-16</li>
<li>用EPSILON表示js运算的最小精确度</li>
</ul>
</li>
<li><p>二进制和八进制</p>
<ul>
<li>ES6 提供了二进制和八进制数值的新的写法，分别用前缀 0b 和 0o 表示</li>
</ul>
</li>
<li><p>Number.isFinite() 与 Number.isNaN()</p>
<ul>
<li>Number.isFinite() 用来检查一个数值是否为有限的</li>
<li>Number.isNaN() 用来检查一个值是否为 NaN</li>
</ul>
</li>
<li><p>Number.parseInt() 与 Number.parseFloat()字符串转整数</p>
<ul>
<li>ES6 将全局方法 parseInt 和 parseFloat，移植到 Number 对象上面，使用不变</li>
</ul>
</li>
<li><p>Math.trunc</p>
<ul>
<li>用于去除一个数的小数部分，返回整数部分</li>
</ul>
</li>
<li><p>Number.isInteger</p>
<ul>
<li>Number.isInteger() 用来判断一个数值是否为整数</li>
</ul>
</li>
<li><p>Math.sign </p>
<ul>
<li>判断一个数到底为正数 负数 还是零</li>
</ul>
</li>
</ol>
<h2 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h2><ul>
<li>ES6 新增了一些 Object 对象的方法<br>1)    Object.is比较两个值是否严格相等，与『===』行为基本一致（+0 与 NaN）<br>2)    Object.assign 对象的合并，将源对象的所有可枚举属性，复制到目标对象<br>3)    proto 、setPrototypeOf、 setPrototypeOf 可以直接设置对象的原型</li>
</ul>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><ul>
<li>模块化是指将一个大的程序文件，拆分成许多小的文件，然后将小文件组合起来。</li>
</ul>
<p>1.模块化的好处</p>
<ul>
<li>模块化的优势有以下几点：<br>1)    防止命名冲突<br>2)    代码复用<br>3)    高维护性</li>
</ul>
<ol start="2">
<li>模块化规范产品</li>
</ol>
<ul>
<li>ES6 之前的模块化规范有：<br>1) CommonJS    =&gt;    NodeJS、Browserify<br>2) AMD    =&gt;    requireJS<br>3) CMD    =&gt;    seaJS</li>
</ul>
<ol start="3">
<li>ES6 模块化语法</li>
</ol>
<ul>
<li>模块功能主要由两个命令构成：export 和 import<ul>
<li>export 命令用于规定模块的对外接口</li>
<li>import 命令用于输入其他模块提供的功能<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import:</span><br><span class="line">1. 通用的导入方式</span><br><span class="line">引入 m1.js 模块内容</span><br><span class="line">import * as m1 from &quot;.&#x2F;src&#x2F;js&#x2F;m1.js&quot;;</span><br><span class="line">&#x2F;&#x2F;引入 m2.js 模块内容</span><br><span class="line">import * as m2 from &quot;.&#x2F;src&#x2F;js&#x2F;m2.js&quot;;</span><br><span class="line">&#x2F;&#x2F;引入 m3.js </span><br><span class="line">import * as m3 from &quot;.&#x2F;src&#x2F;js&#x2F;m3.js&quot;;</span><br><span class="line"></span><br><span class="line">2. 解构赋值形式</span><br><span class="line">import &#123;school, teach&#125; from &quot;.&#x2F;src&#x2F;js&#x2F;m1.js&quot;;</span><br><span class="line">import &#123;school as guigu, findJob&#125; from &quot;.&#x2F;src&#x2F;js&#x2F;m2.js&quot;;</span><br><span class="line">import &#123;default as m3&#125; from &quot;.&#x2F;src&#x2F;js&#x2F;m3.js&quot;;</span><br><span class="line"></span><br><span class="line">3. 简便形式  针对默认暴露</span><br><span class="line">import m3 from &quot;.&#x2F;src&#x2F;js&#x2F;m3.js&quot;;</span><br><span class="line">console.log(m3);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export:</span><br><span class="line">&#x2F;&#x2F;分别暴露</span><br><span class="line">export let school &#x3D; &#39;xxx&#39;;</span><br><span class="line">export function teach() &#123;</span><br><span class="line">    console.log(&quot;xxx&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;统一暴露</span><br><span class="line">let school &#x3D; &#39;xxx&#39;;</span><br><span class="line">function teach()&#123;</span><br><span class="line">    console.log(&quot;xxx&quot;);</span><br><span class="line">&#125;</span><br><span class="line">export &#123;school, teach&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;默认暴露</span><br><span class="line">export default &#123;</span><br><span class="line">    school: &#39;xxx&#39;,</span><br><span class="line">    teach: function()&#123;</span><br><span class="line">        console.log(&quot;xxx&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h1 id="ES7"><a href="#ES7" class="headerlink" title="ES7"></a>ES7</h1><ol>
<li><p>Array.includes()</p>
<ul>
<li>Includes 方法用来检测数组中是否包含某个元素，返回布尔类型值</li>
</ul>
</li>
<li><p>指数操作符</p>
<ul>
<li>在 ES7 中引入指数运算符「**」，用来实现幂运算，功能与 Math.pow 结果相同</li>
</ul>
</li>
</ol>
<h1 id="ES8"><a href="#ES8" class="headerlink" title="ES8"></a>ES8</h1><ol>
<li><p>async 和 await</p>
<ul>
<li>async 和 await 两种语法结合可以让异步代码像同步代码一样</li>
</ul>
<ol>
<li>async 函数<ul>
<li>async 函数的返回值为 promise 对象，</li>
<li>promise 对象的结果由 async 函数执行的返回值决定</li>
</ul>
</li>
<li>await 表达式<ul>
<li>await 必须写在 async 函数中</li>
<li>await 右侧的表达式一般为 promise 对象</li>
<li>await 返回的是 promise 成功的值</li>
<li>await 的 promise 失败了, 就会抛出异常, 需要通过 try…catch 捕获处理</li>
</ul>
</li>
</ol>
</li>
<li><p>Object.values 和 Object.entries</p>
<ul>
<li>Object.values()方法返回一个给定对象的所有可枚举属性值的数组</li>
<li>Object.entries()方法返回一个给定对象自身可遍历属性 [key,value] 的数组</li>
</ul>
</li>
<li><p>Object.getOwnPropertyDescriptors</p>
<ul>
<li>该方法返回指定对象所有自身属性的描述对象</li>
</ul>
</li>
</ol>
<h1 id="ES9"><a href="#ES9" class="headerlink" title="ES9"></a>ES9</h1><ol>
<li>Rest/Spread 属性</li>
</ol>
<ul>
<li>Rest 参数与 spread 扩展运算符在 ES6 中已经引入，不过 ES6 中只针对于数组,在 ES9 中为对象提供了像数组一样的 rest 参数和扩展运算符<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function connect(&#123;host, port, ...user&#125;) &#123;</span><br><span class="line">console.log(host);</span><br><span class="line">console.log(port); </span><br><span class="line">console.log(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">connect(&#123;</span><br><span class="line">host: &#39;127.0.0.1&#39;,</span><br><span class="line">port: 3306, </span><br><span class="line">username: &#39;root&#39;, </span><br><span class="line">password: &#39;root&#39;, </span><br><span class="line">type: &#39;master&#39;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="2">
<li>正则表达式命名捕获组</li>
</ol>
<ul>
<li>ES9 允许命名捕获组对捕获的结果进行命名,这样获取捕获结果可读性更强<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let str &#x3D; &#39;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.atguigu.com&quot;&gt;&lt;&#x2F;a&gt;&#39;; </span><br><span class="line">const reg &#x3D; &#x2F;&lt;a href&#x3D;&quot;(?&lt;url&gt;.*)&quot;&gt;(?&lt;text&gt;.*)&lt;\&#x2F;a&gt;&#x2F;;</span><br><span class="line"></span><br><span class="line">const result &#x3D; reg.exec(str);</span><br><span class="line"></span><br><span class="line">console.log(result.groups.url);	</span><br><span class="line"></span><br><span class="line">console.log(result.groups.text);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="3">
<li>正则表达式反向断言</li>
</ol>
<ul>
<li>ES9 支持反向断言，通过对匹配结果前面的内容进行判断，对匹配进行筛选<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;声明字符串</span><br><span class="line">let str &#x3D; &#39;JS5211314 你知道么 555 啦啦啦&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;正向断言</span><br><span class="line">const reg &#x3D; &#x2F;\d+(?&#x3D;啦)&#x2F;;</span><br><span class="line">const result &#x3D; reg.exec(str);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;反向断言</span><br><span class="line">const reg &#x3D; &#x2F;(?&lt;&#x3D;么)\d+&#x2F;;</span><br><span class="line">const result &#x3D; reg.exec(str);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="4">
<li>正则表达式 dotAll 模式</li>
</ol>
<ul>
<li>正则表达式中点 . 匹配除回车外的任何单字符，标记『s』改变这种行为，允许行终止符出现</li>
</ul>
<h1 id="ES10"><a href="#ES10" class="headerlink" title="ES10"></a>ES10</h1><ol>
<li>Object.fromEntries<ul>
<li>将二维数组转化为对象，与entries作用相反</li>
</ul>
</li>
<li>trimStart 和 trimEnd<ul>
<li>trimStart负责清除字符串左侧空白</li>
<li>trimEnd负责清除字符串右侧空白</li>
</ul>
</li>
<li>Array.flat() 与 flatMap<ul>
<li>flat()将多维数组转化为低维数组</li>
<li>flatMap把Map的结果做一个维度降低，是flat和map操作的结合体</li>
</ul>
</li>
<li>Symbol.prototype.description<ul>
<li>获取symbol的描述字符串</li>
</ul>
</li>
</ol>
<h1 id="ES11"><a href="#ES11" class="headerlink" title="ES11"></a>ES11</h1><ol>
<li><p>类的私有属性</p>
<ul>
<li>私有属性前要加#</li>
</ul>
</li>
<li><p>String.prototype.matchAll</p>
<ul>
<li>用来得到正则批量匹配的结果</li>
</ul>
</li>
<li><p>Promise.allSettled</p>
<ul>
<li>接受一个promise数组，返回一个成功的结果，成功的值是每一个promise对象的状态和结果</li>
</ul>
</li>
<li><p>可选链操作符?.</p>
<ul>
<li>xxx1?.xxx2?.xxx3如果有xxx1才会读取后面的xxx2以此类推</li>
</ul>
</li>
<li><p>动态 import 导入</p>
</li>
<li><p>globalThis 对象</p>
<ul>
<li>始终指向全局对象 </li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>规范集成</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>ES11</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript</title>
    <url>/2020/07/07/JavaScript/</url>
    <content><![CDATA[<blockquote>
<p>序<br><br>终于开始学前端的核心内容了！学好JS才能为后面的jQuery( JavaScript库)和JS框架(React,Vue,Angular)打好基础，冲冲冲！</p>
</blockquote>
<a id="more"></a>
<h1 id="js基本语法"><a href="#js基本语法" class="headerlink" title="js基本语法"></a>js基本语法</h1><h2 id="引入js"><a href="#引入js" class="headerlink" title="引入js"></a>引入js</h2><ul>
<li>可以编写到标签的onclick属性中，也可以写在标签的属性中，但是他们属于行为和结构耦合，不方便维护，不推荐<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button onclick&#x3D;&quot;alert(&#39;xxx&#39;)&quot;&gt;&lt;&#x2F;button&gt;</span><br><span class="line">&lt;a href&#x3D;&quot;javascript:alert(&#39;xxx&#39;)&quot;&gt;&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure></li>
<li>可以写在标签或者外部文件中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>js标签一旦引入外部文件了，就不能再编码了，即使编写了浏览器也会忽略；如果需要则可以再创建一个新的script标签用于编写内部代码，执行顺序按从上至下依次执行。</li>
</ul>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><ul>
<li>在js中所有的可以由我们自主命名的都可以成为标识符</li>
<li>例如：变量名，函数名，属性名等等</li>
<li>命名一个标识符需要遵守如下规则：<ol>
<li>标识符可以包含字母，数字，_，$</li>
<li>标识符不能以数字开头</li>
<li>标识符不能是关键字和保留字</li>
</ol>
</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li>数据类型</li>
</ul>
<p>String，Number，Boolean，Null，Undefined，Object(object不属于基本数据类型)</p>
<ul>
<li><p>数组</p>
<blockquote>
<p>用方括号书写，数组的项目由逗号分隔。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">下面的代码声明（创建）了名为 cars 的数组，包含三个项目（汽车品牌）：</span><br><span class="line">var cars &#x3D; [&quot;Porsche&quot;, &quot;Volvo&quot;, &quot;BMW&quot;];</span><br></pre></td></tr></table></figure>
</li>
<li><p>typeof 运算符</p>
</li>
</ul>
<p>可使用typeof 来确定 JavaScript 变量的类型,typeof<br>运算符返回变量或表达式的类型</p>
<ul>
<li>进制</li>
</ul>
<ol>
<li>表示16进制的数字，需要0x开头</li>
<li>表示8进制的数字，需要0开头</li>
<li>表示2进制的数字，需要0b开头</li>
</ol>
<ul>
<li><p>强制转换</p>
<ol>
<li><p>将其他数据类型转换为String</p>
<ul>
<li>方法一：调用被转换数据类型的toString()方法</li>
<li>该方法不影响原变量，他会将转换的结果返回</li>
<li>但是注意null和undefined这两个值没有toString()方法，会报错</li>
<li>方法二：调用String()函数，并将被转换的数据作为参数传递给函数</li>
<li>使用String()函数强制转换时，对于Number和Boolean实际上就是调用toString()方法，但是对于null和undefined就会将他们转换为字符串”null”和”undefined”</li>
</ul>
</li>
<li><p>将其他数据类型转换为Number</p>
<ul>
<li>方法一：使用Number()函数</li>
<li>如果字符串中有非数字的内容，则转换为NaN</li>
<li>如果字符串是空或者是全空格，则转换为0</li>
<li>方法二：这种方法专用于字符串</li>
<li>parseInt()把一个字符串转换为一个整数<br>//将一个字符串中的有效内容的整数内容读取出来转换为Number</li>
<li>parseFloat()把一个字符串转换为一个浮点数//将一个字符串中的有效内容的小数内容读取出来转换为Number</li>
<li>可以用一元的+来进行隐式的类型转换</li>
</ul>
</li>
<li><p>将其他数据类型转换为Boolean</p>
<ul>
<li><p>使用Boolean()函数</p>
<ul>
<li>数字-&gt;布尔(除了0和NaN，其余都是true)</li>
<li>字符串-&gt;布尔(除了空串，其余都是true)</li>
<li>null和undefined都会转换为false</li>
<li>对象也会转换为true</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul>
<li><p>逻辑运算符</p>
<ul>
<li><p>!</p>
<p>非运算可以对一个布尔值进行取反，true变false false边true<br>当对非布尔值使用!时，会先将其转换为布尔值然后再取反<br>我们可以利用!来将其他的数据类型转换为布尔值</p>
</li>
<li><p>&amp;&amp;</p>
<p>&amp;&amp;可以对符号两侧的值进行与运算<br>只有两端的值都为true时，才会返回true。只要有一个false就会返回false。<br>与是一个短路的与，如果第一个值是false，则不再检查第二个值<br>对于非布尔值，它会将其转换为布尔值然后做运算，并返回原值<br>规则：</p>
</li>
</ul>
<p>1.如果第一个值为false，则返回第一个值<br> 2.如果第一个值为true，则返回第二个值</p>
<ul>
<li><p>||</p>
<p>||可以对符号两侧的值进行或运算<br>只有两端都是false时，才会返回false。只要有一个true，就会返回true。<br>或是一个短路的或，如果第一个值是true，则不再检查第二个值<br>对于非布尔值，它会将其转换为布尔值然后做运算，并返回原值<br>规则：1. 如果第一个值为true，则返回第一个值2.<br>如果第一个值为false，则返回第二个值</p>
</li>
</ul>
</li>
</ul>
<h2 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h2><ul>
<li>break关键字可以用来退出switch或循环语句</li>
<li>不能在if语句中使用break和continue</li>
<li>break关键字，会立即终止离他最近的那个循环语句</li>
<li>continue可以跳过当次循环</li>
</ul>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><blockquote>
<p>对象属于一种复合的数据类型，在对象中可以保存多个不同数据类型的属性</p>
</blockquote>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ol>
<li>内建对象</li>
</ol>
<ul>
<li>由ES标准中定义的对象，在任何的ES的实现中都可以使用</li>
<li>比如：Math String Number Boolean Function Object…</li>
</ul>
<ol start="2">
<li>宿主对象</li>
</ol>
<ul>
<li>由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象</li>
<li>比如：BOM DOM</li>
</ul>
<ol start="3">
<li>自定义对象</li>
</ol>
<ul>
<li><p>由开发人员自己创建的对象</p>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2></li>
</ul>
<ol>
<li>方法一<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; new Object();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>基本数据类型的数据，变量是直接保存的它的值。</li>
<li>变量与变量之间是互相独立的，修改一个变量不会影响其他的变量。</li>
<li>引用数据类型的数据，对象是保存在堆内存中的，每创建一个新对象，就会在堆内存中开辟一个新的空间，而变量保存的是对象的内存地址，如果两个变量保存的是同一个对象引用，当我们通过一个变量修改属性时，另一个也会受到影响</li>
<li>当两个引用数据类型比较时，比较的是对象的内存地址</li>
</ul>
<ol start="2">
<li>方法二<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; &#123;&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>使用对象字面量可以在创建对象的时候，直接指定对象中的属性</li>
<li>语法：{属性名：属性值，属性名：属性值，···}//要是属性名过于特殊，则要加引号</li>
</ul>
<ol start="3">
<li><p>向对象中添加属性</p>
<ul>
<li>语法：对象.属性名=属性值;</li>
<li>对象[“属性名”] = 属性值; 这种方式能够使用特殊的属性名</li>
<li>对象的属性名没有任何要求，不需要遵守标识符的规范，但是在开发中，尽量按照标识符的要求去写。属性值也可以任意的数据类型。</li>
</ul>
</li>
<li><p>读取对象中的属性</p>
<ul>
<li>语法：对象.属性名</li>
<li>对象[“属性名”] ;“属性名”可以使字符串常量，也可以是字符串变量</li>
<li>如果读取一个对象中没有的属性，它不会报错，而是返回一个undefined</li>
</ul>
</li>
<li><p>修改对象中的属性</p>
<ul>
<li>语法：对象.属性值=新值</li>
</ul>
</li>
<li><p>删除对象中的属性</p>
<ul>
<li><p>语法：delete 对象.属性名</p>
<pre><code>delete 对象[&quot;属性名&quot;]</code></pre></li>
</ul>
</li>
</ol>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><blockquote>
<p>函数也是一个对象，函数主要用来封装一些功能</p>
</blockquote>
<ol>
<li><p>创建函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">函数声明</span><br><span class="line">function 函数名(形参1,形参2...形参N)</span><br><span class="line">&#123;  </span><br><span class="line">语句...  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">函数表达式：将要封装的代码以字符串的形式传递给构造函数</span><br><span class="line">var 函数名 &#x3D; function(形参1,形参2...形参N)</span><br><span class="line">&#123;  </span><br><span class="line">语句...  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>立即执行函数</p>
<ul>
<li>函数定义完，立即被调用，这种函数叫做立即执行函数</li>
<li>立即执行函数往往只会执行一次<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function(a,b)&#123;  </span><br><span class="line">console.log(&quot;a &#x3D; &quot;+a);  </span><br><span class="line">console.log(&quot;b &#x3D; &quot;+b);  </span><br><span class="line">&#125;)(123,456);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>枚举对象中的属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">for(var 变量 in 对象)&#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><ol>
<li><p>全局作用域</p>
<ul>
<li>直接在script标签中编写的代码都运行在全局作用域中</li>
<li>全局作用域在页面打开时创建，在页面关闭时销毁</li>
<li>在全局作用域中有一个全局对象window，他代表的是一个浏览器的窗口，他由浏览器创建时我们可以直接使用</li>
<li>在全局作用域中创建的变量都会作为window对象的属性保存</li>
<li>在全局作用域中创建的函数都会作为window对象的方法保存</li>
<li>在全局作用域中创建的变量和函数可以在页面的任意位置访问</li>
<li>在函数作用域中也可以访问到全局作用域的变量</li>
</ul>
</li>
<li><p>函数作用域</p>
<ul>
<li>调用函数时创建函数作用域，函数执行完毕后，函数作用域销毁</li>
<li>每调用一个函数就会创建一个新的函数作用域，他们之间是相互独立的</li>
<li>在函数作用域中可以访问到全局作用域的变量</li>
<li>在全局作用域中无法访问到函数作用域的变量</li>
<li>当在函数作用域中操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用，如果没有就向上一级的作用域中寻找，直到找到全局作用域，若全局作用域中还没有，则会报错</li>
</ul>
</li>
<li><p>变量的声明提前</p>
<ul>
<li>在全局作用域中，使用var关键字声明的变量会在所有代码执行前被声明(但是不会被赋值)，但是如果声明变量不使用var关键字，则变量不会被声明提前</li>
<li>在函数作用域中，也具有同上特性，使用var关键字声明的变量会在函数所有的代码执行前被声明，如果没有使用var关键字声明变量，则变量会变成全局变量</li>
</ul>
</li>
<li><p>函数的声明提前</p>
<ul>
<li>使用函数声明形式创建的函数function<br>函数名(){},他会在所有代码执行前被创建，所以我们可以在函数声明前调用函数；使用函数表达式(var<br>fun = function(){})创建的函数没有该特性</li>
<li>在函数作用域中，使用函数声明创建的函数，会在所有的函数中的代码执行之前就被创建好了</li>
</ul>
</li>
</ol>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><blockquote>
<p>我们每次调用函数时，解析器都会将一个上下文对象作为隐含的参数传递进函数。<br>使用this来引用上下文对象，根据函数的调用形式不同，this的值也不同。</p>
</blockquote>
<ul>
<li>this的不同的情况：<ol>
<li>以函数的形式调用时，this是window</li>
<li>以方法的形式调用时，this就是调用方法的对象</li>
<li>以构造函数的形式调用时，this就是新创建的对象</li>
<li>在事件的响应函数中，响应函数是给谁绑定的this，那么这个this就是谁</li>
</ol>
</li>
</ul>
<p>##构造函数 </p>
<ul>
<li>一个构造函数我们也可以称为一个类</li>
<li>通过一个构造函数创建的对象，我们称该对象时这个构造函数的实例</li>
<li>可以用 instanceof 用来检查一个对象是否是一个类的实例</li>
<li>通过同一个构造函数创建的对象，我们称为一类对象</li>
<li>构造函数就是一个普通的函数，只是他的调用方式不同，如果直接调用，它就是一个普通函数，如果使用new来调用，则它就是一个构造函数</li>
<li>构造函数的执行流程：<ol>
<li>创建一个新的对象</li>
<li>将新建的对象设置为函数中的this，在构造函数中用this来引用新建的对象</li>
<li>执行函数中的代码</li>
<li>将新建的对象返回<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eg:</span><br><span class="line"></span><br><span class="line">function Person(name , age , gender)&#123;  </span><br><span class="line">this.name &#x3D; name;  </span><br><span class="line">this.age &#x3D; age;  </span><br><span class="line">this.gender &#x3D; gender;  </span><br><span class="line">this.sayName &#x3D; function()&#123;  </span><br><span class="line">alert(this.name);  </span><br><span class="line">&#125;;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h2 id="原型-prototype"><a href="#原型-prototype" class="headerlink" title="原型-prototype"></a>原型-prototype</h2><ul>
<li><p>我们所创建的每一个函数，解析器都会像函数中添加一个属性prototype</p>
</li>
<li><p>prototype属性指向的是一个对象，这个对象我们称为原型对象</p>
</li>
<li><p>当函数作为构造函数使用，<strong>它所创建的对象中都会有一个隐含的属性执行该原型对象</strong>，并且这个隐含的属性可以通过对象.<strong>proto</strong>来访问</p>
</li>
<li><p>当我们访问对象的一个属性或者是方法是，他会先在对象自身中寻找，如果有就直接使用；如果没有就回去原型对象中寻找，找到则直接使用</p>
</li>
<li><p>原型对象就相当于一个公共的区域，凡是通过同一个构造函数创建的对象他们通常都可以访问到相同的原型对象</p>
</li>
<li><p>举例：<br><img src="/2020/07/07/JavaScript/js%E5%8E%9F%E5%9E%8B.png" alt></p>
</li>
<li><p><strong>作用：如果将构造函数中的函数定义在全局作用域中，污染了全局作用域的命名空间，而且定义在全局作用域中很不安全，所以我们可以将对象共有的属性和方法放在原型对象中，这样既不用分别为每一个对象添加，也不会影响全局作用域，就可以使每个对啊ing都具有这些属性和方法了</strong></p>
</li>
<li><p>hasOwnProperty()</p>
<blockquote>
<p>这个方法可以用来检查对象自身中是否含有某个属性</p>
<blockquote>
<p>语法：对象.hasOwnProperty(“属性名”)</p>
</blockquote>
</blockquote>
</li>
<li><p>原型也是对象，所以他也有原型</p>
<blockquote>
<p>当我们使用一个对象或方法时，会先在自身中寻找，自身要是有就直接使用</p>
<blockquote>
<p>如果自身没有就去原型对象中寻找，如果有就直接使用</p>
<blockquote>
<p>如果原型对象中还没有，就去原型的原型中去寻找，直到找到object对象（object没有以原型），如果还没找到就返回undefined\</p>
<p><img src="/2020/07/07/JavaScript/%E5%8E%9F%E5%9E%8B%E7%9A%84%E5%8E%9F%E5%9E%8B.png" alt></p>
</blockquote>
</blockquote>
</blockquote>
</li>
</ul>
<h2 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h2><ul>
<li><p>当我们直接在页面中打印一个对象时，事实上是输出的对象的toString()方法的返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;修改Person原型的toString方法的返回值  </span><br><span class="line">Person.prototype.toString &#x3D; function()&#123;  </span><br><span class="line">return &quot;Person[name&#x3D;&quot;+this.name+&quot;,age&#x3D;&quot;+this.age+&quot;,gender&#x3D;&quot;+this.gender+&quot;]&quot;;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2></li>
<li><p>就像人生活的时间长了会产生垃圾一样，程序运行过程中也会产生垃圾,这些垃圾积攒过多以后，会导致程序运行的速度过慢，所以我们需要一个垃圾回收的机制，来处理程序运行过程中产生垃圾</p>
</li>
<li><p>当一个对象没有任何的变量或属性对它进行引用，此时我们将永远无法操作该对象，此时这种对象就是一个垃圾，这种对象过多会占用大量的内存空间，导致程序运行变慢，所以这种垃圾必须进行清理。</p>
</li>
<li><p>在JS中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁，我们不需要也不能进行垃圾回收的操作，<strong>我们需要做的只是要将不再使用的对象设置null即可</strong></p>
</li>
</ul>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><ul>
<li>数组也是一个对象，是一个用来存储数据的对象和Object类似，但是它的存储效率比普通对象要高，数组中保存的内容我们称为元素</li>
</ul>
<h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方法一：</span><br><span class="line">var arr &#x3D; new Array();  </span><br><span class="line">arr[0] &#x3D; 123;  </span><br><span class="line">arr[1] &#x3D; &quot;hello&quot;;</span><br><span class="line">方法二：</span><br><span class="line">var arr &#x3D; [123,&quot;hello&quot;];</span><br></pre></td></tr></table></figure></code></pre><h2 id="数组的方法"><a href="#数组的方法" class="headerlink" title="数组的方法"></a>数组的方法</h2><table>
<thead>
<tr>
<th>FunctionName</th>
<th>Function</th>
</tr>
</thead>
<tbody><tr>
<td>push()</td>
<td>用来向数组的末尾添加一个或多个元素，并返回数组新的长度\</td>
</tr>
<tr>
<td>pop()</td>
<td>用来删除数组的最后一个元素，并返回被删除的元素\</td>
</tr>
<tr>
<td>unshift()</td>
<td>向数组的开头添加一个或多个元素，并返回数组的新的长度\</td>
</tr>
<tr>
<td>shift()</td>
<td>删除数组的开头的一个元素，并返回被删除的元素\</td>
</tr>
<tr>
<td>slice(start,end)</td>
<td>可以从一个数组中截取指定的元素，该方法不会影响原数组，而是将截取到的内容封装为一个新的数组并返回\</td>
</tr>
<tr>
<td>splice()</td>
<td>可以用来删除数组中指定元素，并使用新的元素替换，该方法会将删除的元素封装到新数组中返回，第三个及以后，都是替换的元素，这些元素将会插入到开始位置索引的前边\</td>
</tr>
<tr>
<td>concat()</td>
<td>可以连接两个或多个数组，它不会影响原数组，而是连接数组作为返回值返回\</td>
</tr>
<tr>
<td>join()</td>
<td>可以将一个数组转换为一个字符串,它不会影响原数组，而是转换后的数组作为返回值返回\</td>
</tr>
<tr>
<td>reverse()</td>
<td>可以用来反转一个数组，它会对原数组产生影响\</td>
</tr>
<tr>
<td>sort()</td>
<td>可以对一个数组中的内容进行排序，默认是按照Unicode编码进行排序，他会对原数组产生影响，我们可以自己来指定排序的规则我们可以在sort()添加一个回调函数【数组.sort(functiom(a,b){});】，来指定排序规则，回调函数中需要定义两个形参</td>
</tr>
<tr>
<td>filter()</td>
<td>filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。</td>
</tr>
</tbody></table>
<h2 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h2><ol>
<li><p>用for循环来遍历数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方法一：</span><br><span class="line">for(var i&#x3D;0 ; i&lt;数组.length ; i++)&#123;  </span><br><span class="line">    &#x2F;&#x2F;数组[i]  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用forEach()方法来遍历数组（不兼容IE8）</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数组.forEach(function(value , index , obj)&#123;  </span><br><span class="line">  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">value:正在遍历的元素</span><br><span class="line">index:正在遍历元素的索引</span><br><span class="line">obj:被遍历对象</span><br></pre></td></tr></table></figure>

<ul>
<li>forEach()方法需要一个回调函数作为参数，<br>数组中有几个元素，回调函数就会被调用几次，<br>每次调用时，都会将遍历到的信息以实参的形式传递进来，<br>我们可以定义形参来获取这些信息</li>
</ul>
<h1 id="常用类和方法"><a href="#常用类和方法" class="headerlink" title="常用类和方法"></a>常用类和方法</h1><h2 id="call-和apply"><a href="#call-和apply" class="headerlink" title="call-和apply"></a>call-和apply</h2><ul>
<li>这两个方法都是函数对象的方法，需要通过函数对象调用</li>
<li>当对函数调用call()和apply()都会调用函数执行</li>
<li>在调用call()和apply()可以将一个对象指定为第一个参数，此时这个对象将会成为函数执行时的this</li>
<li>call()方法可以将实参在对象之后一次传递</li>
<li>apply()方法需要将实参封装到一个数组中统一传递</li>
</ul>
<h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><ul>
<li>arguments是一个类数组对象，它可以通过索引来操作数据，也可以获取长度</li>
<li>在调用函数是，我们所传递的实参都会在arguments中保存</li>
<li>arguements.length可以用来获取实参长度</li>
<li>还可以用arguements来使用实参，arguements[0]表示第一个实参，arguements[1]表示第二个实参···</li>
<li>它里面有一个属性交callee，这个属性对应一个函数对象，就是当前正在指向的函数对象</li>
</ul>
<h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><ul>
<li><p>日期的对象，在JS中通过Date对象来表示一个时间</p>
</li>
<li><p>如果直接用构造函数创建一个Date对象，则封装为当前代码执行的时间</p>
</li>
<li><p>创建对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">创建一个当前的时间对象</span><br><span class="line">var d &#x3D; new Date();</span><br><span class="line"></span><br><span class="line">创建一个指定的时间对象</span><br><span class="line">var d &#x3D; new Date(&quot;月&#x2F;日&#x2F;年 时:分:秒&quot;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法</p>
<table>
<thead>
<tr>
<th>name</th>
<th>function</th>
</tr>
</thead>
<tbody><tr>
<td>getDate()</td>
<td>当前日期对象是几日（1-31）</td>
</tr>
<tr>
<td>getDay()</td>
<td>返回当前日期对象时周几（0-6），0 周日，1 周一 ···</td>
</tr>
<tr>
<td>getMonth()</td>
<td>返回当前日期对象的月份（0-11），0 一月， 1 二月 ···</td>
</tr>
<tr>
<td>getFullYear()</td>
<td>从 Date 对象以四位数字返回年份</td>
</tr>
<tr>
<td>getHours()</td>
<td>返回 Date 对象的小时 (0 ~ 23)</td>
</tr>
<tr>
<td>getMinutes()</td>
<td>返回 Date 对象的分钟 (0 ~ 59)</td>
</tr>
<tr>
<td>getSeconds()</td>
<td>返回 Date 对象的秒数 (0 ~ 59)</td>
</tr>
<tr>
<td>getMilliseconds()</td>
<td>返回 Date 对象的毫秒(0 ~ 999)</td>
</tr>
<tr>
<td>getTime()</td>
<td>返回当前日期对象的时间戳，时间戳，指的是从1970年月1日 0时0分0秒，到现在时间的毫秒数，计算机底层保存时间都是以时间戳的形式保存的</td>
</tr>
<tr>
<td>Date.now()</td>
<td>可以获取当前代码执行时的时间戳</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><ul>
<li><p>Math属于一个工具类，它不需要我们创建对象，它里边封装了属性运算相关的常量和方法,我们可以直接使用它来进行数学运算相关的操作</p>
</li>
<li><p>方法</p>
<p>name                   |              function</p>
</li>
<li><p>-|–<br> Math.PI                              |常量，圆周率<br> Math.abs()                          | 绝对值运算<br> Math.cell()                         | 向上取整<br> Math.floor()                        | 向下取整<br> Math.round()                        | 四舍五入取整<br> Math.random()                       | 生成一个01之间的随机数<br> Math.round(Math.random()*(y-x)+x)  | 生成一个xy之间的随机数<br> Math.pow(x,y)                       | 求x的y次幂<br> Math.sqrt()                         | 对一个数进行开方<br> Math.max()                          | 求多个数中最大值<br> Math.min()                          | 求多个数中的最小值</p>
</li>
</ul>
<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><ul>
<li><p>在JS中为我们提供了三个包装类，通过这三个包装类可以将基本的数据类型的数据转换为对象：<br>String() Boolean()<br>Number()通过这三个包装类可以创建基本数据类型的对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通过包装类创建基本数据类型的对象：</span><br><span class="line"></span><br><span class="line">var num &#x3D; new Number(2);  </span><br><span class="line">var str &#x3D; new String(&quot;hello&quot;);  </span><br><span class="line">var bool &#x3D; new Boolean(true);</span><br></pre></td></tr></table></figure>
</li>
<li><p>但是在实际应用中千万不要这么干。当我们去操作一个基本数据类型的属性和方法时，解析器会临时将其转换为对应的包装类，然后再去操作属性和方法，操作完成以后再将这个临时对象进行销毁</p>
</li>
</ul>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul>
<li><p>在底层字符串是以字符数组的形式保存的</p>
</li>
<li><p>方法</p>
<table>
<thead>
<tr>
<th>name</th>
<th>function</th>
</tr>
</thead>
<tbody><tr>
<td>length</td>
<td>获取字符串的长度</td>
</tr>
<tr>
<td>charAt()</td>
<td>根据索引获取指定的字符</td>
</tr>
<tr>
<td>charCodeAt()</td>
<td>根据索引获取指定的字符编码(Unicode编码)</td>
</tr>
<tr>
<td>String.fromCharCode()</td>
<td>根据字符编码获取字符</td>
</tr>
<tr>
<td>indexof()</td>
<td>可以检索一个字符串是否含有指定内容，需要一个字符串作为参数，这个字符串就是要检索的内容，如果找到该内容，则会返回其第一次出现的索引，如果没有找到则返回-1，可以指定一个第二个参数，来表示开始查找的位置</td>
</tr>
<tr>
<td>lastIndexOf()</td>
<td>功能同indexof，indexOf()是从前向后找，lastIndexOf()是从后向前找</td>
</tr>
<tr>
<td>slice(start,end)</td>
<td>可以从一个字符串中截取指定的内容，并将截取到内容返回，不会影响原变量，参数：第一个：截取开始的位置（包括开始），第二个：截取结束的位置（不包括结束）可以省略第二个参数，如果省略则一直截取到最后，可以传负数，如果是负数则从后往前数</td>
</tr>
<tr>
<td>substr()</td>
<td>和slice()基本一致，不同的是它第二个参数不是索引，而是截取的数量</td>
</tr>
<tr>
<td>substring()</td>
<td>和slice()基本一致，不同的是它不能接受负值作为参数，如果设置一个负值，则会自动修正为0，substring()中如果第二个参数小于第一个，自动调整位置</td>
</tr>
<tr>
<td>toLowerCase()</td>
<td>将字符串转换为小写并返回</td>
</tr>
<tr>
<td>toUpperCase()</td>
<td>将字符串转换为大写并返回</td>
</tr>
<tr>
<td>正则表达式相关方法:</td>
<td></td>
</tr>
<tr>
<td>split()</td>
<td>可以将一个字符串拆分成一个数组，方法中可以传一个正则表达式作为参数，这样方法就会根据正则表达式去拆分字符串</td>
</tr>
<tr>
<td>search()</td>
<td>可以搜索字符串中是否含有指定内容，如果搜索到指定内容，则会返回第一次出现的索引，如果没有则返回-1，它可以接受正则表达式作为参数，然后根据正则表达式去检索字符串,search只会查找第一个，即使设置全局匹配也没用</td>
</tr>
<tr>
<td>match()</td>
<td>可以根据正则表达式，从一个字符串中将符合条件的内容提取出来，默认情况下我们的match只会找到第一个符合要求的内容，找到以后就停止检索，我们可以设置正则表达式为全局匹配模式，这样就会匹配到所有的内容，可以为一个正则表达式设置多个匹配模式，且顺序无所谓，match()会将匹配到的内容封装到一个数组中返回，即使只查询到一个结果</td>
</tr>
<tr>
<td>replace()</td>
<td>可以将字符串中指定内容替换为新的内容,参数：1.被替换的内容，可以接受一个正则表达式作为参数2.新的内容；替换为””则为删除,默认只会替换第一个</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><ul>
<li><p>用于定义一些字符串的规则，计算机可以根据正则表达式来检查一个字符串是否符合规则，并将字符串中符合规则的内容提取出来</p>
</li>
<li><p>创建正则表达式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方法一：</span><br><span class="line">var reg &#x3D; new RegExp(“正则”,”匹配模式”); </span><br><span class="line"></span><br><span class="line">方法二：</span><br><span class="line">var reg &#x3D; &#x2F;正则表达式&#x2F;匹配模式; </span><br><span class="line">&#x2F;&#x2F;（匹配模式可以多个一起写：&#x2F;gi）</span><br><span class="line"></span><br><span class="line">匹配模式：</span><br><span class="line">i:忽略大小写（ignore）</span><br><span class="line">g:全局匹配模式（默认为1次）</span><br><span class="line">m:执行多行匹配</span><br><span class="line">设置匹配模式时，可以都不设置，也可以设置1个，也可以全设置，设置时没有顺序要求</span><br></pre></td></tr></table></figure>

<ul>
<li>test()<ul>
<li>语法：正则表达式.test(字符串)</li>
<li>可以用来检查一个字符串是否符合正则表达式，如果符合返回true，否则返回false</li>
</ul>
</li>
</ul>
</li>
<li><p>正则语法</p>
<ul>
<li>| 或</li>
<li>[] 或 //[]里的内容也是或的关系</li>
<li>[^···] 除了 //除了···都为true</li>
<li><strong>[x-y] x的ascii到y的ascii码之间的值</strong></li>
<li>[a-z] 小写字母 （也可以[e-i])</li>
<li>[A-Z] 大写字母</li>
<li>[A-z] 任意字母,但是还包括了其他ASCII在此之中的</li>
<li>[0-9] 任意数字</li>
</ul>
</li>
<li><p>量词</p>
<ul>
<li>通过量词可以设置一个内容出现的次数，<strong>量词只对它前边的一个内容起作用</strong></li>
<li>{n}     正好出现n次</li>
<li>{m,n}    出现m~n次</li>
<li>{m,}    出现m次以上</li>
<li><ul>
<li>至少一个，相当于{1,}</li>
</ul>
</li>
<li>*   0个或多个，相当于{0,}</li>
<li>?   0个或1个，相当于{0,1}</li>
</ul>
</li>
<li><p>边界表达式</p>
<ul>
<li>^表示开头</li>
<li>$表示结尾</li>
<li>在正则表达式中同时使用^$则要求字符串必须符合正则表达式<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eg:</span><br><span class="line">reg &#x3D; &#x2F;^a&#x2F;;  &#x2F;&#x2F;以a开头</span><br><span class="line">reg &#x3D; &#x2F;b$&#x2F;;  &#x2F;&#x2F;以b接位</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>元符号</p>
<ul>
<li>.     表示任意字符</li>
<li>\  .  表示 .</li>
<li>\\  表示 \</li>
<li>\w  任意字母、数字、_ [A-z0-9_]</li>
<li>\W  除了字母、数字、_ [ ^A-z0-9_]</li>
<li>\d  任意的数字 [0-9]</li>
<li>\D  除了数字 [ ^0-9]</li>
<li>\s  空格</li>
<li>\S  除了空格</li>
<li>\b  单词边界</li>
<li>\B  除了单词边界</li>
</ul>
</li>
<li><p>正则表达式应用举例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">去掉字符串两端的空格:</span><br><span class="line">var s &#x3D; &quot;        	he    llo    &quot;;   </span><br><span class="line">s &#x3D; s.replace(&#x2F;^\s*|\s*$&#x2F;g,&quot;&quot;);</span><br><span class="line"></span><br><span class="line">邮件的正则:</span><br><span class="line">hello.nihao@abc.com.cn</span><br><span class="line">任意字母下划线 . 任意字母下划线  @ 任意字母数字 .任意字母(2-5位) .任意字母(2-5位)</span><br><span class="line">\w&#123;3,&#125;  (\.\w+)*  @  [A-z0-9]+  (\.[A-z]&#123;2,5&#125;)&#123;1,2&#125;</span><br></pre></td></tr></table></figure>

<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1></li>
</ul>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>Document Object<br>Model文档对象模型,通过DOM可以来任意来修改网页中各个内容</p>
</blockquote>
<ul>
<li>文档<ul>
<li>文档指的是网页，一个网页就是一个文档</li>
</ul>
</li>
<li>对象<ul>
<li>对象指将网页中的每一个节点都转换为对象,转换完对象以后，就能以一种纯面向对象的形式来操作网页了</li>
</ul>
</li>
<li>模型<ul>
<li>模型用来表示节点和节点之间的关系，方便操作页面</li>
</ul>
</li>
<li>节点（Node）<ul>
<li>节点是构成网页的最基本的单元，网页中的每一个部分都可以称为是一个节点</li>
<li>虽然都是节点，但是节点的类型却是不同的</li>
<li>常用的节点：<ol>
<li>文档节点 （Document），代表整个网页</li>
<li>元素节点（Element），代表网页中的标签</li>
<li>属性节点（Attribute），代表标签中的属性</li>
<li>文本节点（Text），代表网页中的文本内容<br><img src="/2020/07/07/JavaScript/node.png" alt></li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><blockquote>
<p>就是用户和浏览器的交互行为，我们可以在事件对应的属性中设置一些js代码，事件被触发时执行代码</p>
</blockquote>
<ul>
<li><p>浏览器加载一个页面时，是按照从上至下的顺序加载的，如果把script标签放在页面上面，在代码执行时，页面还没有加载，就无法获取到dom对象，解决方法如下：</p>
<ol>
<li>解决方式一：可以将js代码编写到body的下边</li>
<li>解决方式二：将js代码编写到window.onload =<br>function(){}，window.onload<br>对应的回调函数会在整个页面加载完毕以后才执行，所以可以确保代码执行时，DOM对象已经加载完毕了<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">window.onload &#x3D; function()&#123;  </span><br><span class="line">var btn &#x3D; document.getElementById(&quot;btn&quot;);  </span><br><span class="line">btn.onclick &#x3D; function()&#123;  </span><br><span class="line">&#125;;  </span><br><span class="line">&#125;;  </span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>


</li>
</ol>
</li>
</ul>
<h2 id="DOM操作HTML"><a href="#DOM操作HTML" class="headerlink" title="DOM操作HTML"></a>DOM操作HTML</h2><ul>
<li><p>document对象获取元素节点对象</p>
<ol>
<li><p>getElementById()</p>
<ul>
<li>通过元素的id属性获取一个元素节点对象：</li>
</ul>
</li>
<li><p>getElementsByTagName()</p>
<ul>
<li>通过标签名获取一组元素节点对象</li>
</ul>
</li>
<li><p>getElementsByName()</p>
<ul>
<li>通过name属性获取一组元素节点对象</li>
</ul>
</li>
</ol>
</li>
<li><p>document对象的其他的属性和方法</p>
<ol>
<li><p>document.all</p>
<ul>
<li>获取页面中的所有元素，相当于document.getElementsByTagName(“*”);</li>
</ul>
</li>
<li><p>document.documentElement</p>
<ul>
<li>获取页面中html根元素</li>
</ul>
</li>
<li><p>document.body</p>
<ul>
<li>获取页面中的body元素</li>
</ul>
</li>
<li><p>document.getElementsByClassName()</p>
<ul>
<li>根据元素的class属性值查询一组元素节点对象//这个方法不支持IE8及以下的浏览器</li>
</ul>
</li>
<li><p>document.querySelector()</p>
<ul>
<li>根据CSS选择器去页面中查询一个元素，如果匹配到的元素有多个，则它会返回查询到的第一个元素</li>
</ul>
</li>
<li><p>document.querySelectorAll()</p>
<ul>
<li>用法同5，根据CSS选择器去页面中查询一组元素，会将匹配到所有元素封装到一个数组中返回，即使只匹配到一个</li>
</ul>
</li>
</ol>
</li>
<li><p>元素的属性：</p>
<ul>
<li><p>读取元素的属性：</p>
<ul>
<li>语法：元素.属性名</li>
<li>注意：class属性不能采用这种方式，读取class属性时需要使用<br>元素.className</li>
</ul>
</li>
<li><p>修改元素的属性：<br>语法：元素.属性名 = 属性值</p>
</li>
</ul>
</li>
<li><p>innerHTML</p>
<blockquote>
<p>使用该属性可以获取或设置元素内部的HTML代码</p>
</blockquote>
</li>
<li><p>获取元素节点的子节点</p>
<ul>
<li><p>元素.getElementsByTagName()</p>
<ul>
<li>通过标签名查询当前元素的指定后代元素</li>
</ul>
</li>
<li><p>子节点包括便签元素中的文本，子元素自包含标签元素</p>
</li>
<li><p>元素.childNodes</p>
<ul>
<li>获取当前元素的所有子节点，会获取到空白的文本子节点</li>
<li>childNodes属性会获取包括文本节点在内的所有节点，根据DOM标签标签间空白也会当成文本节点【注意：在IE8及以下的浏览器中，不会将空白文本当成子节点，所以该属性在IE8中会返回4个子元素而其他浏览器是9个】</li>
</ul>
</li>
<li><p>元素.children</p>
<ul>
<li>获取当前元素的所有子元素</li>
</ul>
</li>
<li><p>元素.firstChild</p>
<ul>
<li>获取当前元素的第一个子节点，会获取到空白的文本子节点</li>
</ul>
</li>
<li><p>元素.lastChild</p>
<ul>
<li>获取当前元素的最后一个子节点</li>
</ul>
</li>
<li><p>元素.parentNode</p>
<ul>
<li>获取当前元素的父元素</li>
</ul>
</li>
<li><p>元素.previousSibling</p>
<ul>
<li>获取当前元素的前一个兄弟节点</li>
<li>previousElementSibling获取前一个兄弟元素，IE8及以下不支持</li>
</ul>
</li>
<li><p>元素.nextSibling</p>
<ul>
<li>获取当前元素的后一个兄弟节点</li>
</ul>
</li>
<li><p>firstElementChild</p>
<ul>
<li>获取当前元素的第一个子元素</li>
<li>firstElementChild不支持IE8及以下的浏览器，如果需要兼容他们尽量不要使用</li>
</ul>
</li>
<li><p>innerHTML和innerText</p>
<ul>
<li>这两个属性并没有在DOM标准定义，但是大部分浏览器都支持这两个属性<br>两个属性作用类似，都可以获取到标签内部的内容，<br>不同是innerHTML会获取到html标签，而innerText会自动去除标签<br>如果使用这两个属性来设置标签内部的内容时，没有任何区别的</li>
</ul>
</li>
<li><p>读取标签内部的文本内容</p>
<ul>
<li>元素.firstChild.nodeValue</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="DOM修改"><a href="#DOM修改" class="headerlink" title="DOM修改"></a>DOM修改</h2><ul>
<li><p>document.createElement()</p>
<ul>
<li>可以用于创建一个元素节点对象，它需要一个标签名作为参数，将会根据该标签名创建元素节点对象，并将创建好的对象作为返回值返回</li>
</ul>
</li>
<li><p>document.createTextNode()</p>
<ul>
<li>可以根据文本内容创建一个文本节点对象</li>
</ul>
</li>
<li><p>父节点.appendChild(子节点)</p>
<ul>
<li>向父节点中添加指定的子节点</li>
</ul>
</li>
<li><p>父节点.insertBefore(新节点,旧节点)</p>
<ul>
<li>将一个新的节点插入到旧节点的前边</li>
</ul>
</li>
<li><p>父节点.replaceChild(新节点,旧节点)</p>
<ul>
<li>使用一个新的节点去替换旧节点</li>
</ul>
</li>
<li><p>父节点.removeChild(子节点)</p>
<ul>
<li>删除指定的子节点</li>
<li>推荐方式：子节点.parentNode.removeChild(子节点)</li>
</ul>
</li>
</ul>
<h2 id="DOM操作CSS"><a href="#DOM操作CSS" class="headerlink" title="DOM操作CSS"></a>DOM操作CSS</h2><ul>
<li><p>读取和修改内联样式</p>
<ul>
<li>使用style属性来操作元素的内联样式</li>
<li>读取内联样式：</li>
<li>语法：元素.style.样式名<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">元素.style.width</span><br><span class="line">元素.style.height</span><br><span class="line">注意：如果样式名中带有-，则需要将样式名修改为驼峰命名法将-去掉，然后后的字母改大写</span><br><span class="line">比如：backgroundcolor &gt; backgroundColor</span><br><span class="line">borderwidth &gt; borderWidth</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>修改内联样式：</p>
<ul>
<li>语法：元素.style.样式名 = 样式值</li>
<li>通过style修改和读取的样式都是内联样式，由于内联样式的优先级比较高，所以我们通过JS来修改的样式，往往会立即生效，但是如果样式中设置了!important，则内联样式将不会生效。</li>
</ul>
</li>
<li><p>读取元素的当前样式</p>
<ol>
<li>正常浏览器</li>
</ol>
<ul>
<li>使用getComputedStyle()</li>
<li>这个方法是window对象的方法，可以返回一个对象，这个对象中保存着当前元素生效样式</li>
<li>参数：<ul>
<li>1.要获取样式的元素</li>
<li>2.可以传递一个伪元素，一般传null</li>
<li>例子：<ul>
<li>获取元素的宽度</li>
<li>getComputedStyle(box , null)[“width”];</li>
<li>通过该方法读取到样式都是只读的不能修改</li>
</ul>
</li>
</ul>
</li>
<li>可以通过对象.样式名来读取样式</li>
<li>如果获取的样式没有设置，则会获取到真实的值，而不是默认值</li>
</ul>
<ol start="2">
<li>IE8</li>
</ol>
<ul>
<li>使用currentStyle</li>
<li>语法：<ul>
<li>元素.currentStyle.样式名</li>
<li>例子：<ul>
<li>box.currentStyle[“width”]</li>
<li>通过这个属性读取到的样式是只读的不能修改</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>实现兼容性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*  </span><br><span class="line">* 定义一个函数，用来获取指定元素的当前的样式  </span><br><span class="line">* 参数：  </span><br><span class="line">* 		obj 要获取样式的元素  </span><br><span class="line">* 		name 要获取的样式名  </span><br><span class="line">*&#x2F;  </span><br><span class="line">function getStyle(obj , name)&#123;  </span><br><span class="line">    if(window.getComputedStyle)&#123;  </span><br><span class="line">        &#x2F;&#x2F;正常浏览器的方式，具有getComputedStyle()方法  </span><br><span class="line">        return getComputedStyle(obj , null)[name];  </span><br><span class="line">    &#125;else&#123;  </span><br><span class="line">        &#x2F;&#x2F;IE8的方式，没有getComputedStyle()方法  </span><br><span class="line">        return obj.currentStyle[name];  </span><br><span class="line">    &#125;  </span><br><span class="line">    &#x2F;&#x2F;简写：return window.getComputedStyle?getComputedStyle(obj , null)[name]:obj.currentStyle[name];			  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>其他的样式相关的属性</p>
<blockquote>
<p>注意：以下样式都是只读的，不能修改，未指明偏移量都是相对于当前窗口左上角</p>
</blockquote>
<table>
<thead>
<tr>
<th>name</th>
<th>function</th>
</tr>
</thead>
<tbody><tr>
<td>clientHeight</td>
<td>元素的可见高度，包括元素的内容区和内边距的高度</td>
</tr>
<tr>
<td>clientWidth</td>
<td>元素的可见宽度，包括元素的内容区和内边距的宽度</td>
</tr>
<tr>
<td>offsetHeight</td>
<td>整个元素的高度，包括内容区、内边距、边框</td>
</tr>
<tr>
<td>offfsetWidth</td>
<td>整个元素的宽度，包括内容区、内边距、边框</td>
</tr>
<tr>
<td>offsetParent</td>
<td>当前元素的定位父元素,离他最近的开启了定位的祖先元素，如果所有的元素都没有开启定位，则返回body</td>
</tr>
<tr>
<td>offsetLeft</td>
<td>当前元素和定位父元素之间的偏移量(水平偏移量)</td>
</tr>
<tr>
<td>offsetTop</td>
<td>当前元素和定位父元素之间的偏移量(垂直偏移量)</td>
</tr>
<tr>
<td>scrollHeight</td>
<td>获取元素整个滚动区域的高度</td>
</tr>
<tr>
<td>scrollWidth</td>
<td>获取元素整个滚动区域的宽度</td>
</tr>
<tr>
<td>scrollTop</td>
<td>获取元素垂直滚动条滚动的距离</td>
</tr>
<tr>
<td>scrollLeft</td>
<td>获取元素水平滚动条滚动的距离</td>
</tr>
<tr>
<td>scrollHeight -scrollTop = clientHeight</td>
<td>判断滚动条是否滚动到底(垂直滚动条)</td>
</tr>
<tr>
<td>scrollWidth -scrollLeft = clientWidth</td>
<td>判断滚动条是否滚动到底(水平滚动条)</td>
</tr>
</tbody></table>
<h1 id="事件-1"><a href="#事件-1" class="headerlink" title="事件"></a>事件</h1></li>
</ul>
<h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><ul>
<li><p>当响应函数被调用时，浏览器每次都会将一个事件对象作为实参传递进响应函数中，这个事件对象中封装了当前事件的相关信息，比如：鼠标的坐标，键盘的按键，鼠标的按键，滚轮的方向。。</p>
</li>
<li><p>可以在响应函数中定义一个形参，来使用事件对象，但是在IE8以下浏览器中事件对象没有做完实参传递，而是作为window对象的属性保存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">元素.事件 &#x3D; function(event)&#123;  </span><br><span class="line">    event &#x3D; event || window.event;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">元素.事件 &#x3D; function(e)&#123;  </span><br><span class="line">	e &#x3D; e || event;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取到鼠标的坐标</p>
<ol>
<li><p>clientX和clientY</p>
<ul>
<li>用于获取鼠标在当前的可见窗口的坐标</li>
<li>div的偏移量，是相对于整个页面的</li>
</ul>
</li>
<li><p>pageX和pageY</p>
<ul>
<li>可以获取鼠标相对于当前页面的坐标但是这个两个属性在IE8中不支持，所以如果需要兼容IE8，则不要使用var<br>left = event.clientX;var　top = event.clientY;</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="事件的冒泡"><a href="#事件的冒泡" class="headerlink" title="事件的冒泡"></a>事件的冒泡</h2><ul>
<li><p>事件的冒泡指的是事件向上传导，当后代元素上的事件被触发时，将会导致其祖先元素上的同类事件也会触发</p>
</li>
<li><p>事件的冒泡大部分情况下都是有益的，如果需要取消冒泡，则需要使用事件对象来取消<br>可以将事件对象的cancelBubble设置为true，即可取消冒泡</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">元素.事件 &#x3D; function(event)&#123;  </span><br><span class="line">    event &#x3D; event || window.event;  </span><br><span class="line">    event.cancelBubble &#x3D; true;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="事件的委派"><a href="#事件的委派" class="headerlink" title="事件的委派"></a>事件的委派</h2><ul>
<li>指将事件统一绑定给元素的共同的祖先元素，这样当后代元素上的事件触发时，会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件。</li>
<li>事件委派是利用了冒泡，通过委派可以减少事件绑定的次数，提高程序的性能</li>
<li>我们希望，只绑定一次事件，即可应用到多个的元素上，即使元素是后添加的<br>我们可以尝试将其绑定给元素的共同的祖先元素</li>
<li>target : event中的target表示的触发事件的对象</li>
</ul>
<h2 id="事件的绑定"><a href="#事件的绑定" class="headerlink" title="事件的绑定"></a>事件的绑定</h2><ul>
<li><p>addEventListener()</p>
</li>
<li><p>通过这个方法也可以为元素绑定响应函数</p>
</li>
<li><p>参数：</p>
<ol>
<li>事件的字符串，不要on</li>
<li>回调函数，当事件触发时该函数会被调用</li>
<li>是否在捕获阶段触发事件，需要一个布尔值，一般都传false</li>
</ol>
</li>
<li><p>使用addEventListener()可以同时为一个元素的相同事件同时绑定多个响应函数，<br>这样当事件被触发时，响应函数将会按照函数的绑定顺序执行,<strong>这个方法不支持IE8及以下的浏览器</strong></p>
</li>
<li><p>attachEvent()</p>
</li>
<li><p>在IE8中可以使用attachEvent()来绑定事件</p>
</li>
<li><p>参数：</p>
<ol>
<li>事件的字符串，要on</li>
<li>回调函数</li>
</ol>
</li>
<li><p>这个方法也可以同时为一个事件绑定多个处理函数，不同的是它是后绑定是事件先执行，执行顺序和addEventListener()相反</p>
</li>
<li><p>兼容模式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;定义一个函数，用来为指定元素绑定响应函数  </span><br><span class="line">            &#x2F;*  </span><br><span class="line">            * addEventListener()中的this，是绑定事件的对象  </span><br><span class="line">            * attachEvent()中的this，是window  </span><br><span class="line">            *  需要统一两个方法this  </span><br><span class="line">            *&#x2F;  </span><br><span class="line">            &#x2F;*  </span><br><span class="line">            * 参数：  </span><br><span class="line">            * 	obj 要绑定事件的对象  </span><br><span class="line">            * 	eventStr 事件的字符串(不要on)  </span><br><span class="line">            *  callback 回调函数  </span><br><span class="line">            *&#x2F;  </span><br><span class="line">function bind(obj , eventStr , callback)&#123;  </span><br><span class="line">    if(obj.addEventListener)&#123;  </span><br><span class="line">        &#x2F;&#x2F;大部分浏览器兼容的方式  </span><br><span class="line">        obj.addEventListener(eventStr , callback , false);  </span><br><span class="line">    &#125;else&#123;  </span><br><span class="line">                    &#x2F;*  </span><br><span class="line">                    * this是谁由调用方式决定  </span><br><span class="line">                    * callback.call(obj)  </span><br><span class="line">                    *&#x2F;  </span><br><span class="line">        &#x2F;&#x2F;IE8及以下  </span><br><span class="line">        obj.attachEvent(&quot;on&quot;+eventStr , function()&#123;  </span><br><span class="line">            &#x2F;&#x2F;在匿名函数中调用回调函数  </span><br><span class="line">            callback.call(obj);  </span><br><span class="line">        &#125;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="事件的传播"><a href="#事件的传播" class="headerlink" title="事件的传播"></a>事件的传播</h2><ul>
<li><p>关于事件的传播网景公司和微软公司有不同的理解：</p>
<ul>
<li>微软公司认为事件应该是由内向外传播，也就是当事件触发时，应该先触发当前元素上的事件，然后再向当前元素的祖先元素上传播，也就说事件应该在冒泡阶段执行</li>
<li>网景公司认为事件应该是由外向内传播的，也就是当前事件触发时，应该先触发当前元素的最外层的祖先元素的事件，然后在向内传播给后代元素</li>
</ul>
</li>
<li><p>W3C综合了两个公司的方案，将事件传播分成了三个阶段：</p>
<ol>
<li><p>捕获阶段</p>
<ul>
<li>在捕获阶段时从最外层的祖先元素，向目标元素进行事件的捕获，但是默认此时不会触发事件</li>
</ul>
</li>
<li><p>目标阶段</p>
<ul>
<li>事件捕获到目标元素，捕获结束开始在目标元素上触发事件</li>
</ul>
</li>
<li><p>冒泡阶段</p>
<ul>
<li>事件从目标元素向他的祖先元素传递，依次触发祖先元素上的事件</li>
</ul>
</li>
</ol>
</li>
<li><p>如果希望在捕获阶段就触发事件，可以将addEventListener()的第三个参数设置为true</p>
</li>
<li><p>一般情况下我们不会希望在捕获阶段触发事件，所以这个参数一般都是false</p>
</li>
<li><p>IE8及以下的浏览器中没有捕获阶段</p>
</li>
</ul>
<h2 id="常用的事件"><a href="#常用的事件" class="headerlink" title="常用的事件"></a>常用的事件</h2><ul>
<li><p>拖拽事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;  </span><br><span class="line">    &lt;html&gt;  </span><br><span class="line">    &lt;head&gt;  </span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;  </span><br><span class="line">        &lt;title&gt;&lt;&#x2F;title&gt;  </span><br><span class="line">&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;  </span><br><span class="line">    #box1&#123;  </span><br><span class="line">width: 100px;  </span><br><span class="line">height: 100px;  </span><br><span class="line">background-color: red;  </span><br><span class="line">position: absolute;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">#box2&#123;  </span><br><span class="line">width: 100px;  </span><br><span class="line">height: 100px;  </span><br><span class="line">background-color: yellow;  </span><br><span class="line">position: absolute;  </span><br><span class="line">  </span><br><span class="line">left: 200px;  </span><br><span class="line">top: 200px;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">    &lt;&#x2F;style&gt;  </span><br><span class="line">  </span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;  </span><br><span class="line">    window.onload &#x3D; function()&#123;  </span><br><span class="line">    &#x2F;*  </span><br><span class="line">				 * 拖拽box1元素  </span><br><span class="line">				 *  - 拖拽的流程  </span><br><span class="line">				 * 		1.当鼠标在被拖拽元素上按下时，开始拖拽  onmousedown  </span><br><span class="line">				 * 		2.当鼠标移动时被拖拽元素跟随鼠标移动 onmousemove  </span><br><span class="line">				 * 		3.当鼠标松开时，被拖拽元素固定在当前位置	onmouseup  </span><br><span class="line">				 *&#x2F;  </span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F;获取box1  </span><br><span class="line">    var box1 &#x3D; document.getElementById(&quot;box1&quot;);  </span><br><span class="line">    var box2 &#x3D; document.getElementById(&quot;box2&quot;);  </span><br><span class="line">    &#x2F;&#x2F;开启box1的拖拽  </span><br><span class="line">    drag(box1);  </span><br><span class="line">    &#x2F;&#x2F;开启box2的  </span><br><span class="line">    drag(box2);  </span><br><span class="line">  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">&#x2F;*  </span><br><span class="line">			 * 提取一个专门用来设置拖拽的函数  </span><br><span class="line">			 * 参数：开启拖拽的元素  </span><br><span class="line">			 *&#x2F;  </span><br><span class="line">function drag(obj)&#123;  </span><br><span class="line">    &#x2F;&#x2F;当鼠标在被拖拽元素上按下时，开始拖拽  onmousedown  </span><br><span class="line">    obj.onmousedown &#x3D; function(event)&#123;  </span><br><span class="line">        &#x2F;&#x2F;设置box1捕获所有鼠标按下的事件  </span><br><span class="line">        &#x2F;*  </span><br><span class="line">					 * setCapture()  </span><br><span class="line">					 * 	- 只有IE支持，但是在火狐中调用时不会报错，  </span><br><span class="line">					 * 		而如果使用chrome调用，会报错  </span><br><span class="line">					 *&#x2F;  </span><br><span class="line">        &#x2F;*if(box1.setCapture)&#123;  </span><br><span class="line">						box1.setCapture();  </span><br><span class="line">					&#125;*&#x2F;  </span><br><span class="line">        &#x2F;&#x2F;当调用setcapture方法之后，这个元素将会把下一次所有的鼠标按下相关事件捕获到自身上</span><br><span class="line">        obj.setCapture &amp;&amp; obj.setCapture();  </span><br><span class="line">        event &#x3D; event || window.event;  </span><br><span class="line">        &#x2F;&#x2F;div的偏移量 鼠标.clentX - 元素.offsetLeft  </span><br><span class="line">        &#x2F;&#x2F;div的偏移量 鼠标.clentY - 元素.offsetTop  </span><br><span class="line">        var ol &#x3D; event.clientX - obj.offsetLeft;  </span><br><span class="line">        var ot &#x3D; event.clientY - obj.offsetTop;  </span><br><span class="line">        &#x2F;&#x2F;为document绑定一个onmousemove事件  </span><br><span class="line">        document.onmousemove &#x3D; function(event)&#123;  </span><br><span class="line">            event &#x3D; event || window.event;  </span><br><span class="line">            &#x2F;&#x2F;当鼠标移动时被拖拽元素跟随鼠标移动 onmousemove  </span><br><span class="line">            &#x2F;&#x2F;获取鼠标的坐标  </span><br><span class="line">            var left &#x3D; event.clientX - ol;  </span><br><span class="line">            var top &#x3D; event.clientY - ot;  </span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F;修改box1的位置  </span><br><span class="line">            obj.style.left &#x3D; left+&quot;px&quot;;  </span><br><span class="line">            obj.style.top &#x3D; top+&quot;px&quot;;  </span><br><span class="line">  </span><br><span class="line">        &#125;;  </span><br><span class="line">        &#x2F;&#x2F;为document绑定一个鼠标松开事件  </span><br><span class="line">        document.onmouseup &#x3D; function()&#123;  </span><br><span class="line">            &#x2F;&#x2F;当鼠标松开时，被拖拽元素固定在当前位置	onmouseup  </span><br><span class="line">            &#x2F;&#x2F;取消document的onmousemove事件  </span><br><span class="line">            document.onmousemove &#x3D; null;  </span><br><span class="line">            &#x2F;&#x2F;取消document的onmouseup事件  </span><br><span class="line">            document.onmouseup &#x3D; null;  </span><br><span class="line">            &#x2F;&#x2F;当鼠标松开时，取消对事件的捕获  </span><br><span class="line">            obj.releaseCapture &amp;&amp; obj.releaseCapture();  </span><br><span class="line">        &#125;;  </span><br><span class="line"> &#x2F;*  </span><br><span class="line">* 当我们拖拽一个网页中的内容时，浏览器会默认去搜索引擎中搜索内容，  </span><br><span class="line">* 	此时会导致拖拽功能的异常，这个是浏览器提供的默认行为，  </span><br><span class="line">* 	如果不希望发生这个行为，则可以通过return false来取消默认行为  </span><br><span class="line">*   </span><br><span class="line">* 但是这招对IE8不起作用  </span><br><span class="line">*&#x2F;  </span><br><span class="line">        return false;  </span><br><span class="line">    &#125;;  </span><br><span class="line">&#125;  </span><br><span class="line">&lt;&#x2F;script&gt;  </span><br><span class="line">&lt;&#x2F;head&gt;  </span><br><span class="line">&lt;body&gt;   </span><br><span class="line">我是一段文字   </span><br><span class="line">&lt;div id&#x3D;&quot;box1&quot;&gt;&lt;&#x2F;div&gt;  </span><br><span class="line">&lt;div id&#x3D;&quot;box2&quot;&gt;&lt;&#x2F;div&gt;  </span><br><span class="line">&lt;&#x2F;body&gt;  </span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>滚轮事件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;  </span><br><span class="line">    &lt;html&gt;  </span><br><span class="line">    &lt;head&gt;  </span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;  </span><br><span class="line">        &lt;title&gt;&lt;&#x2F;title&gt;  </span><br><span class="line">&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;  </span><br><span class="line">  </span><br><span class="line">    #box1&#123;  </span><br><span class="line">width: 100px;  </span><br><span class="line">height: 100px;  </span><br><span class="line">background-color: red;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">    &lt;&#x2F;style&gt;  </span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;  </span><br><span class="line">  </span><br><span class="line">    window.onload &#x3D; function()&#123;  </span><br><span class="line">    &#x2F;&#x2F;获取id为box1的div  </span><br><span class="line">    var box1 &#x3D; document.getElementById(&quot;box1&quot;);  </span><br><span class="line">    &#x2F;&#x2F;为box1绑定一个鼠标滚轮滚动的事件  </span><br><span class="line">    &#x2F;*  </span><br><span class="line">				 * onmousewheel鼠标滚轮滚动的事件，会在滚轮滚动时触发，  </span><br><span class="line">				 * 	但是火狐不支持该属性  </span><br><span class="line">				 *   </span><br><span class="line">				 * 在火狐中需要使用 DOMMouseScroll 来绑定滚动事件  </span><br><span class="line">				 * 	注意该事件需要通过addEventListener()函数来绑定  </span><br><span class="line">				 *&#x2F;  </span><br><span class="line">  </span><br><span class="line">    box1.onmousewheel &#x3D; function(event)&#123;  </span><br><span class="line">        event &#x3D; event || window.event;  </span><br><span class="line">        &#x2F;&#x2F;event.wheelDelta 可以获取鼠标滚轮滚动的方向  </span><br><span class="line">        &#x2F;&#x2F;向上滚 120   向下滚 -120  </span><br><span class="line">        &#x2F;&#x2F;wheelDelta这个值我们不看大小，只看正负  </span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F;alert(event.wheelDelta);  </span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F;wheelDelta这个属性火狐中不支持  </span><br><span class="line">        &#x2F;&#x2F;在火狐中使用event.detail来获取滚动的方向  </span><br><span class="line">        &#x2F;&#x2F;向上滚 -3  向下滚 3  </span><br><span class="line">        &#x2F;&#x2F;alert(event.detail);  </span><br><span class="line">        &#x2F;*  </span><br><span class="line">					 * 当鼠标滚轮向下滚动时，box1变长  </span><br><span class="line">					 * 	当滚轮向上滚动时，box1变短  </span><br><span class="line">					 *&#x2F;  </span><br><span class="line">        &#x2F;&#x2F;判断鼠标滚轮滚动的方向  </span><br><span class="line">        if(event.wheelDelta &gt; 0 || event.detail &lt; 0)&#123;  </span><br><span class="line">            &#x2F;&#x2F;向上滚，box1变短  </span><br><span class="line">            box1.style.height &#x3D; box1.clientHeight - 10 + &quot;px&quot;;  </span><br><span class="line">  </span><br><span class="line">        &#125;else&#123;  </span><br><span class="line">            &#x2F;&#x2F;向下滚，box1变长  </span><br><span class="line">            box1.style.height &#x3D; box1.clientHeight + 10 + &quot;px&quot;;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        &#x2F;*  </span><br><span class="line">					 * 使用addEventListener()方法绑定响应函数，取消默认行为时不能使用return false  </span><br><span class="line">					 * 需要使用event来取消默认行为event.preventDefault();  </span><br><span class="line">					 * 但是IE8不支持event.preventDefault();这个玩意，如果直接调用会报错  </span><br><span class="line">					 *&#x2F;  </span><br><span class="line">        event.preventDefault &amp;&amp; event.preventDefault();  </span><br><span class="line"></span><br><span class="line">        &#x2F;*  </span><br><span class="line">					 * 当滚轮滚动时，如果浏览器有滚动条，滚动条会随之滚动，  </span><br><span class="line">					 * 这是浏览器的默认行为，如果不希望发生，则可以取消默认行为  </span><br><span class="line">					 *&#x2F;  </span><br><span class="line">        return false;  </span><br><span class="line">    &#125;;  </span><br><span class="line">    &#x2F;&#x2F;为火狐绑定滚轮事件  </span><br><span class="line">    bind(box1,&quot;DOMMouseScroll&quot;,box1.onmousewheel);  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">function bind(obj , eventStr , callback)&#123;  </span><br><span class="line">    if(obj.addEventListener)&#123;  </span><br><span class="line">        &#x2F;&#x2F;大部分浏览器兼容的方式  </span><br><span class="line">        obj.addEventListener(eventStr , callback , false);  </span><br><span class="line">    &#125;else&#123;  </span><br><span class="line">        &#x2F;*  </span><br><span class="line">					 * this是谁由调用方式决定  </span><br><span class="line">					 * callback.call(obj)  </span><br><span class="line">					 *&#x2F;  </span><br><span class="line">        &#x2F;&#x2F;IE8及以下  </span><br><span class="line">        obj.attachEvent(&quot;on&quot;+eventStr , function()&#123;  </span><br><span class="line">            &#x2F;&#x2F;在匿名函数中调用回调函数  </span><br><span class="line">            callback.call(obj);  </span><br><span class="line">        &#125;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">&lt;&#x2F;script&gt;  </span><br><span class="line">&lt;&#x2F;head&gt;  </span><br><span class="line">&lt;body style&#x3D;&quot;height: 2000px;&quot;&gt;   </span><br><span class="line">    &lt;div id&#x3D;&quot;box1&quot;&gt;&lt;&#x2F;div&gt;  </span><br><span class="line">&lt;&#x2F;body&gt;  </span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li>键盘事件</li>
</ul>
<ol>
<li><p>onkeydown</p>
<ul>
<li>按键被按下</li>
<li>对于onkeydown来说如果一直按着某个按键不松手，则事件会一直触发</li>
<li>当onkeydown连续触发时，第一次和第二次之间会间隔稍微长一点，其他的会非常的快，这种设计是为了防止误操作的发生</li>
</ul>
</li>
<li><p>onkeyup</p>
<ul>
<li>按键被松开</li>
<li>键盘事件一般都会绑定给一些可以获取到焦点的对象或者是document</li>
</ul>
</li>
<li><p>keyCode</p>
<ul>
<li>可以通过keyCode来获取按键的编码通过它可以判断哪个按键被按下</li>
<li>除了keyCode，事件对象中还提供了几个属性<ul>
<li>altKey</li>
<li>ctrlKey</li>
<li>shiftKey</li>
<li>这个三个用来判断alt ctrl 和<br>shift是否被按下，如果按下则返回true，否则返回false<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eg:</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;判断一个y是否被按下  </span><br><span class="line"> &#x2F;&#x2F;判断y和ctrl是否同时被按下  </span><br><span class="line"> if(event.keyCode &#x3D;&#x3D;&#x3D; 89 &amp;&amp; event.ctrlKey)&#123;  </span><br><span class="line">     console.log(&quot;ctrl和y都被按下了&quot;);  </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;使文本框中不能输入数字  </span><br><span class="line"> input.onkeydown &#x3D; function(event) &#123;  </span><br><span class="line">     event &#x3D; event || window.event;  </span><br><span class="line">     &#x2F;&#x2F;数字 48 - 57  </span><br><span class="line">     if(event.keyCode &gt;&#x3D; 48 &amp;&amp; event.keyCode &lt;&#x3D; 57) &#123;  </span><br><span class="line">         &#x2F;&#x2F;在文本框中输入内容，属于onkeydown的默认行为  </span><br><span class="line">         &#x2F;&#x2F;如果在onkeydown中取消了默认行为，则输入的内容，不会出现在文本框中  </span><br><span class="line">         return false;  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><ul>
<li>浏览器对象模型(browser object model)</li>
<li>BOM可以使我们通过JS来操作浏览器</li>
<li>在BOM中为我们提供了一组对象，用来完成对浏览器的操作</li>
</ul>
<h2 id="BOM对象"><a href="#BOM对象" class="headerlink" title="BOM对象"></a>BOM对象</h2><ul>
<li>Window<ul>
<li>代表的是整个浏览器的窗口，同时window也是网页中的全局对象</li>
</ul>
</li>
<li>Navigator<ul>
<li>代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器</li>
</ul>
</li>
<li>Location<ul>
<li>代表当前浏览器的地址栏信息，通过Location可以获取地址栏信息，或者操作浏览器跳转页面</li>
</ul>
</li>
<li>History<ul>
<li>代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录<br>由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页，而且该操作只在当次访问时有效</li>
</ul>
</li>
<li>Screen<ul>
<li>代表用户的屏幕的信息，通过该对象可以获取到用户的显示器的相关的信息</li>
</ul>
</li>
<li>这些BOM对象在浏览器中都是作为window对象的属性保存的，可以通过window对象来使用，也可以直接使用</li>
</ul>
<h2 id="Navigator"><a href="#Navigator" class="headerlink" title="Navigator"></a>Navigator</h2><ul>
<li>代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器</li>
<li>由于历史原因，Navigator对象中的大部分属性都已经不能帮助我们识别浏览器了，一般我们只会使用userAgent来判断浏览器的信息，</li>
<li>userAgent是一个字符串，这个字符串中包含有用来描述浏览器信息的内容，不同的浏览器会有不同的userAgent<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;通过userAgent判断浏览器类型</span><br><span class="line"></span><br><span class="line">alert(navigator.appName);   </span><br><span class="line">var ua &#x3D; navigator.userAgent;  </span><br><span class="line"></span><br><span class="line">if(firefoxi.test(ua))&#123;  </span><br><span class="line">alert(&quot;你是火狐！！！&quot;);  </span><br><span class="line">&#125;else if(chromei.test(ua))&#123;  </span><br><span class="line">alert(&quot;你是Chrome&quot;);  </span><br><span class="line">&#125;else if(msiei.test(ua))&#123;  </span><br><span class="line">alert(&quot;你是IE浏览器~~~&quot;);  </span><br><span class="line">&#x2F;&#x2F;通过userAgent不能判断浏览器类型时，还可以通过一些浏览器特有的对象来判断浏览器信息，比如：ActiveXObject</span><br><span class="line">&#125;else if(&quot;ActiveXObject&quot; in window)&#123;  </span><br><span class="line">alert(&quot;你是IE11，枪毙了你~~~&quot;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="History"><a href="#History" class="headerlink" title="History"></a>History</h2><ul>
<li>对象可以用来操作浏览器向前或向后翻页</li>
<li>length<ul>
<li>可以获取到当次访问的链接数量</li>
</ul>
</li>
<li>back()<ul>
<li>可以用来回退到上一个页面，作用和浏览器的回退按钮一样</li>
</ul>
</li>
<li>forward()<ul>
<li>可以跳转下一个页面，作用和浏览器的前进按钮一样</li>
</ul>
</li>
<li>go()<ul>
<li>可以用来跳转到指定的页面</li>
<li>它需要一个整数作为参数<ul>
<li>1:表示向前跳转一个页面 相当于forward()</li>
<li>2:表示向前跳转两个页面</li>
<li>-1:表示向后跳转一个页面</li>
<li>-2:表示向后跳转两个页面</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h2><ul>
<li>该对象中封装了浏览器的地址栏的信息</li>
<li>如果直接打印location，则可以获取到地址栏的信息（当前页面的完整路径）</li>
<li>alert(location);<ul>
<li>如果直接将location属性修改为一个完整的路径或相对路径，则我们页面会自动跳转到该路径，并且会生成相应的历史记录<ul>
<li>location = “http:<a href="http://www.baidu.com" target="_blank" rel="noopener" ">www.baidu.com”</a>;</li>
<li>location = “01.BOM.html”;</li>
</ul>
</li>
</ul>
</li>
<li>assign()<ul>
<li>用来跳转到其他的页面，作用和直接修改location一样</li>
</ul>
</li>
<li>reload()<ul>
<li>用于重新加载当前页面，作用和刷新按钮一样</li>
<li>如果在方法中传递一个true，作为参数，则会强制清空缓存刷新页面<br>location.reload(true);</li>
</ul>
</li>
<li>replace()<ul>
<li>可以使用一个新的页面替换当前页面，调用完毕也会跳转页面<br>不会生成历史记录，不能使用回退按钮回退</li>
</ul>
</li>
</ul>
<h2 id="window"><a href="#window" class="headerlink" title="window"></a>window</h2><ul>
<li><p>定时调用</p>
</li>
<li><p>setInterval()</p>
<ul>
<li>可以将一个函数，每隔一段时间执行一次</li>
<li>参数：<ul>
<li>1.回调函数，该函数会每隔一段时间被调用一次</li>
<li>2.每次调用间隔的时间，单位是毫秒</li>
</ul>
</li>
<li>返回值：<ul>
<li>返回一个Number类型的数据</li>
<li>这个数字用来作为定时器的唯一标识</li>
</ul>
</li>
</ul>
</li>
<li><p>clearInterval()</p>
<ul>
<li>可以用来关闭一个定时器</li>
<li>方法中需要一个定时器的标识作为参数，这样将关闭标识对应的定时器</li>
<li>clearInterval()可以接收任意参数，如果参数是一个有效的定时器的标识，则停止对应的定时器,如果参数不是一个有效的标识，则什么也不做<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var num &#x3D; 1;  </span><br><span class="line">var timer &#x3D; setInterval(function() &#123;  </span><br><span class="line">    count.innerHTML &#x3D; num++;  </span><br><span class="line">    if(num &#x3D;&#x3D; 11) &#123;  </span><br><span class="line">        &#x2F;&#x2F;关闭定时器  </span><br><span class="line">        clearInterval(timer);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>延时调用</p>
</li>
<li><p>setTimeout</p>
<ul>
<li>参数：<ul>
<li>1.回调函数，该函数会在一段时间后被调用一次</li>
<li>2.每次调用的时间，单位是毫秒</li>
</ul>
</li>
<li>延时调用一个函数不马上执行，而是隔一段时间以后在执行，而且只会执行一次</li>
<li>延时调用和定时调用的区别，定时调用会执行多次，而延时调用只会执行一次，延时调用和定时调用实际上是可以互相代替的，在开发中可以根据自己需要去选择</li>
<li>使用clearTimeout()来关闭一个延时调用clearTimeout(timer);</li>
</ul>
</li>
</ul>
<h1 id="类的操作"><a href="#类的操作" class="headerlink" title="类的操作"></a>类的操作</h1><h2 id="直接修改元素的类css"><a href="#直接修改元素的类css" class="headerlink" title="直接修改元素的类css"></a>直接修改元素的类css</h2><ul>
<li><p>通过style属性来修改元素的样式，每修改一个样式，浏览器就需要重新渲染一次页面，这样的执行的性能是比较差的，而且这种形式当我们要修改多个样式时，也不太方便<br>我希望一行代码，可以同时修改多个样式，<strong>我们可以通过修改元素的class属性来间接的修改样式</strong>，这样一来，我们只需要修改一次，即可同时修改多个样式，浏览器只需要重新渲染页面一次，性能比较好，并且这种方式，可以使表现和行为进一步的分离</p>
<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><blockquote>
<p>JavaScript Object Notation JS对象表示法</p>
</blockquote>
</li>
</ul>
<h2 id="JSON-格式"><a href="#JSON-格式" class="headerlink" title="JSON-格式"></a>JSON-格式</h2><ul>
<li>复合类型的值只能是数组或对象，<strong>不能是函数</strong>、正则表达式对象、日期对象</li>
<li>原始类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和null（不能使用NaN,<br>Infinity, -Infinity和undefined）</li>
<li>字符串必须使用双引号表示，不能使用单引号。</li>
<li>对象的键名必须放在双引号里面。</li>
<li>数组或对象最后一个成员的后面，不能加逗号。</li>
<li>JS中的对象只有JS自己认识，其他的语言都不认识</li>
<li>JSON就是一个特殊格式的字符串，这个字符串可以被任意的语言所识别，并且可以转换为任意语言中的对象，JSON在开发中主要用来数据的交互</li>
<li>JSON和JS对象的格式一样，只不过JSON字符串中的属性名必须加双引号,其他的和JS语法一致</li>
</ul>
<h2 id="JSON分类："><a href="#JSON分类：" class="headerlink" title="JSON分类："></a>JSON分类：</h2><ol>
<li>对象 {}</li>
<li>数组 []</li>
</ol>
<h2 id="JSON中允许的值："><a href="#JSON中允许的值：" class="headerlink" title="JSON中允许的值："></a>JSON中允许的值：</h2><ol>
<li>字符串</li>
<li>数值</li>
<li>布尔值</li>
<li>null</li>
<li>对象</li>
<li>数组<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eg:</span><br><span class="line"></span><br><span class="line">var arr &#x3D; &#39;[1,2,3,&quot;hello&quot;,true]&#39;;  </span><br><span class="line">var obj2 &#x3D; &#39;&#123;&quot;arr&quot;:[1,2,3]&#125;&#39;;    </span><br><span class="line">var arr2 &#x3D;&#39;[&#123;&quot;name&quot;:&quot;孙悟空&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;男&quot;&#125;,&#123;&quot;name&quot;:&quot;孙悟空&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;男&quot;&#125;]&#39;;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="JSON工具类"><a href="#JSON工具类" class="headerlink" title="JSON工具类"></a>JSON工具类</h2><ul>
<li><strong>JSON -&gt; JS对象</strong></li>
<li>JSON.parse()<ul>
<li>可以将以JSON字符串转换为js对象</li>
<li>它需要一个JSON字符串作为参数，会将该字符串转换为JS对象并返回<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var o &#x3D; JSON.parse(json);</span><br><span class="line">var o2 &#x3D; JSON.parse(arr);</span><br><span class="line"></span><br><span class="line">var obj3 &#x3D; &#123;name:”猪八戒” , age:28 , gender:”男”&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>JS对象 -&gt; JSON</strong></li>
<li>JSON.stringify()<ul>
<li>可以将一个JS对象转换为JSON字符串</li>
<li>需要一个js对象作为参数，会返回一个JSON字符串<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str &#x3D; JSON.stringify(obj3);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>JSON这个对象在IE7及以下的浏览器中不支持，所以在这些浏览器中调用时会报错</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>eval()<ul>
<li>这个函数可以用来执行一段字符串形式的JS代码，并将执行结果返回</li>
<li>如果使用eval()执行的字符串中含有{},它会将{}当成是代码块</li>
<li>如果不希望将其当成代码块解析，则需要在字符串前后各加一个()</li>
<li>eval()这个函数的功能很强大，可以直接执行一个字符串中的js代码，但是在开发中尽量不要使用，首先它的执行性能比较差，然后它还具有安全隐患<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eg:</span><br><span class="line"></span><br><span class="line">var str &#x3D; &#39;&#123;&quot;name&quot;:&quot;孙悟空&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;男&quot;&#125;&#39;;  </span><br><span class="line">var obj &#x3D; eval(&quot;(&quot;+str+&quot;)&quot;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>confirm()<ul>
<li>用于弹出一个带有确认和取消按钮的提示框，和alert一样，但是他有两个按钮</li>
<li>需要一个字符串作为参数，该字符串将会作为提示文字显示出来</li>
<li>如果用户点击确认则会返回true，如果点击取消则返回false</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端三大块</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Ajax</title>
    <url>/2020/07/16/Ajax/</url>
    <content><![CDATA[<blockquote>
<p>序<br><br>页面的局部刷新技术</p>
</blockquote>
<a id="more"></a>
<h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><ul>
<li><p>允许浏览器和服务器通信而无须刷新整个页面的技术</p>
</li>
<li><p>XMLHttpRequest:该对象是对JS的一个拓展，可使网页与服务器进行通信，是创建Ajax应用的最佳选择</p>
</li>
<li><p>Ajax实际上是几种技术以一种全新的方式聚合在一起：</p>
<ul>
<li>服务器端语言：服务器需要具备向浏览器发送特定信息的能力，Ajax与服务器端语言无关</li>
<li>XMl是一种描述数据的格式，Ajax需要某种格式化的格式来在服务器和客户端之间传递信息，XML就是其中的一种选择</li>
<li>XHTML使用扩展超媒体标记语言和CSS标准化呈现</li>
<li>DOM实现动态显示和交互</li>
<li>使用XMLHTTP组件XMLHttpRequest对象进行异步读取</li>
<li>使用JS进行绑定和处理数据</li>
</ul>
</li>
</ul>
<h2 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h2><ul>
<li>利用XMLHttpRequest实例与服务器进行通信包含三个关键的部分</li>
</ul>
<ol>
<li><p>onreadystatechang事件处理函数</p>
<ul>
<li>该函数由服务器触发，而不是用户</li>
<li>在Ajax执行过程中，服务器会通知客户端当前的通信状态，这依靠更新XMLHttpRequest对象的readyState来实现，改变readyState属性是服务器对客户端连接操作的一种方式，每次readyState属性的改变都会触发readystatechang事件</li>
</ul>
</li>
<li><p>open(method,url,asynch)方法</p>
<ul>
<li>open运行用一个Ajax调用向服务器发送请求</li>
<li>method：请求的类型<ul>
<li>GET从服务器检索一个文件，不需要发送任何数据</li>
<li>POST向服务器发送数据</li>
</ul>
</li>
<li>url:路径，指向你所请求的服务器上的那个文件，通常会在url后附一个时间戳来清除浏览器缓存，不清除的话下次访问的页面还是上次请求的页面不会改变</li>
<li>asynch：表示请求是否异步传输，默认值是true，在读取后面的脚本之前不需要等待服务器响应，指定false，当脚本处理过程经过这点时，会停下来等到Ajax请求完毕在继续执行</li>
</ul>
</li>
<li><p>send方法</p>
<ul>
<li>open方法定义了Ajax请求的一些细节，send方法可为已经待命的请求发送指令</li>
<li>如果用的是GET请求，不会发送任何数据，给send方法传递null即可</li>
<li>如果是POST请求，则要为send方法提供参数，如果没用参数用null代替</li>
</ul>
</li>
<li><p>sendRequestHeader(header,value)</p>
<ul>
<li>首部信息用来声明一个请求时GET还是POST</li>
<li>header首部的名字，value首部的值</li>
</ul>
</li>
</ol>
<h2 id="接收响应"><a href="#接收响应" class="headerlink" title="接收响应"></a>接收响应</h2><ol>
<li><p>readyState</p>
<ul>
<li>表示Ajax请求的当前状态<ul>
<li>0表示初始化，还没有调用open方法</li>
<li>1表示正在加载，open方法已调用，send方法还没调用</li>
<li>2表示已加载完毕，send方法已调用，请求开始了</li>
<li>3表示交互中，服务器正在发送响应</li>
<li>4表示完成，响应发送完毕</li>
</ul>
</li>
<li>每次readyState的值发生改变时，都会触发readystatechang事件</li>
<li>readystate值的变化会因浏览器的不同而有所差异，但是，当请求结束的时候，每个浏览器都会把readyState的值统一设置为4</li>
</ul>
</li>
<li><p>status</p>
<ul>
<li>服务器发送的每一个响应都带有首部信息，三位数的状态码是最重要的首部信息</li>
<li>常用状态码及其含义：<ul>
<li>404没找到页面</li>
<li>403禁止访问</li>
<li>500内部服务器错误</li>
<li>200一切正常</li>
<li>304没有被修改</li>
</ul>
</li>
<li>在XMLHttpRequest对象中，服务器发送的状态码都保存在status属性里，通过把这个值和200或304比较，可以确保服务器是否已发送了一个成功的响应</li>
</ul>
</li>
<li><p>responseText</p>
<ul>
<li>该属性包含了从服务器发送的数据，他可以是一个html，json或普通文本，这取决于服务器发送的内容</li>
<li>当readyState属性变成4时，responseText属性才可用，表示Ajax请求已经结束</li>
</ul>
</li>
<li><p>responseXML</p>
<ul>
<li>如果服务器返回的是xml，那么数据存储在该属性中</li>
</ul>
</li>
</ol>
<ul>
<li>若应用程序不需要与其他应用程序共享数据时，使用HTML来返回数据是最简单的</li>
<li>如果数据要重用，JSON文件在性能和文件大小上都有优势</li>
<li>如果远程应用程序未知时，XML文档是首选，因为XML是web服务领域的世界语</li>
</ul>
<h2 id="Ajax传输数据的三种方式："><a href="#Ajax传输数据的三种方式：" class="headerlink" title="Ajax传输数据的三种方式："></a>Ajax传输数据的三种方式：</h2><ol>
<li>XML：笨重，解析困难，但是XML是通用的数据交换形式</li>
<li>HTML:不需要解析就可以直接放到文档中，若仅仅更新一部分区域，但传输的数据不是很方便，且HTML代码需要拼接完成</li>
<li>JSON：小巧，有面向对象特征，且有json使用最广泛</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用ajax发送数据的五个步骤</span><br><span class="line">第一步：创建异步对象</span><br><span class="line">var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">第二步：设置请求方式和请求地址</span><br><span class="line">xhr.open(method,url,asynch);</span><br><span class="line"></span><br><span class="line">第三步：用send发送请求</span><br><span class="line">xhr.send(参数);</span><br><span class="line"></span><br><span class="line">第四步：监听状态变化</span><br><span class="line">xhr.onreadystatechang&#x3D;function()&#123;</span><br><span class="line"></span><br><span class="line">第五步：让异步对象接收服务器的响应数据</span><br><span class="line">if(xhr.status &#x3D;&#x3D; 200 &amp;&amp; xhr.readyState &#x3D;&#x3D; 4)&#123; </span><br><span class="line">console.log(xhr.responseText);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="jQuery实现Ajax"><a href="#jQuery实现Ajax" class="headerlink" title="jQuery实现Ajax"></a>jQuery实现Ajax</h1><ol>
<li><p>load(url, [data], [callback])</p>
<ul>
<li>载入远程 HTML 文件代码并插入至 DOM 中</li>
<li>任何一个html节点都可以使用load方法加载ajax，结果直接插入HTML节点中</li>
<li>url:待装入 HTML 网页网址。</li>
<li>data:发送至服务器的 key/value 数据，没传数据默认get方法，否则为post</li>
<li>callback:载入成功时回调函数。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var $obj&#x3D;...;</span><br><span class="line">var url...;</span><br><span class="line">var args&#x3D;&#123;key:value&#125;;</span><br><span class="line">$obj.load(url, args, [callback])</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>jQuery.get(url, [data], [callback], [type])</p>
<ul>
<li>通过远程 HTTP GET 请求载入信息</li>
<li>url:待载入页面的URL地址</li>
<li>data:待发送 Key/value 参数</li>
<li>callback:载入成功时回调函数</li>
<li>type:返回内容格式，xml, html, script, json, text, _default</li>
</ul>
</li>
<li><p>jQuery.post(url, [data], [callback], [type])</p>
<ul>
<li>通过远程 HTTP POST 请求载入信息</li>
<li>url:发送请求地址。</li>
<li>data:待发送 Key/value 参数。</li>
<li>callback:发送成功时回调函数。</li>
<li>type:返回内容格式，xml, html, script, json, text, _default。</li>
</ul>
</li>
<li><p>jQuery.getJSON(url, [data], [callback])</p>
<ul>
<li>通过 HTTP GET 请求载入 JSON 数据</li>
<li>url:发送请求地址。</li>
<li>data:待发送 Key/value 参数。</li>
<li>callback:载入成功时回调函数。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js</title>
    <url>/2020/07/11/NodeJS/</url>
    <content><![CDATA[<blockquote>
<p>序<br><br> Node.js是一个能够在服务器端运行js的开放源代码，跨平台的js运行平台</p>
</blockquote>
<a id="more"></a>
<h1 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h1><ul>
<li>Node是对ES标准一个实现，Node也是一个JS引擎</li>
<li>通过Node可以使js代码在服务器端执行</li>
<li>Node仅仅对ES标准进行了实现，所以在Node中不包含DOM 和 BOM    </li>
<li>Node中可以使用所有的内建对象</li>
</ul>
<ul>
<li>String Number Boolean Math Date RegExp Function Object Array</li>
<li>而BOM和DOM都不能使用</li>
<li>但是可以使用 console 也可以使用定时器（setTimeout() setInterval()）</li>
</ul>
<ul>
<li>node为js提供了许多服务器级别的API：<a href="http://nodejs.cn/api/" target="_blank" rel="noopener">http://nodejs.cn/api/</a><ul>
<li>文件操作的能力</li>
<li>http 服务的能力<br><img src="/2020/07/11/NodeJS/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%BB%91%E7%9B%92%E5%AD%90.png" alt></li>
</ul>
</li>
</ul>
<ul>
<li><p>Node可以在后台来编写服务器<br>Node编写服务器都是单线程的服务器</p>
<ul>
<li>进程<ul>
<li>进程就是一个一个的工作计划（工厂中的车间）</li>
</ul>
</li>
<li>线程<ul>
<li>线程是计算机最小的运算单位（工厂中的工人）<br>线程是干活的</li>
</ul>
</li>
</ul>
</li>
<li><p>传统的服务器都是多线程的</p>
<ul>
<li>每进来一个请求，就创建一个线程去处理请求</li>
</ul>
</li>
<li><p>Node的服务器单线程的</p>
<ul>
<li>Node处理请求时是单线程，但是在后台拥有一个I/O线程池</li>
</ul>
</li>
</ul>
<h1 id="http"><a href="#http" class="headerlink" title="http"></a>http</h1><ul>
<li>require</li>
<li>端口号<ul>
<li>ip 地址定位计算机</li>
<li>端口号定位具体的应用程序</li>
<li>端口号的范围从0-65536之间</li>
<li>可以同时开启多个服务，但是要确保端口号不一致才行</li>
</ul>
</li>
<li>Content-Type<ul>
<li>服务器最好把每次响应的数据是什么内容类型都告诉客户端，而且要正确的告诉</li>
<li>不同的资源对应的 Content-Type 是不一样，具体参照：<a href="http://tool.oschina.net/commons" target="_blank" rel="noopener">http://tool.oschina.net/commons</a></li>
<li>对于文本类型的数据，最好都加上编码，<strong>目的是为了防止中文解析乱码问题</strong></li>
</ul>
</li>
<li>通过网络发送文件<ul>
<li>发送的并不是文件，本质上来讲发送是文件的内容</li>
<li>当浏览器收到服务器响应内容之后，就会根据你的 Content-Type 进行对应的解析处理<br><img src="/2020/07/11/NodeJS/ip%E5%9C%B0%E5%9D%80%E5%92%8C%E7%AB%AF%E5%8F%A3%E5%8F%B7.png" alt></li>
</ul>
</li>
</ul>
<h2 id="简单的http服务"><a href="#简单的http服务" class="headerlink" title="简单的http服务"></a>简单的http服务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 加载 http 核心模块</span><br><span class="line">var http &#x3D; require(&#39;http&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2. 使用 http.createServer() 方法创建一个 Web 服务器</span><br><span class="line">&#x2F;&#x2F;    返回一个 Server 实例</span><br><span class="line">var server &#x3D; http.createServer()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3. 服务器要干嘛？</span><br><span class="line">&#x2F;&#x2F;    提供服务：对 数据的服务</span><br><span class="line">&#x2F;&#x2F;    发请求</span><br><span class="line">&#x2F;&#x2F;    接收请求</span><br><span class="line">&#x2F;&#x2F;    处理请求</span><br><span class="line">&#x2F;&#x2F;    给个反馈（发送响应）</span><br><span class="line">&#x2F;&#x2F;    注册 request 请求事件</span><br><span class="line">&#x2F;&#x2F;    当客户端请求过来，就会自动触发服务器的 request 请求事件，然后执行第二个参数：回调处理函数</span><br><span class="line">server.on(&#39;request&#39;, function () &#123;</span><br><span class="line">  console.log(&#39;收到客户端的请求了&#39;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 4. 绑定端口号，启动服务器</span><br><span class="line">server.listen(3000, function () &#123;</span><br><span class="line">  console.log(&#39;服务器启动成功了，可以通过 http:&#x2F;&#x2F;127.0.0.1:3000&#x2F; 来进行访问&#39;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>打开终端使用node执行<br><img src="NodeJS/http.png" alt></p>
</li>
<li><p>停止服务</p>
<ul>
<li>可以ctrl + v</li>
<li>还可以找到端口的进程并taskkill掉</li>
<li>netstat -ano | find “:3000”</li>
<li>taskkill /F /PID 找到的pid</li>
</ul>
</li>
<li><p>发送请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var http &#x3D; require(&#39;http&#39;)</span><br><span class="line"></span><br><span class="line">var server &#x3D; http.createServer()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; request 请求事件处理函数，需要接收两个参数：</span><br><span class="line">&#x2F;&#x2F;    Request 请求对象</span><br><span class="line">&#x2F;&#x2F;        请求对象可以用来获取客户端的一些请求信息，例如请求路径</span><br><span class="line">&#x2F;&#x2F;    Response 响应对象</span><br><span class="line">&#x2F;&#x2F;        响应对象可以用来给客户端发送响应消息</span><br><span class="line">server.on(&#39;request&#39;, function (request, response) &#123;</span><br><span class="line">  &#x2F;&#x2F; http:&#x2F;&#x2F;127.0.0.1:3000&#x2F; </span><br><span class="line">  &#x2F;&#x2F; http:&#x2F;&#x2F;127.0.0.1:3000&#x2F;a 返回&#x2F;a</span><br><span class="line">  &#x2F;&#x2F; http:&#x2F;&#x2F;127.0.0.1:3000&#x2F;foo&#x2F;b 返回&#x2F;foo&#x2F;b</span><br><span class="line">  &#x2F;&#x2F; 在浏览器中的端口号后面输入什么，请求路径就返回什么</span><br><span class="line">  console.log(&#39;收到客户端的请求了，请求路径是：&#39; + request.url)</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; response 对象有一个方法：write 可以用来给客户端发送响应数据</span><br><span class="line">  &#x2F;&#x2F; write 可以使用多次，但是最后一定要使用 end 来结束响应，否则客户端会一直等待</span><br><span class="line">  response.write(&#39;hello&#39;)</span><br><span class="line">  response.write(&#39; nodejs&#39;)</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 告诉客户端，我的话说完了，你可以呈递给用户了</span><br><span class="line">  response.end()</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(3000, function () &#123;</span><br><span class="line">  console.log(&#39;服务器启动成功了，可以通过 http:&#x2F;&#x2F;127.0.0.1:3000&#x2F; 来进行访问&#39;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>改完代码后要重启服务才生效</strong></p>
</li>
</ul>
<h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><ul>
<li>ES5中没有原生支持模块化，我们只能通过script标签引入js文件来实现模块化</li>
<li>在node中为了对模块管理，引入了CommonJS规范</li>
</ul>
<h2 id="模块的引用"><a href="#模块的引用" class="headerlink" title="模块的引用"></a>模块的引用</h2><ul>
<li>使用 require()函数来引入一个模块</li>
<li>例子：<br>var 变量 = require(“模块的标识”);</li>
</ul>
<h2 id="模块的定义"><a href="#模块的定义" class="headerlink" title="模块的定义"></a>模块的定义</h2><ul>
<li><p>在node中一个js文件就是一个模块</p>
</li>
<li><p>默认情况下在js文件中编写的内容，都是运行在一个独立的函数中，<br>外部的模块无法访问</p>
</li>
<li><p>导出变量和函数</p>
<ul>
<li><p>使用 exports </p>
</li>
<li><p>通过exports只能使用.的方式来向外暴露内部变量</p>
<ul>
<li>例子：<ul>
<li>exports.属性 = 属性值;</li>
<li>exports.方法 = 函数;</li>
</ul>
</li>
</ul>
</li>
<li><p>使用module.exports</p>
</li>
<li><p>而module.exports既可以通过.的形式，也可以直接赋值</p>
<ul>
<li>例子：<ul>
<li>module.exports.属性 = 属性值;</li>
<li>module.exports.方法 = 函数;</li>
<li>module.exports = {};</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="模块的标识"><a href="#模块的标识" class="headerlink" title="模块的标识"></a>模块的标识</h2><ul>
<li><p>模块的标识就是模块的名字或路径</p>
</li>
<li><p>我们node通过模块的标识来寻找模块的</p>
</li>
<li><p>模块分成两大类</p>
<ul>
<li><p>核心模块</p>
<ul>
<li>由node引擎提供的模块</li>
<li>核心模块的标识就是，模块的名字</li>
</ul>
<ul>
<li>对于核心模块（npm中下载的模块），直接使用模块的名字对其进行引入<ul>
<li>var fs = require(“fs”);</li>
<li>var express = require(“express”);</li>
</ul>
</li>
</ul>
</li>
<li><p>文件模块</p>
<ul>
<li>由用户自己创建的模块   </li>
<li>对于自定义的文件模块，需要通过文件的路径来对模块进行引入,路径可以是绝对路径，如果是相对路径必须以./或 ../开头<br>var router = require(“./router”);</li>
</ul>
</li>
</ul>
</li>
<li><p>当node在执行模块中的代码时，它会首先在代码的最顶部，添加如下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function (exports, require, module, __filename, __dirname) &#123;</span><br><span class="line">在代码的最底部，添加如下代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>实际上模块中的代码都是包装在一个函数中执行的，并且在函数执行时，同时传递进了5个实参</p>
<ul>
<li><p>exports</p>
<ul>
<li>该对象用来将变量或函数暴露到外部</li>
</ul>
</li>
<li><p>require</p>
<ul>
<li>函数，用来引入外部的模块</li>
</ul>
</li>
<li><p>module</p>
<ul>
<li>module代表的是当前模块本身</li>
<li>exports就是module的属性</li>
<li>既可以使用 exports 导出，也可以使用module.exports导出</li>
</ul>
</li>
<li><p>__filename</p>
<ul>
<li>当前模块的完整路径</li>
</ul>
</li>
<li><p>__dirname</p>
<ul>
<li>当前模块所在文件夹的完整路径</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><ul>
<li>将多个模块组合为一个完整的功能，就是一个包</li>
<li>包结构<ul>
<li>bin<ul>
<li>二进制的可执行文件，一般都是一些工具包中才有</li>
</ul>
</li>
<li>lib<ul>
<li>js文件</li>
</ul>
</li>
<li>doc<ul>
<li>文档</li>
</ul>
</li>
<li>test<ul>
<li>测试代码</li>
</ul>
</li>
<li>package.json<ul>
<li>包的描述文件</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><ul>
<li>它是一个json格式的文件，在它里面保存了包各种相关的信息<ul>
<li>name 包名</li>
<li>version 版本</li>
<li>dependencies 依赖</li>
<li>main 包的主要的文件</li>
<li>bin 可执行文件</li>
</ul>
</li>
</ul>
<h2 id="npm（Node-Package-Manager-node的包管理器）"><a href="#npm（Node-Package-Manager-node的包管理器）" class="headerlink" title="npm（Node Package Manager node的包管理器）"></a>npm（Node Package Manager node的包管理器）</h2><ul>
<li>通过npm可以对node中的包进行上传、下载、搜索等操作</li>
<li>npm会在安装完node以后，自动安装</li>
<li>npm的常用指令<ul>
<li>npm -v 查看npm的版本</li>
<li>npm version 查看所有模块的版本</li>
<li>npm init 初始化项目（创建package.json）</li>
<li>npm i/install 包名 安装指定的包</li>
<li>npm i/install 包名 –save 安装指定的包并添加依赖(写在json文件里，下次下载自动下载依赖的包)</li>
<li>npm i/install 包名 -g 全局安装（一般都是一些工具）</li>
<li>npm i/install 安装当前项目所依赖的包</li>
<li>npm s/search 包名 搜索包    </li>
<li>npm r/remove 包名 删除一个包</li>
<li>$ npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a> 淘宝镜像（从国外的npm服务器复制一份作为镜像来供国内使用，提高下载速度，以后使用淘宝镜像就是执行cnpm指令，使用npm连接的是国外服务器）</li>
</ul>
</li>
</ul>
<ul>
<li><p>通过npm下载的包都放到node_modules文件夹中</p>
<ul>
<li>我们通过npm下载的包，直接通过包名引入即可</li>
</ul>
</li>
<li><p>node在使用模块名字来引入模块时，它会首先在当前目录的node_modules中寻找是否含有该模块</p>
<ul>
<li>如果有则直接使用，如果没有则去上一级目录的node_modules中寻找</li>
<li>如果有则直接使用，如果没有则再去上一级目录寻找，直到找到为止</li>
<li>直到找到磁盘的根目录，如果依然没有，则报错</li>
</ul>
</li>
</ul>
<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="Buffer（缓冲区）"><a href="#Buffer（缓冲区）" class="headerlink" title="Buffer（缓冲区）"></a>Buffer（缓冲区）</h2><ul>
<li>Buffer和数组的结构的非常类似，Buffer是用来存储二进制数据的</li>
<li>数组中不能存储二进制的文件，而buffer就是专门用来存储二进制数据</li>
<li>使用buffer不需要引入模块，直接使用即可</li>
<li>在buffer中存储的都是二进制数据，但是在显示时都是以16进制的形式显示</li>
<li>Buffer的方法<ul>
<li>Buffer.from(字符串)<ul>
<li>将一个字符串中内容保存到一个buffer中</li>
</ul>
</li>
<li>buf.toString()<ul>
<li>将buffer转换为一个字符串</li>
</ul>
</li>
<li>Buffer.alloc(size)<ul>
<li>创建一个指定大小的buffer对象</li>
</ul>
</li>
<li>Buffer.allocUnsafe(size)<ul>
<li>创建一个指定大小的buffer对象，可以包含敏感数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="fs模块"><a href="#fs模块" class="headerlink" title="fs模块"></a>fs模块</h2><ul>
<li><p>在Node通过fs模块来对系统中的文件进行操作，fs模块是node中已经继承好了，不需要在使用npm下载，直接引入即可</p>
</li>
<li><p>引入fs</p>
<ul>
<li>var fs = require(“fs”);</li>
</ul>
</li>
<li><p>fs模块中的大部分操作都提供了两种方法，同步方法和异步方法</p>
<ul>
<li>同步方法带sync</li>
<li>同步文件系统会阻塞程序的执行，也就是除非操作完毕，否则不会向下执行代码</li>
<li>异步方法没有sync，都需要回调函数</li>
<li>异步文件系统不会阻塞程序的执行，而是在操作完成时，通过回调函数将结果返回</li>
</ul>
</li>
<li><p>写入文件</p>
<ol>
<li>同步写入</li>
<li>异步写入</li>
<li>简单写入</li>
<li>流式写入</li>
</ol>
</li>
<li><p>读取文件</p>
<ol>
<li>同步读取</li>
<li>异步读取</li>
<li>简单读取</li>
<li>流式读取</li>
</ol>
</li>
<li><p>方法</p>
</li>
<li><p>打开文件</p>
<ul>
<li>fs.open(path, flags[, mode], callback)<ul>
<li>回调函数两个参数：<ul>
<li>err 错误对象，如果没有错误则为null</li>
<li>fd  文件的描述符</li>
</ul>
</li>
</ul>
</li>
<li>fs.openSync(path, flags[, mode])<ul>
<li>path 要打开文件的路径</li>
<li>flags 打开文件要做的操作的类型<ul>
<li>r 只读的</li>
<li>w 可写的</li>
</ul>
</li>
<li>mode 设置文件的操作权限，一般不传</li>
</ul>
<ul>
<li>返回值：该方法会返回一个文件的描述符作为结果，我们可以通过该描述符来对文件进行各种操作</li>
</ul>
</li>
</ul>
</li>
<li><p>读写文件</p>
<ul>
<li><p>fs.write(fd, string[, position[, encoding]], callback)</p>
</li>
<li><p>fs.writeSync(fd, string[, position[, encoding]])</p>
<ul>
<li>fd 文件的描述符，需要传递要写入的文件的描述符</li>
<li>string 要写入的内容</li>
<li>position 写入的起始位置</li>
<li>encoding 写入的编码，默认utf-8</li>
</ul>
</li>
<li><p>fs.read(fd, buffer, offset, length, position, callback)</p>
</li>
<li><p>fs.readSync(fd, buffer, offset, length, position)</p>
</li>
</ul>
</li>
<li><p>关闭文件</p>
<ul>
<li>fs.close(fd,callback)</li>
<li>fs.closeSync(fd);</li>
</ul>
</li>
<li><p>简单文件读取和写入</p>
<ul>
<li><p>fs.writeFile(file, data[, options], callback)</p>
</li>
<li><p>fs.writeFileSync(file, data[, options])</p>
<ul>
<li>file 要操作的文件的路径</li>
<li>data 要写入的数据</li>
<li>options 选项，可以对写入进行一些设置<ul>
<li>encoding <string> | <null> 默认值: ‘utf8’。</null></string></li>
<li>mode <integer> 默认值: 0o666。</integer></li>
<li>flag <string> 参见文件系统 flag 的支持。 默认值: ‘w’( r 只读,w 可写,a 追加)</string></li>
</ul>
</li>
<li>callback 当写入完成以后执行的函数</li>
</ul>
</li>
<li><p>fs.readFile(path[, options], callback)</p>
</li>
<li><p>fs.readFileSync(path[, options])</p>
<ul>
<li>path 要读取的文件的路径<ul>
<li>options 读取的选项</li>
<li>callback回调函数，通过回调函数将读取到内容返回(err , data)<ul>
<li>err 错误对象</li>
<li>data 读取到的数据，会返回一个Buffer</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>流式文件读取和写入</p>
</li>
</ul>
<ul>
<li>同步、异步、简单文件的写入都不适合大文件的写入，性能较差，容易导致内存溢出</li>
</ul>
<ul>
<li>流式读取和写入适用于一些比较大的文件</li>
</ul>
<ul>
<li>可以通过监听流的open和close事件来监听流的打开和关闭<ul>
<li>on(事件字符串,回调函数)<ul>
<li>可以为对象绑定一个事件</li>
</ul>
</li>
<li>once(事件字符串,回调函数)<ul>
<li>可以为对象绑定一个一次性的事件，该事件将会在触发一次以后自动失效</li>
</ul>
</li>
</ul>
</li>
<li>fs.createWriteStream(path[, options])<ul>
<li>可以用来创建一个可写流</li>
<li>path，文件路径</li>
<li>options 配置的参数</li>
</ul>
</li>
<li>fs.createReadStream(path[, options])</li>
<li>pipe()可以将可读流中的内容，直接输出到可写流中rs.pipe(ws);</li>
</ul>
<h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><ul>
<li><p>验证路径是否存在</p>
<ul>
<li>fs.exists(path，callback)</li>
<li>fs.existsSync(path)</li>
</ul>
</li>
<li><p>获取文件信息</p>
<ul>
<li>fs.stat(path, callback)</li>
<li>fs.statSync(path)</li>
</ul>
</li>
<li><p>删除文件</p>
<ul>
<li>fs.unlink(path, callback)</li>
<li>fs.unlinkSync(path)</li>
</ul>
</li>
<li><p>列出文件</p>
<ul>
<li>fs.readdir(path[, options], callback)</li>
<li>fs.readdirSync(path[, options])</li>
</ul>
</li>
<li><p>截断文件</p>
<ul>
<li>fs.truncate(path, len, callback)</li>
<li>fs.truncateSync(path, len)</li>
</ul>
</li>
<li><p>建立目录</p>
<ul>
<li>fs.mkdir(path[, mode], callback)</li>
<li>fs.mkdirSync(path[, mode])</li>
</ul>
</li>
<li><p>删除目录</p>
<ul>
<li>fs.rmdir(path, callback)</li>
<li>fs.rmdirSync(path)</li>
</ul>
</li>
<li><p>重命名文件和目录</p>
<ul>
<li>fs.rename(oldPath, newPath, callback)</li>
<li>fs.renameSync(oldPath, newPath)</li>
</ul>
</li>
<li><p>监视文件更改写入</p>
<ul>
<li>fs.watchFile(filename[, options], listener)</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>后台服务器端</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB</title>
    <url>/2020/07/13/MongoDB/</url>
    <content><![CDATA[<blockquote>
<p>序<br><br>MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</p>
</blockquote>
<a id="more"></a>
<h1 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h1><ul>
<li><p>打开cmd命令行窗口</p>
<ul>
<li>输入 mongod 启动mongodb服务器</li>
</ul>
</li>
<li><p>在打开一个cmd窗口</p>
<ul>
<li>输入 mongo 连接mongodb ，出现 &gt; </li>
</ul>
</li>
<li><p>还可以自定义data存储的路径和端口</p>
<ul>
<li>mongod –dbpath 数据库路径 –port 端口号</li>
</ul>
</li>
<li><p>将MongoDB设置为系统服务，可以自动在后台启动，不需要每次都手动启动</p>
<ul>
<li><p>在此之前在data目录下新建db和log文件夹，在D:\mongoDB\serve\3.2\目录下创建mongod.cfg,并写入</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> systemLog:</span><br><span class="line">destination: file</span><br><span class="line">path: D:\data\log\mongod.log</span><br><span class="line"> storage:</span><br><span class="line">dbPath: D:\data\db</span><br></pre></td></tr></table></figure></li>
<li><p>以管理员身份打开命令行窗口，执行如下的命令</p>
<ul>
<li><p>sc.exe create MongoDB binPath= “&quot;D:\mongoDB\serve\3.2\bin\mongod.exe&quot; –service –config=&quot;D:\mongoDB\serve\3.2\mongod.cfg&quot;“ DisplayName= “MongoDB” start= “auto”</p>
</li>
<li><p>sc.exe create MongoDB binPath= “&quot;mongod的bin目录\mongod.exe&quot; –service –config=&quot;mongo的安装目录\mongod.cfg&quot;“ DisplayName= “MongoDB” start= “auto”</p>
</li>
</ul>
</li>
<li><p>在任务管理器启动mongodb服务</p>
</li>
</ul>
</li>
</ul>
<h2 id="数据库（database）"><a href="#数据库（database）" class="headerlink" title="数据库（database）"></a>数据库（database）</h2><ul>
<li><p>数据库的服务器</p>
<ul>
<li>服务器用来保存数据</li>
<li>mongod 用来启动服务器</li>
</ul>
</li>
<li><p>数据库的客户端</p>
<ul>
<li>客户端用来操作服务器，对数据进行增删改查的操作</li>
<li>mongo 用来启动客户端</li>
</ul>
</li>
<li><p>基本概念</p>
<ul>
<li>数据库（database）</li>
<li>集合（collection）</li>
<li>文档（document）<ul>
<li>在MongoDB中，数据库和集合都不需要手动创建，<br>  当我们创建文档时，如果文档所在的集合或数据库不存在会自动创建数据库和集合    </li>
</ul>
</li>
<li>Scheme、model、collection、document是其中的四大元素。document是MongoDB里的基本存储单位，collection是众多同类document的集合。Schema定义了一类document的模板，让这一类document在数据库中有一个具体的构成、存储模式。而Schema仅仅是定义了Document是什么样子的，至于生成document和对document进行各种操作（增删改查）则是通过相对应的model来进行的</li>
</ul>
</li>
</ul>
<p><img src="/2020/07/13/MongoDB/mongo.png" alt></p>
<ul>
<li>基本指令<ul>
<li>show dbs</li>
<li>show databases<ul>
<li>显示当前的所有数据库</li>
</ul>
</li>
<li>use 数据库名<ul>
<li>进入到指定的数据库中</li>
</ul>
</li>
<li>db<ul>
<li>db表示的是当前所处的数据库</li>
</ul>
</li>
<li>show collections<ul>
<li>显示数据库中所有的集合</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="数据库的CRUD（增删改查）的操作"><a href="#数据库的CRUD（增删改查）的操作" class="headerlink" title="数据库的CRUD（增删改查）的操作"></a>数据库的CRUD（增删改查）的操作</h1><p><a href="https://docs.mongodb.com/manual/crud/" target="_blank" rel="noopener">MongoDB官方文档</a></p>
<h2 id="插入文档"><a href="#插入文档" class="headerlink" title="插入文档"></a>插入文档</h2><ul>
<li><p>db.collection.insert()</p>
<ul>
<li>向集合中插入一个或多个文档</li>
<li>当我们向集合中插入文档时，如果没有给文档指定_id属性，则数据库会自动为文档添加_id，该属性用来作为文档的唯一标识</li>
<li>_id我们可以自己指定，如果我们指定了数据库就不会在添加了，如果自己指定_id 也必须确保它的唯一性</li>
</ul>
</li>
<li><p>db.collection.insertOne()</p>
<ul>
<li>插入一个文档对象</li>
</ul>
</li>
<li><p>db.collection.insertMany() </p>
<ul>
<li>插入多个文档对象</li>
</ul>
</li>
</ul>
<h2 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h2><ul>
<li><p>db.collection.remove()</p>
<ul>
<li>删除一个或多个，可以第二个参数传递一个true，则只会删除一个</li>
<li>如果传递一个空对象{}作为参数，则会删除所有的</li>
</ul>
</li>
<li><p>db.collection.deleteOne()</p>
</li>
<li><p>db.collection.deleteMany()</p>
</li>
<li><p>db.collection.drop() </p>
<ul>
<li>删除集合</li>
</ul>
</li>
<li><p>db.dropDatabase() </p>
<ul>
<li>删除数据库</li>
</ul>
</li>
<li><p>一般数据库中的数据都不会删除，所以删除的方法很少调用</p>
</li>
<li><p>一般会在数据中添加一个字段，来表示数据是否被删除</p>
</li>
</ul>
<h2 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h2><ul>
<li><p>db.collection.find()</p>
<ul>
<li>find()用来查询集合中所有符合条件的文档</li>
<li>find()可以接收一个对象作为条件参数<ul>
<li>{} 表示查询集合中所有的文档</li>
<li>{属性:值} 查询属性是指定值的文档</li>
</ul>
</li>
<li>find()返回的是一个数组</li>
</ul>
</li>
<li><p>db.collection.findOne()</p>
<ul>
<li>用来查询集合中符合条件的第一个文档  </li>
<li>findOne()返回的是一个文档对象 </li>
</ul>
</li>
<li><p>db.collection.find({}).count() </p>
<ul>
<li>查询所有结果的数量</li>
</ul>
</li>
<li><p>MongoDB支持直接通过内嵌文档的属性进行查询，如果要查询内嵌文档则可以通过.的形式来匹配</p>
</li>
<li><p>如果要通过内嵌文档来对文档进行查询，此时属性名必须使用引号</p>
</li>
<li><p>查询文档时，默认情况是按照_id的值进行排列（升序）</p>
<ul>
<li>sort()可以用来指定文档的排序的规则,sort()需要传递一个对象来指定排序规则 1表示升序 -1表示降序</li>
<li>limit skip sort 可以以任意的顺序进行调用</li>
<li>在查询时，可以在第二个参数的位置来设置查询结果的<strong>投影</strong>，1表示显示该字段，0表示不显示</li>
</ul>
</li>
</ul>
<h2 id="修改文档"><a href="#修改文档" class="headerlink" title="修改文档"></a>修改文档</h2><ul>
<li><p>db.collection.update(查询条件,新对象)</p>
<ul>
<li>update()默认情况下会使用新对象来替换旧的对象</li>
<li>如果需要修改指定的属性，而不是替换需要使用“修改操作符”来完成修改</li>
<li>update()默认只会修改一个</li>
</ul>
</li>
<li><p>db.collection.updateMany()</p>
<ul>
<li>同时修改多个符合条件的文档</li>
</ul>
</li>
<li><p>db.collection.updateOne()</p>
<ul>
<li>修改一个符合条件的文档    </li>
</ul>
</li>
<li><p>db.collection.replaceOne()</p>
<ul>
<li>替换一个文档</li>
</ul>
</li>
</ul>
<h2 id="修改器"><a href="#修改器" class="headerlink" title="修改器"></a>修改器</h2><ul>
<li>$set<ol>
<li>修改器用来指定一个键值。如果这个键不存在，则创建他</li>
<li>修改内嵌文档</li>
</ol>
</li>
<li>$unset      <ul>
<li>用于将键删除</li>
</ul>
</li>
<li>$push <ul>
<li>用于向数组中添加一个新的元素</li>
</ul>
</li>
<li>$addToSet <ul>
<li>向数组中添加一个新元素，如果数组中已经存在了该元素，则不会添加</li>
</ul>
</li>
<li>$each       <ul>
<li>和$addToSet修改结合起来用，可以一次添加多个不同的值</li>
</ul>
</li>
<li>$pop        <ul>
<li>从数组中删除元素，他可以从数组中的任何一端删除元素</li>
</ul>
</li>
<li>$pull       <ul>
<li>基于特定条件来删除元素。</li>
</ul>
</li>
<li>$inc        <ul>
<li>用来增加或减少已有的键的键值(（只能为满足要求的数字）)，或者在键不存在的时候创建一个键</li>
</ul>
</li>
<li>$ne         <ul>
<li>如果一个值不在数组里面就把他加进去，如果在不添加</li>
</ul>
</li>
<li>$gt:大于</li>
<li>$lt:小于</li>
<li>$gte:大于或等于</li>
<li>$lte:小于或等于</li>
<li>$inc:自增</li>
</ul>
<h1 id="Mongoose"><a href="#Mongoose" class="headerlink" title="Mongoose"></a>Mongoose</h1><ul>
<li><strong>Mongoose就是一个让我们可以通过node来操作mongodb的模块</strong></li>
<li><a href="https://mongoosejs.com/docs/guide.html" target="_blank" rel="noopener">Mongoose官方文档</a></li>
</ul>
<ol>
<li><p>下载安装Mongoose</p>
<ul>
<li>npm i mongoose –save</li>
</ul>
</li>
<li><p>在项目中引入mongoose</p>
<ul>
<li>var mongoose = require(“mongoose”);</li>
</ul>
</li>
<li><p>连接MongoDB数据库</p>
<ul>
<li>mongoose.connect(‘mongodb://数据库的ip地址:端口号/数据库名’, { useMongoClient: true});</li>
<li>如果端口号是默认端口号（27017） 则可以省略不写</li>
</ul>
</li>
<li><p>断开数据库连接(一般不需要调用)</p>
<ul>
<li><p>MongoDB数据库，一般情况下，只需要连接一次，连接一次以后，除非项目停止服务器关闭，否则连接一般不会断开</p>
<ul>
<li>mongoose.disconnect()</li>
</ul>
</li>
<li><p>监听MongoDB数据库的连接状态</p>
<ul>
<li>在mongoose对象中，有一个属性叫做connection，该对象表示的就是数据库连接，通过监视该对象的状态，可以来监听数据库的连接与断开</li>
</ul>
</li>
</ul>
<ul>
<li><p>数据库连接成功的事件</p>
<ul>
<li>mongoose.connection.once(“open”,function(){});</li>
</ul>
</li>
<li><p>数据库断开的事件</p>
<ul>
<li>mongoose.connection.once(“close”,function(){});</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例子：</span><br><span class="line">&#x2F;&#x2F;将mongoose.Schema 赋值给一个变量</span><br><span class="line">var Schema &#x3D; mongoose.Schema;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建Schema（模式）对象</span><br><span class="line">var stuSchema &#x3D; new Schema(&#123;</span><br><span class="line"></span><br><span class="line">	name:String,</span><br><span class="line">	age:Number,</span><br><span class="line">	gender:&#123;</span><br><span class="line">		type:String,</span><br><span class="line">		default:&quot;female&quot;</span><br><span class="line">        &#x2F;&#x2F;默认值为female</span><br><span class="line">	&#125;,</span><br><span class="line">	address:String</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><ul>
<li>有了Model，我们就可以来对数据库进行增删改查的操作了</li>
</ul>
<ul>
<li><p>Model.create(doc(s), [callback])</p>
<ul>
<li>用来创建一个或多个文档并添加到数据库中</li>
<li>参数：<ul>
<li>doc(s) 可以是一个文档对象，也可以是一个文档对象的数组</li>
<li>callback 当操作完成以后调用的回调函数</li>
</ul>
</li>
</ul>
</li>
<li><p>查询：</p>
<ul>
<li><p>通过find()查询的结果，返回的对象，就是Document文档对象</p>
</li>
<li><p>Model.find(conditions, [projection], [options], [callback])</p>
<ul>
<li>查询所有符合条件的文档 总会返回一个数组</li>
</ul>
</li>
<li><p>Model.findById(id, [projection], [options], [callback])</p>
<ul>
<li>根据文档的id属性查询文档</li>
</ul>
</li>
<li><p>Model.findOne([conditions], [projection], [options], [callback])</p>
<ul>
<li><p>查询符合条件的第一个文档 总和返回一个具体的文档对象</p>
<ul>
<li>conditions 查询的条件</li>
<li>projection 投影 需要获取到的字段<ul>
<li>两种方式<ul>
<li>{name:1,_id:0}</li>
<li>“name -_id”</li>
</ul>
</li>
</ul>
</li>
<li>options  查询选项（skip limit）//跳过，显示的最大数量{skip:3 , limit:1}</li>
<li>callback 回调函数，查询结果会通过回调函数返回</li>
<li>回调函数必须传，如果不传回调函数，压根不会查询</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>修改</p>
<ul>
<li>Model.update(conditions, doc, [options], [callback])</li>
<li>Model.updateMany(conditions, doc, [options], [callback])</li>
<li>Model.updateOne(conditions, doc, [options], [callback])<ul>
<li>用来修改一个或多个文档</li>
<li>参数：<ul>
<li>conditions 查询条件</li>
<li>doc 修改后的对象</li>
<li>options 配置参数</li>
<li>callback 回调函数</li>
</ul>
</li>
</ul>
</li>
<li>Model.replaceOne(conditions, doc, [options], [callback])</li>
</ul>
</li>
<li><p>删除：</p>
<ul>
<li>Model.remove(conditions, [callback])</li>
<li>Model.deleteOne(conditions, [callback])</li>
<li>Model.deleteMany(conditions, [callback])</li>
</ul>
</li>
<li><p>统计文档的数量 </p>
<ul>
<li>Model.count(conditions, [callback])</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例子：</span><br><span class="line">&#x2F;&#x2F;通过Schema来创建Model</span><br><span class="line">&#x2F;&#x2F;Model代表的是数据库中的集合，通过Model才能对数据库进行操作</span><br><span class="line">&#x2F;&#x2F;mongoose.model(modelName, schema):</span><br><span class="line">&#x2F;&#x2F;modelName 就是要映射的集合名 mongoose会自动将集合名变成复数</span><br><span class="line">var StuModel &#x3D; mongoose.model(&quot;student&quot; , stuSchema);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;向数据库中插入一个文档</span><br><span class="line">&#x2F;&#x2F;StuModel.create(doc, function(err)&#123;&#125;);</span><br><span class="line">StuModel.create(&#123;</span><br><span class="line">	name:&quot;白骨精&quot;,</span><br><span class="line">	age:16,</span><br><span class="line">	address:&quot;白骨洞&quot;</span><br><span class="line">&#125;,function (err) &#123;</span><br><span class="line">	if(!err)&#123;</span><br><span class="line">		console.log(&quot;插入成功~~~&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h2 id="Document"><a href="#Document" class="headerlink" title="Document"></a>Document</h2><ul>
<li>Document对象是Model的实例（可以用instanceof验证）</li>
<li>Document 和 集合中的文档一一对应 ， Document是Model的实例<ul>
<li>通过Model查询到结果都是Document</li>
</ul>
</li>
<li>document的方法<ul>
<li>Model#save([options], [function])<ul>
<li>和model的create作用相同，但是document只能用save<ul>
<li>update(update,[options],[callback])</li>
</ul>
</li>
</ul>
<ul>
<li>修改对象<ul>
<li>remove([callback])</li>
</ul>
</li>
<li>删除对象<ul>
<li>get(name)</li>
</ul>
</li>
<li>获取文档中的指定属性值<ul>
<li>set(name , value)</li>
</ul>
</li>
<li>设置文档的指定的属性值<ul>
<li>id</li>
</ul>
</li>
<li>获取文档的_id属性值<ul>
<li>toJSON() </li>
</ul>
</li>
<li>转换为一个JSON对象//不一定生效<ul>
<li>toObject()</li>
</ul>
</li>
<li>将Document对象转换为一个普通的JS对象</li>
<li>转换为普通的js对象以后，注意所有的Document对象的方法或属性都不能使用了<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2></li>
</ul>
</li>
</ul>
</li>
<li>定义一个连接数据库的模块<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var mongoose &#x3D; require(&quot;mongoose&quot;);</span><br><span class="line">mongoose.connect(&quot;mongodb:&#x2F;&#x2F;数据库的ip地址:端口号&#x2F;数据库名&quot;,&#123;useMongoClient:true&#125;);</span><br><span class="line">mongoose.connection.once(&quot;open&quot;,function () &#123;</span><br><span class="line">	console.log(&quot;数据库连接成功~~~&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li>其他模块直接通过require引入该模块即可</li>
</ul>
]]></content>
      <categories>
        <category>后台服务器端</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>JS高级</title>
    <url>/2020/07/08/JS%E9%AB%98%E7%BA%A7/</url>
    <content><![CDATA[<blockquote>
<p>序<br><br>js进阶-&gt;上流JS</p>
</blockquote>
<a id="more"></a>
<h1 id="JS基础总结深入"><a href="#JS基础总结深入" class="headerlink" title="JS基础总结深入"></a>JS基础总结深入</h1><h2 id="数据类型的分类和判断"><a href="#数据类型的分类和判断" class="headerlink" title="数据类型的分类和判断"></a>数据类型的分类和判断</h2><table>
<thead>
<tr>
<th>数据类型</th>
<th>定义</th>
<th>类型判断</th>
</tr>
</thead>
<tbody><tr>
<td>基本(值)类型</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Number</td>
<td>任意数值</td>
<td>typeof</td>
</tr>
<tr>
<td>String</td>
<td>任意字符串</td>
<td>typeof</td>
</tr>
<tr>
<td>Boolean</td>
<td>true/false</td>
<td>typeof</td>
</tr>
<tr>
<td>undefined</td>
<td>undefined</td>
<td>typeof/===</td>
</tr>
<tr>
<td>null</td>
<td>null</td>
<td>===</td>
</tr>
<tr>
<td>对象(引用)类型</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Object</td>
<td>任意对象</td>
<td>typeof/instanceof</td>
</tr>
<tr>
<td>Array</td>
<td>一种特别的对象(索引，内部是有序的)</td>
<td>instanceof</td>
</tr>
<tr>
<td>Function</td>
<td>一种特别的对象(可以执行)</td>
<td>typeof</td>
</tr>
</tbody></table>
<ul>
<li><p>判断</p>
<ul>
<li>typeof:<ul>
<li>可以区别: 数值, 字符串, 布尔值, undefined, function</li>
<li>不能区别: null与对象, 一般对象与数组</li>
</ul>
</li>
<li>instanceof<ul>
<li>专门用来判断对象数据的类型: Object, Array与Function</li>
</ul>
</li>
<li>===<ul>
<li>可以判断: undefined和null</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>相关问题</strong></p>
</li>
</ul>
<ol>
<li>undefined与null的区别?</li>
</ol>
<ul>
<li>undefined代表没有赋值</li>
<li>null代表赋值了, 只是值为null</li>
</ul>
<ol start="2">
<li>什么时候给变量赋值为null呢?</li>
</ol>
<ul>
<li>var a = null //初始赋值为null，表明将要赋值为对象，a将指向一个对象,<br>但对象此时还没有确定</li>
<li>a = null //让a指向的对象成为垃圾对象(被垃圾回收器回收)</li>
</ul>
<ol start="3">
<li>严格区别变量类型与数据类型?</li>
</ol>
<ul>
<li>js的变量本身是没有类型的, 变量的类型实际上是变量内存中数据的类型</li>
<li>变量类型:<ul>
<li>基本类型: 保存基本类型数据</li>
<li>引用类型: 保存对象地址值</li>
</ul>
</li>
<li>数据对象<ul>
<li>基本类型</li>
<li>对象类型</li>
</ul>
</li>
</ul>
<h2 id="数据-变量-内存的理解"><a href="#数据-变量-内存的理解" class="headerlink" title="数据-变量-内存的理解"></a>数据-变量-内存的理解</h2><ol>
<li><p>什么是数据?</p>
<ul>
<li>存储于内存中代表特定信息的’东东’, 本质就是0101二进制</li>
<li>具有可读和可传递的基本特性</li>
<li>万物(一切)皆数据, 函数也是数据</li>
<li>程序中所有操作的目标: 数据<ul>
<li>算术运算</li>
<li>逻辑运算</li>
<li>赋值</li>
<li>调用函数传参<br>…</li>
</ul>
</li>
</ul>
</li>
<li><p>什么是内存?</p>
<ul>
<li>内存条通电后产生的存储空间(临时的)</li>
<li>产生和死亡:<br>内存条(集成电路板)==&gt;通电==&gt;产生一定容量的存储空间==&gt;存储各种数据==&gt;断电==&gt;内存全部消失</li>
<li>内存的空间是临时的, 而硬盘的空间是持久的</li>
<li>一块内存包含2个数据<ul>
<li>内部存储的数据(一般数据/地址数据)</li>
<li>内存地址值数据</li>
</ul>
</li>
<li>内存分类<ul>
<li>栈: 全局变量, 局部变量 (空间较小)</li>
<li>堆: 对象 (空间较大)</li>
</ul>
</li>
</ul>
</li>
<li><p>什么是变量?</p>
<ul>
<li>值可以变化的量, 由变量名与变量值组成</li>
<li>一个变量对应一块小内存, 变量名用来查找到内存,<br>变量值就是内存中保存的内容</li>
</ul>
</li>
<li><p>内存,数据, 变量三者之间的关系</p>
<ul>
<li>内存是一个容器, 用来存储程序运行需要操作的数据</li>
<li>变量是内存的标识, 我们通过变量找到对应的内存,<br>进而操作(读/写)内存中的数据</li>
</ul>
</li>
</ol>
<ul>
<li><strong>相关问题</strong></li>
</ul>
<ol>
<li><p>var a = xxx, a内存中到底保存的是什么?</p>
<ul>
<li>xxx是一个基本数据，保存的就是数据</li>
<li>xxx是一个对象，保存的是对象的地址值</li>
<li>xxx是一个变量，保存的内存内容可能是地址值，也可能是数据值</li>
</ul>
</li>
<li><p>关于引用变量赋值问题</p>
<ul>
<li>2个引用变量指向同一个对象, 通过一个引用变量修改对象内部数据,<br>另一个引用变量看到的是修改之后的数据</li>
<li>2个引用变量指向同一个对象,让一个引用变量指向另一个对象,<br>另一个引用变量还是指向前面的对象</li>
</ul>
</li>
<li><p>在js调用函数时传递变量参数时, 是值传递还是引用传递?</p>
<ul>
<li>只有值传递, 没有引用传递, 传递的都是变量的值,<br>只是这个值可能是基本数据, 也可能是地址(引用)数据</li>
<li>如果后一种看成是引用传递, 那就值传递和引用传递都可以有</li>
</ul>
</li>
<li><p>JS引擎如何管理内存?</p>
<ol>
<li><p>内存生命周期</p>
<ol>
<li>分配小内存空间，得到他的使用权</li>
<li>存储数据。进行反复操作</li>
<li>不需要时将其释放/归还</li>
</ol>
</li>
<li><p>释放内存</p>
<ul>
<li>为执行函数分配的栈空间内存: 函数执行完自动释放</li>
<li>存储对象的堆空间内存: 当内存没有引用指向时,<br>对象成为垃圾对象, 垃圾回收器后面就会回收释放此内存</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="对象的理解和使用"><a href="#对象的理解和使用" class="headerlink" title="对象的理解和使用"></a>对象的理解和使用</h2><ol>
<li><p>什么是对象?</p>
<ul>
<li>代表现实中的某个事物, 是该事物在编程中的抽象</li>
<li>多个数据的集合体(封装体)</li>
<li>用于保存多个数据的容器</li>
</ul>
</li>
<li><p>为什么要用对象?</p>
<ul>
<li>便于对多个数据进行统一管理</li>
</ul>
</li>
<li><p>对象的组成</p>
<ul>
<li>属性<ul>
<li>代表现实事物的状态数据</li>
<li>由属性名和属性值组成</li>
<li>属性名都是字符串类型, 属性值是任意类型</li>
</ul>
</li>
<li>方法<ul>
<li>代表现实事物的行为数据</li>
<li>是特别的属性==&gt;属性值是函数</li>
</ul>
</li>
</ul>
</li>
<li><p>如何访问对象内部数据?</p>
<ul>
<li>.属性名: 编码简单, 但有时不能用</li>
<li>[‘属性名’]: 编码麻烦, 但通用</li>
</ul>
</li>
</ol>
<ul>
<li><strong>相关问题</strong></li>
</ul>
<ol>
<li>什么时候必须使用[‘属性名’]的方式?<ul>
<li>属性名不是合法的标识名</li>
<li>属性名不确定</li>
</ul>
</li>
</ol>
<h2 id="函数的理解和使用"><a href="#函数的理解和使用" class="headerlink" title="函数的理解和使用"></a>函数的理解和使用</h2><ul>
<li><p>什么是函数?</p>
<ul>
<li>用来实现特定功能的, n条语句的封装体</li>
<li>只有函数类型的数据是可以执行的, 其它的都不可以</li>
</ul>
</li>
<li><p>为什么要用函数?</p>
<ul>
<li>提高复用性</li>
<li>便于阅读交流</li>
</ul>
</li>
<li><p>函数也是对象</p>
<ul>
<li>instanceof Object===true</li>
<li>函数有属性: prototype</li>
<li>函数有方法: call()/apply()</li>
<li>可以添加新的属性/方法</li>
</ul>
</li>
<li><p>函数的3种不同角色</p>
<ul>
<li>一般函数 : 直接调用</li>
<li>构造函数 : 通过new调用</li>
<li>对象 : 通过.调用内部的属性/方法</li>
</ul>
</li>
<li><p>匿名函数自调用:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function(w, obj)&#123;</span><br><span class="line">&#x2F;&#x2F;实现代码</span><br><span class="line">&#125;)(window, obj)</span><br></pre></td></tr></table></figure>

<ul>
<li>专业术语为: IIFE (Immediately Invoked Function Expression)<br>立即调用函数表达式</li>
<li>作用<ul>
<li>隐藏内部实现</li>
<li>不污染外部命名空间</li>
<li>用它来编写js模块</li>
</ul>
</li>
</ul>
</li>
<li><p>回调函数的理解</p>
<ul>
<li>什么函数才是回调函数?<ul>
<li>你定义的</li>
<li>你没有调用</li>
<li>但它最终执行了(在一定条件下或某个时刻)</li>
</ul>
</li>
<li>常用的回调函数<ul>
<li>dom事件回调函数</li>
<li>定时器回调函数</li>
<li>ajax请求回调函数</li>
<li>生命周期回调函数</li>
</ul>
</li>
</ul>
</li>
<li><p>函数中的this</p>
<ul>
<li>显式指定谁:obj.xxx()</li>
<li>通过call/apply指定谁调用: xxx.call(obj)</li>
<li>不指定谁调用: xxx(): window</li>
<li>回调函数: 看背后是通过谁来调用的: window/其它</li>
</ul>
</li>
</ul>
<h1 id="函数高级"><a href="#函数高级" class="headerlink" title="函数高级"></a>函数高级</h1><h2 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h2><blockquote>
<ol>
<li><p>函数的prototype属性</p>
<ul>
<li>每个函数都有一个prototype属性,<br>它默认指向一个Object空对象(即称为: 原型对象)</li>
<li>原型对象中有一个属性constructor, 它指向函数对象</li>
</ul>
</li>
<li><p>给原型对象添加属性(一般都是方法)</p>
<ul>
<li>作用: 函数的所有实例对象自动拥有原型中的属性(方法)</li>
</ul>
</li>
</ol>
</blockquote>
<ul>
<li><p>所有函数都有一个特别的属性:</p>
<ul>
<li><code>prototype</code> : 显式原型属性</li>
</ul>
</li>
<li><p>所有实例对象都有一个特别的属性:</p>
<ul>
<li><code>__proto__</code> : 隐式原型属性</li>
</ul>
</li>
<li><p>显式原型与隐式原型的关系</p>
<ul>
<li>函数的prototype: 定义函数时被自动赋值, 值默认为{},<br>即用为原型对象</li>
<li>实例对象的<strong>proto</strong>: 在创建实例对象时被自动添加,<br>并赋值为构造函数的prototype值</li>
<li>原型对象即为当前实例对象的父对象</li>
<li>例子:<br><img src="/2020/07/08/JS%E9%AB%98%E7%BA%A7/%E6%98%BE%E5%BC%8F%E5%8E%9F%E5%9E%8B%E4%B8%8E%E9%9A%90%E5%BC%8F%E5%8E%9F%E5%9E%8B.png" alt></li>
</ul>
</li>
<li><p>原型链</p>
<ul>
<li>访问一个对象的属性时，<ul>
<li>先在自身属性中查找，找到返回</li>
<li>如果没有, 再沿着<strong>proto</strong>这条链向上查找, 找到返回</li>
<li>如果最终没找到,<br>返回undefined(下图中函数列表的尽头<strong>proto</strong>=null就表示没找到返回undefined)</li>
</ul>
</li>
<li>别名: 隐式原型链</li>
<li>作用: 查找对象的属性(方法)</li>
<li>所有的实例对象都有<strong>proto</strong>属性, 它指向的就是原型对象</li>
<li>这样通过<strong>proto</strong>属性就形成了一个链的结构—-&gt;原型链</li>
<li>当查找对象内部的属性/方法时, js引擎自动沿着这个原型链查找</li>
<li><strong>当给对象属性赋值时不会使用原型链, 而只是在当前对象中进行操作</strong></li>
<li>函数的prototype属性指向实例的<strong>proto</strong>属性</li>
<li>所有的函数都是 Function的实例(包括Function)<br><img src="/2020/07/08/JS%E9%AB%98%E7%BA%A7/%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%88%86%E6%9E%90.png" alt></li>
</ul>
</li>
<li><p>instanceof是如何判断的?</p>
<ul>
<li>表达式: A instanceof B</li>
<li>如果B函数的显式原型对象在A对象的原型链上, 返回true,<br>否则返回false</li>
</ul>
</li>
<li><p>测试题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    原型测试题：</span><br><span class="line">&lt;script&gt;</span><br><span class="line">&#x2F;*</span><br><span class="line">测试题1</span><br><span class="line">*&#x2F;</span><br><span class="line">var A &#x3D; function() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">A.prototype.n &#x3D; 1</span><br><span class="line"></span><br><span class="line">var b &#x3D; new A()</span><br><span class="line"></span><br><span class="line">A.prototype &#x3D; &#123;</span><br><span class="line">    n: 2,</span><br><span class="line">    m: 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var c &#x3D; new A()</span><br><span class="line">console.log(b.n, b.m, c.n, c.m)</span><br><span class="line">&#x2F;&#x2F;1 undefined 2 3 </span><br><span class="line">&#x2F;*</span><br><span class="line">测试题2</span><br><span class="line">*&#x2F;</span><br><span class="line">var F &#x3D; function()&#123;&#125;;</span><br><span class="line">Object.prototype.a &#x3D; function()&#123;</span><br><span class="line">    console.log(&#39;a()&#39;)</span><br><span class="line">&#125;;</span><br><span class="line">Function.prototype.b &#x3D; function()&#123;</span><br><span class="line">    console.log(&#39;b()&#39;)</span><br><span class="line">&#125;;</span><br><span class="line">var f &#x3D; new F();</span><br><span class="line">f.a()</span><br><span class="line">f.b()</span><br><span class="line">F.a()</span><br><span class="line">F.b()</span><br><span class="line">&#x2F;&#x2F;a() </span><br><span class="line">&#x2F;&#x2F; f.b is not a function</span><br><span class="line">&#x2F;&#x2F;a()</span><br><span class="line">&#x2F;&#x2F;b()</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/08/JS%E9%AB%98%E7%BA%A7/%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt></p>
</li>
</ul>
<h2 id="执行上下文与执行上下文栈"><a href="#执行上下文与执行上下文栈" class="headerlink" title="执行上下文与执行上下文栈"></a>执行上下文与执行上下文栈</h2><ul>
<li>变量提升与函数提升<ul>
<li>变量提升: 在变量定义语句之前,<br>就可以访问到这个变量(undefined)，只是还没有赋值</li>
<li>函数提升: 在函数定义语句之前, 就可执行该函数</li>
<li>先有变量提升, 再有函数提升</li>
</ul>
</li>
</ul>
<ol>
<li>执行上下文</li>
</ol>
<ul>
<li>代码分类(位置)<ul>
<li>全局代码</li>
<li>函数代码</li>
</ul>
</li>
<li>全局执行上下文<ul>
<li>在执行全局代码前将window确定为全局执行上下文</li>
<li>对全局数据进行预处理<ul>
<li>var定义的全局变量==&gt;undefined, 添加为window的属性</li>
<li>function声明的全局函数==&gt;赋值(fun), 添加为window的方法</li>
<li>this==&gt;赋值(window)</li>
</ul>
</li>
<li>开始执行全局代码</li>
</ul>
</li>
<li>函数执行上下文<ul>
<li>在调用函数, 准备执行函数体之前, 创建对应的函数执行上下文对象</li>
<li>对局部数据进行预处理<ul>
<li>形参变量==&gt;赋值(实参)==&gt;添加为执行上下文的属性</li>
<li>arguments==&gt;赋值(实参列表), 添加为执行上下文的属性</li>
<li>var定义的局部变量==&gt;undefined, 添加为执行上下文的属性</li>
<li>function声明的函数 ==&gt;赋值(fun), 添加为执行上下文的方法</li>
<li>this==&gt;赋值(调用函数的对象)</li>
</ul>
</li>
<li>开始执行函数体代码</li>
</ul>
</li>
</ul>
<ol start="2">
<li>执行上下文栈</li>
</ol>
<ul>
<li><p>在全局代码执行前, JS引擎就会创建一个栈来存储管理所有的执行上下文对象</p>
</li>
<li><p>在全局执行上下文(window)确定后, 将其添加到栈中(压栈)</p>
</li>
<li><p>在函数执行上下文创建后, 将其添加到栈中(压栈)</p>
</li>
<li><p>在当前函数执行完后,将栈顶的对象移除(出栈)</p>
</li>
<li><p>当所有的代码执行完后, 栈中只剩下window</p>
</li>
<li><p>例子：<br><img src="/2020/07/08/JS%E9%AB%98%E7%BA%A7/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88.png" alt></p>
</li>
<li><p>测试题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">执行上下文栈测试题：</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">console.log(&#39;global begin: &#39;+ i)</span><br><span class="line">var i &#x3D; 1</span><br><span class="line">foo(1);</span><br><span class="line">function foo(i) &#123;</span><br><span class="line">    if (i &#x3D;&#x3D; 4) &#123;</span><br><span class="line">    return;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&#39;foo() begin:&#39; + i);</span><br><span class="line">    foo(i + 1);&#x2F;&#x2F;递归调用：在函数内部调用自己，一般会设置条件来终止函数</span><br><span class="line">    console.log(&#39;foo() end:&#39; + i);</span><br><span class="line">&#125;</span><br><span class="line">console.log(&#39;global end: &#39; + i)</span><br><span class="line">&#x2F;&#x2F; global begin: undefined</span><br><span class="line">&#x2F;&#x2F; foo() begin:1 由于递归输出1.2.3</span><br><span class="line">&#x2F;&#x2F; foo() begin:2</span><br><span class="line">&#x2F;&#x2F; foo() begin:3</span><br><span class="line">&#x2F;&#x2F; foo() end:3   因为foo begin执行完后要将栈顶的对象移除出栈</span><br><span class="line">&#x2F;&#x2F; foo() end:2</span><br><span class="line">&#x2F;&#x2F; foo() end:1</span><br><span class="line">&#x2F;&#x2F; global end: 1</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">&#x2F;*</span><br><span class="line">测试题1: 先预处理变量, 后预处理函数</span><br><span class="line">*&#x2F;</span><br><span class="line">function a() &#123;&#125;</span><br><span class="line">var a;</span><br><span class="line">console.log(typeof a)&#x2F;&#x2F;function</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">测试题2: 变量预处理, in操作符</span><br><span class="line">*&#x2F;</span><br><span class="line">if (!(b in window)) &#123;</span><br><span class="line">    var b &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line">console.log(b)&#x2F;&#x2F;undefined</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">测试题3: 预处理, 顺序执行</span><br><span class="line">*&#x2F;</span><br><span class="line">var c &#x3D; 1&#x2F;&#x2F;var c;</span><br><span class="line">function c(c) &#123;</span><br><span class="line">    console.log(c)</span><br><span class="line">    var c &#x3D; 3</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;c&#x3D;1</span><br><span class="line">c(2)&#x2F;&#x2F;报错 会把c识别成变量而不是函数</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="作用域与作用域链"><a href="#作用域与作用域链" class="headerlink" title="作用域与作用域链"></a>作用域与作用域链</h2><ul>
<li><p>理解:</p>
<ul>
<li>作用域: 一块代码区域, 在编码时就确定了, 不会再变化</li>
<li>作用域链:<ul>
<li>多个上下级关系的作用域形成的链,<br>它的方向是从下向上的(从内到外)</li>
<li>查找变量时就是沿着作用域链来查找的</li>
</ul>
</li>
</ul>
</li>
<li><p>分类:</p>
<ul>
<li>全局</li>
<li>函数</li>
<li>js没有块作用域(在ES6之前)</li>
</ul>
</li>
<li><p>作用</p>
<ul>
<li>作用域: 隔离变量, 可以在不同作用域定义同名的变量不冲突</li>
<li>作用域链: 查找变量</li>
</ul>
</li>
<li><p>区别作用域与执行上下文</p>
<ol>
<li><p>区别1</p>
<ul>
<li>全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了，而不是在函数调用时</li>
<li>全局执行上下文环境是在全局作用域确定之后,<br>js代码马上执行之前创建</li>
<li>函数执行上下文环境是在调用函数时, 函数体代码执行之前创建</li>
</ul>
</li>
<li><p>区别2</p>
<ul>
<li>作用域是静态的, 只要函数定义好了就一直存在, 且不会再变化</li>
<li>上下文环境是动态的, 调用函数时创建,<br>函数调用结束时上下文环境就会被释放</li>
</ul>
</li>
<li><p>联系</p>
<ul>
<li>上下文环境(对象)是从属于所在的作用域</li>
<li>全局上下文环境==&gt;全局作用域</li>
<li>函数上下文环境==&gt;对应的函数使用域</li>
</ul>
</li>
</ol>
</li>
<li><p>测试题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">&#x2F;*</span><br><span class="line">问题: 结果输出多少?</span><br><span class="line">*&#x2F;</span><br><span class="line">var x &#x3D; 10;</span><br><span class="line">function fn() &#123;</span><br><span class="line">    console.log(x);</span><br><span class="line">&#125;</span><br><span class="line">function show(f) &#123;</span><br><span class="line">    var x &#x3D; 20;</span><br><span class="line">    f();</span><br><span class="line">&#125;</span><br><span class="line">show(fn);</span><br><span class="line">&#x2F;&#x2F;10</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">&#x2F;*</span><br><span class="line">说说它们的输出情况</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">var fn &#x3D; function () &#123;</span><br><span class="line">    console.log(fn)</span><br><span class="line">&#125;</span><br><span class="line">fn()&#x2F;&#x2F;函数作用域找不到，去外部作用域能找到fn</span><br><span class="line">&#x2F;&#x2F;ƒ () &#123;</span><br><span class="line">&#x2F;&#x2F;  console.log(fn)</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">    fn2: function () &#123;</span><br><span class="line">    console.log(fn2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.fn2()&#x2F;&#x2F;函数作用域找不到，全局作用域也找不到（只有obj，没有fn2）；修改为this.fn2或obj.fn2为正确</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ul>
<li><p>理解</p>
<ul>
<li>当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时,<br>就产生了闭包</li>
<li>通过chrome工具得知: 闭包本质是内部函数中的一个对象,<br>这个对象中包含引用的变量属性</li>
<li>闭包的数量取决于调用外部函数的次数，只有调用外部函数的时候才会创建内部函数对象</li>
</ul>
</li>
<li><p>作用</p>
<ol>
<li>使用函数内部的变量在函数执行完后,<br>仍然存活在内存中(延长了局部变量的生命周期)</li>
<li>让函数外部可以操作(读写)到函数内部的数据(变量/函数)</li>
</ol>
</li>
<li><p>生命周期</p>
<ol>
<li>产生: 在嵌套内部函数定义执行完时就产生了(不是在调用)</li>
<li>死亡: 在嵌套的内部函数成为垃圾对象时<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">function fun1() &#123;</span><br><span class="line">    &#x2F;&#x2F;此处闭包已经产生(函数提升，内部函数对象已经创建了)</span><br><span class="line">    var a &#x3D; 3;</span><br><span class="line">    function fun2() &#123;</span><br><span class="line">    a++;</span><br><span class="line">    console.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">    return fun2;</span><br><span class="line">&#125;</span><br><span class="line">var f &#x3D; fun1();</span><br><span class="line">f();</span><br><span class="line">f();</span><br><span class="line">f &#x3D; null &#x2F;&#x2F;此时闭包对象死亡</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>应用</p>
</li>
</ul>
<ol>
<li>定义JS模块<ul>
<li>具有特定功能的js文件</li>
<li>将所有的数据和功能都封装在一个函数内部(私有的)</li>
<li>只向外暴露一个包含n个方法的对象或函数</li>
<li>模块的使用者, 只需要通过模块暴露的对象调用方法来实现对应的功能</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;Module.js</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;自定义模块1</span><br><span class="line">function coolModule() &#123;</span><br><span class="line">  &#x2F;&#x2F;私有的数据</span><br><span class="line">  var msg &#x3D; &#39;atguigu&#39;</span><br><span class="line">  var names &#x3D; [&#39;I&#39;, &#39;Love&#39;, &#39;you&#39;]</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;私有的操作数据的函数</span><br><span class="line">  function doSomething() &#123;</span><br><span class="line">    console.log(msg.toUpperCase())</span><br><span class="line">  &#125;</span><br><span class="line">  function doOtherthing() &#123;</span><br><span class="line">    console.log(names.join(&#39; &#39;))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;向外暴露包含多个方法的对象，也可以用return(还需在调用时创建对象)</span><br><span class="line">  window.module &#123;</span><br><span class="line">    doSomething: doSomething,</span><br><span class="line">    doOtherthing: doOtherthing</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;调用闭包</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;Module.js&quot;&gt;&lt;&#x2F;script&gt;&#x2F;&#x2F;引入</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">  module.doSomething()</span><br><span class="line">  module.doOtherthing()</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>缺点及解决方案</li>
</ul>
<ol>
<li><p>缺点</p>
<ul>
<li>函数执行完后, 函数内的局部变量没有释放, 占用内存时间会变长</li>
<li>容易造成内存泄露</li>
</ul>
</li>
<li><p>解决</p>
<ul>
<li>能不用闭包就不用</li>
<li>及时释放: f = null; //让内部函数对象成为垃圾对象</li>
</ul>
</li>
</ol>
<h2 id="内存溢出与内存泄露"><a href="#内存溢出与内存泄露" class="headerlink" title="内存溢出与内存泄露"></a>内存溢出与内存泄露</h2><ol>
<li><p>内存溢出</p>
<ul>
<li>一种程序运行出现的错误</li>
<li>当程序运行需要的内存超过了剩余的内存时, 就出抛出内存溢出的错误</li>
</ul>
</li>
<li><p>内存泄露</p>
<ul>
<li>占用的内存没有及时释放</li>
<li>内存泄露积累多了就容易导致内存溢出</li>
<li>常见的内存泄露:<ul>
<li>意外的全局变量</li>
<li>没有及时清理的计时器或回调函数</li>
<li>闭包</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="面向对象高级"><a href="#面向对象高级" class="headerlink" title="面向对象高级"></a>面向对象高级</h1><h2 id="对象的创建模式"><a href="#对象的创建模式" class="headerlink" title="对象的创建模式"></a>对象的创建模式</h2><ul>
<li><p>Object构造函数模式</p>
<ul>
<li>套路: 先创建空Object对象, 再动态添加属性/方法</li>
<li>适用场景: 起始时不确定对象内部数据</li>
<li>问题: 语句太多<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; &#123;&#125;;</span><br><span class="line">obj.name &#x3D; &#39;Tom&#39;</span><br><span class="line">obj.setName &#x3D; function(name)&#123;this.name&#x3D;name&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>对象字面量模式</p>
<ul>
<li>套路: 使用{}创建对象, 同时指定属性/方法</li>
<li>适用场景: 起始时对象内部数据是确定的</li>
<li>问题: 如果创建多个对象, 有重复代码<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">name : &#39;Tom&#39;,</span><br><span class="line">setName : function(name)&#123;this.name &#x3D; name&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>工厂模式</p>
<ul>
<li>套路: 通过工厂函数动态创建对象并返回</li>
<li>适用场景: 需要创建多个对象</li>
<li>问题: 对象没有一个具体的类型, 都是Object类型<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">         &#x2F;&#x2F; 工厂函数: 返回一个需要的数据的函数</span><br><span class="line">    function createPerson(name, age) &#123;</span><br><span class="line">        var p &#x3D; &#123;</span><br><span class="line">        name: name,</span><br><span class="line">        age: age,</span><br><span class="line">        setName: function (name) &#123;</span><br><span class="line">            this.name &#x3D; name</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return p</span><br><span class="line">    &#125;</span><br><span class="line">    var p1&#x3D;createPerson(name, age);</span><br><span class="line">    &#96;&#96;&#96;  </span><br><span class="line">* 构造函数模式</span><br><span class="line">    * 套路: 自定义构造函数, 通过new创建对象</span><br><span class="line">    * 适用场景: 需要创建多个类型确定的对象</span><br><span class="line">    * 问题: 每个对象都有相同的数据, 浪费内存</span><br></pre></td></tr></table></figure>
function Person(name, age) {<br>this.name = name;<br>this.age = age;<br>this.setName = function(name){this.name=name;};<br>}<br>new Person(‘tom’, 12);<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-   构造函数+原型的组合模式</span><br><span class="line"></span><br><span class="line">    -   套路: 自定义构造函数, 属性在函数中初始化, 方法添加到原型上</span><br><span class="line">    -   适用场景: 需要创建多个类型确定的对象</span><br></pre></td></tr></table></figure>
function Person(name, age) {<br>this.name = name;<br>this.age = age;<br>}<br>Person.prototype.setName = function(name){this.name=name;};<br>new Person(‘tom’, 12);<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 继承模式  </span><br><span class="line"></span><br><span class="line">-   **原型链继承** : 得到方法</span><br><span class="line"></span><br><span class="line">    -   套路</span><br><span class="line">        1.  定义父类型构造函数</span><br><span class="line">        2.  给父类型的原型添加方法</span><br><span class="line">        3.  定义子类型的构造函数</span><br><span class="line">        4.  创建父类型的对象赋值给子类型的原型</span><br><span class="line">        5.  将子类型原型的构造属性设置为子类型</span><br><span class="line">        6.  给子类型原型添加方法</span><br><span class="line">        7.  创建子类型的对象: 可以调用父类型的方法</span><br><span class="line">    -   关键</span><br><span class="line">        1.  子类型的原型为父类型的一个实例对象</span><br></pre></td></tr></table></figure>
function Parent(){}<br>Parent.prototype.test = function(){};<br>function Child(){}<br>Child.prototype = new Parent(); // 子类型的原型指向父类型实例(让子类的原型成为父类的实例对象)<br>Child.prototype.constructor = Child//让子类型的原型的constructor指向子类型<br>var child = new Child(); //有test()<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">        -   例子</span><br><span class="line">                ![](&#x2F;JS高级&#x2F;原型链继承.png)</span><br><span class="line">-   借用构造函数 : 得到属性</span><br><span class="line"></span><br><span class="line">    -   套路:</span><br><span class="line">        1.  定义父类型构造函数</span><br><span class="line">        2.  定义子类型构造函数</span><br><span class="line">        3.  在子类型构造函数中调用父类型构造</span><br><span class="line">    -   关键:</span><br><span class="line">        1.  在子类型构造函数中通用super()调用父类型构造函数</span><br></pre></td></tr></table></figure>
function Parent(xxx){this.xxx = xxx}<br>Parent.prototype.test = function(){};<br>function Child(xxx,yyy){<pre><code>Parent.call(this, xxx);//借用构造函数  this.Parent(xxx)不能这样写，但是意思相同</code></pre>}<br>var child = new Child(‘a’, ‘b’);  //child.xxx为’a’, 但child没有test()<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-   原型链+借用构造函数的组合继承</span><br><span class="line"></span><br><span class="line">    1.  利用原型链实现对父类型对象的方法继承</span><br><span class="line">    2.  利用call()借用父类型构建函数初始化相同属性</span><br></pre></td></tr></table></figure>
function Parent(xxx){this.xxx = xxx}<br>Parent.prototype.test = function(){};<br>function Child(xxx,yyy){<br>Parent.call(this, xxx);//借用构造函数 this.Parent(xxx)<br>}<br>Child.prototype = new Parent(); //得到test()<br>var child = new Child(); //child.xxx为’a’, 也有test()<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-   new一个对象背后做了些什么?</span><br><span class="line"></span><br><span class="line">    -   创建一个空对象</span><br><span class="line">    -   给对象设置**proto**, 值为构造函数对象的prototype属性值</span><br><span class="line">        this.**proto** &#x3D; Fn.prototype</span><br><span class="line">    -   执行构造函数体(给对象添加属性&#x2F;方法)</span><br><span class="line"></span><br><span class="line"># 线程机制与事件机制  </span><br><span class="line"></span><br><span class="line">## 线程与进程  </span><br><span class="line"></span><br><span class="line">-   进程:</span><br><span class="line">    -   程序的一次执行, 它占有一片独有的内存空间</span><br><span class="line">    -   可以通过windows任务管理器查看进程</span><br><span class="line">-   线程:</span><br><span class="line">    -   是进程内的一个独立执行单元</span><br><span class="line">    -   是程序执行的一个完整流程</span><br><span class="line">    -   是CPU的最小的调度单元</span><br><span class="line">-   关系</span><br><span class="line">    -   程序是在某个进程中的某个线程执行的</span><br><span class="line">    -   一个进程中一般至少有一个运行的线程: 主线程</span><br><span class="line">    -   一个进程中也可以同时运行多个线程, 我们会说程序是多线程运行的</span><br><span class="line">    -   一个进程内的数据可以供其中的多个线程直接共享</span><br><span class="line">    -   多个进程之间的数据是不能直接共享的</span><br><span class="line">    -   线程池：保存多个线程对象的容器，实现线程对象的反复利用</span><br><span class="line"></span><br><span class="line">## 浏览器内核模块组成 </span><br><span class="line"></span><br><span class="line">1.  什么是浏览器内核?</span><br><span class="line"></span><br><span class="line">    -   支持浏览器运行的最核心的程序</span><br><span class="line"></span><br><span class="line">2.  不同的浏览器可能不太一样</span><br><span class="line"></span><br><span class="line">    -   Chrome, Safari: webkit</span><br><span class="line">    -   firefox: Gecko</span><br><span class="line">    -   IE: Trident</span><br><span class="line">    -   360,搜狗等国内浏览器: Trident + webkit</span><br><span class="line"></span><br><span class="line">3.  内核由很多模块组成</span><br><span class="line"></span><br><span class="line">    -   主线程</span><br><span class="line">        -   js引擎模块 : 负责js程序的编译与运行</span><br><span class="line">        -   html,css文档解析模块 : 负责页面文本的解析</span><br><span class="line">        -   DOM&#x2F;CSS模块 : 负责dom&#x2F;css在内存中的相关处理</span><br><span class="line">        -   布局和渲染模块 : 负责页面的布局和效果的绘制(内存中的对象)</span><br><span class="line">    -   分线程</span><br><span class="line">        -   定时器模块 : 负责定时器的管理</span><br><span class="line">        -   DOM事件模块 : 负责事件的管理</span><br><span class="line">        -   网络请求模块 : 负责Ajax请求</span><br><span class="line"></span><br><span class="line">## 定时器问题  </span><br><span class="line"></span><br><span class="line">1.  定时器真是定时执行的吗?</span><br><span class="line">    -   定时器并不能保证真正定时执行</span><br><span class="line">    -   一般会延迟一丁点(可以接受), 也有可能延迟很长时间(不能接受)</span><br><span class="line"></span><br><span class="line">2.  定时器回调函数是在分线程执行的吗?</span><br><span class="line">    -   在主线程执行的, js是单线程的</span><br><span class="line"></span><br><span class="line">3.  定时器是如何实现的?</span><br><span class="line">    -   事件循环模型</span><br><span class="line"></span><br><span class="line">## js线程  </span><br><span class="line"></span><br><span class="line">-   js是单线程执行的(回调函数也是在主线程)</span><br><span class="line">-   H5提出了实现多线程的方案: Web Workers</span><br><span class="line">-   只能是主线程更新界面</span><br><span class="line"></span><br><span class="line">1.  如何证明js执行是单线程的?</span><br><span class="line"></span><br><span class="line">    -   setTimeout()的回调函数是在主线程执行的</span><br><span class="line">    -   定时器回调函数只有在运行栈中的代码全部执行完后才有可能执行</span><br><span class="line"></span><br><span class="line">2.  为什么js要用单线程模式, 而不用多线程模式?</span><br><span class="line"></span><br><span class="line">    -   JavaScript的单线程，与它的用途有关。</span><br><span class="line">    -   作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。</span><br><span class="line">    -   这决定了它只能是单线程，否则会带来很复杂的同步问题</span><br><span class="line"></span><br><span class="line">3.  代码的分类:</span><br><span class="line"></span><br><span class="line">    -   初始化代码</span><br><span class="line">    -   回调代码</span><br><span class="line"></span><br><span class="line">4.  js引擎执行代码的基本流程</span><br><span class="line"></span><br><span class="line">    -   先执行初始化代码: 包含一些特别的代码</span><br><span class="line">        -   设置定时器</span><br><span class="line">        -   绑定监听</span><br><span class="line">        -   发送ajax请求</span><br><span class="line">    -   后面在某个时刻才会执行回调代码</span><br><span class="line"></span><br><span class="line">## 事件循环模型  </span><br><span class="line"></span><br><span class="line">1.  所有代码分类</span><br><span class="line">    -   初始化执行代码(同步代码): 包含绑定dom事件监听, 设置定时器,</span><br><span class="line">        发送ajax请求的代码</span><br><span class="line">    -   回调执行代码(异步代码): 处理回调逻辑</span><br><span class="line"></span><br><span class="line">2.  js引擎执行代码的基本流程:</span><br><span class="line">    -   初始化代码&#x3D;&#x3D;&#x3D;\&gt;回调代码</span><br><span class="line"></span><br><span class="line">3.  模型的2个重要组成部分:</span><br><span class="line">    -   事件管理模块</span><br><span class="line">    -   回调队列</span><br><span class="line"></span><br><span class="line">4.  模型的运转流程</span><br><span class="line">    -   执行初始化代码, 将事件回调函数交给对应模块管理</span><br><span class="line">    -   当事件发生时, 管理模块会将回调函数及其数据添加到回调列队中</span><br><span class="line">    -   只有当初始化代码执行完后(可能要一定时间),</span><br><span class="line">        才会遍历读取回调队列中的回调函数执行\</span><br><span class="line">        ![](&#x2F;JS高级&#x2F;事件循环模型.png)</span><br><span class="line"></span><br><span class="line">## H5-Web-Workers-多线程  </span><br><span class="line"></span><br><span class="line">1.  H5规范提供了js分线程的实现, 取名为: Web Workers</span><br><span class="line"></span><br><span class="line">-   Worker</span><br></pre></td></tr></table></figure>
var worker = new Worker(‘worker.js’);<br>worker.onMessage = function(event){event.data} : 用来接收另一个线程发送过来的数据的回调//用来绑定消息监听（主线程接收分线程返回的数据）<br>worker.postMessage(data1) : 主线程向分线程发送数据<pre><code></code></pre></li>
</ul>
</li>
</ul>
<ol start="2">
<li><p>相关API</p>
<ul>
<li>Worker: 构造函数, 加载分线程执行的js文件</li>
<li>Worker.prototype.onmessage: 用于接收另一个线程的回调函数</li>
<li>Worker.prototype.postMessage: 向另一个线程发送消息</li>
</ul>
</li>
<li><p>不足</p>
<ul>
<li>worker内代码不能操作DOM(更新UI)</li>
<li>不能跨域加载JS</li>
<li>不是每个浏览器都支持这个新特性<br><img src="/2020/07/08/JS%E9%AB%98%E7%BA%A7/H5WebWorkers.png" alt></li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>前端三大块</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/07/02/hello%20world/</url>
    <content><![CDATA[<blockquote>
<p>序<br><br>偶尔有天在B站上刷到一段视频，内容是up主用hexo快速的搭建个人博客，虽然说作为软件专业的学生用这种快速的网站生成器实属有点说不过去，但是俗话说得好：强撸灰飞湮灭，要是真的手撸出来个人网站，一来按我这个渣渣水平都到猴年马月去了，二来就是想在学习的过程中记录下来一些东西来复习，所以出此下策才有了这个网站。</p>
</blockquote>
<a id="more"></a>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul>
<li>Git</li>
<li>Nginx</li>
<li>Nodejs</li>
<li>搭载环境<ol>
<li>阿里云服务器(学生白嫖服务器，不用白不用，地址：<a href="https://developer.aliyun.com/adc/student/" target="_blank" rel="noopener">https://developer.aliyun.com/adc/student/</a>)</li>
<li>域名（在万网根据个人喜欢挑选一个心仪的）</li>
<li>还可以用Github来部署（不需要域名和服务器且免费，不要问我为什么不用，问就是我傲娇，嫌用github后缀名太吃藕）</li>
</ol>
</li>
</ul>
<ul>
<li>hexo<ol>
<li>主角来了，hexo是基于node.js的一款轻量级的博客制作工具。它可以将我们在本地编写的markdown文档转化成html页面，然后我们将html页面上传到服务器上。</li>
<li>hexo还支持切换主题的功能，在本地下载主题文件，可以通过修改theme配置文件和hexo的配置文件实现网页的个性化。</li>
</ol>
</li>
</ul>
<p><strong><em>域名和服务器大概是在5月20号左右买的，买完以后就迎来了很多大大小小的考试，到最近一段时间才想起来还有这么茬事，就索性把这件事落实下来，整个过程还算顺利，已经有了大致的雏形，不过还有些小功能有待发掘，日后再一一填补上来。</em></strong></p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5 CSS3</title>
    <url>/2020/07/04/htmlcss/</url>
    <content><![CDATA[<blockquote>
<p>序<br><br>最近时间空闲比较多，想起来还没有系统的学习过html,css和js，刚好趁着最近复习巩固一下这块的知识，把自己学习的东西记录下来。let’s<br>do it!</p>
</blockquote>
<a id="more"></a>
<h1 id="html"><a href="#html" class="headerlink" title="html"></a>html</h1><blockquote>
<p>div是块元素，他会独占一整行，无论他的内容有多少，主要用来页面布局。而像span,a,img,iframe这种的内联元素（行内元素）只占自身大小，不会占用一整行。<strong>块元素主要用来做页面的布局，内联元素用来选中文本设置样式</strong></p>
</blockquote>
<h2 id="meta"><a href="#meta" class="headerlink" title="meta"></a>meta</h2><ul>
<li>主要用于设置网页中的一些元数据，元数据不是给用户看</li>
<li>charset 指定网页的字符集</li>
<li>name 指定的数据的名称</li>
<li>content 指定的数据的内容</li>
<li>keywords 表示网站的关键字，可以同时指定多个关键字，关键字间使用,隔开</li>
<li>description 用于指定网站的描述，网站的描述会显示在搜索引擎的搜索的结果中</li>
<li>title标签的内容会作为搜索结果的超链接上的文字显示    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta http-equiv&#x3D;&quot;refresh&quot; content&#x3D;&quot;3;url&#x3D;https:&#x2F;&#x2F;www.xxx.com&quot;&gt; </span><br><span class="line">       几秒后将页面重定向到另一个网站</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><ul>
<li>超链接可以让我们从一个页面跳转到其他页面，或者是当前页面的其他的位置</li>
<li>使用 a 标签来定义超链接<ul>
<li>属性：<ul>
<li>href 指定跳转的目标路径<ul>
<li>值可以是一个外部网站的地址</li>
<li>也可以写一个内部页面的地址</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>超链接是也是一个行内元素，在a标签中可以嵌套除它自身外的任何元素</li>
<li>target属性，用来指定超链接打开的位置<ul>
<li>可选值：<ul>
<li>_self 默认值 在当前页面中打开超链接</li>
<li>_blank 在一个新的要么中打开超链接</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="图片标签"><a href="#图片标签" class="headerlink" title="图片标签"></a>图片标签</h2><ul>
<li><p>图片标签用于向当前页面中引入一个外部图片</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;.&#x2F;&quot; alt&#x3D;&quot;&quot;&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>img这种元素属于替换元素（块和行内元素之间，具有两种元素的特点）</p>
</li>
<li><p>属性：</p>
<ul>
<li><p>src 属性指定的是外部图片的路径（路径规则和超链接是一样的）</p>
</li>
<li><p>alt 图片的描述，这个描述默认情况下不会显示，有些浏览器会图片无法加载时显示</p>
<ul>
<li>搜索引擎会根据alt中的内容来识别图片，如果不写alt属性则图片不会被搜索引擎所收录</li>
</ul>
</li>
<li><p>width 图片的宽度 (单位是像素)</p>
</li>
<li><p>height 图片的高度    </p>
<ul>
<li>宽度和高度中如果只修改了一个，则另一个会等比例缩放</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li>一般情况在pc端，不建议修改图片的大小，需要多大的图片就裁多大</li>
<li>但是在移动端，经常需要对图片进行缩放（大图缩小）</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>图片的格式：</p>
<ul>
<li><p>jpeg(jpg)</p>
<ul>
<li>支持的颜色比较丰富，不支持透明效果，不支持动图</li>
<li>一般用来显示照片</li>
</ul>
</li>
<li><p>gif</p>
<ul>
<li>支持的颜色比较少，支持简单透明，支持动图</li>
<li>颜色单一的图片，动图</li>
</ul>
</li>
<li><p>png</p>
<ul>
<li>支持的颜色丰富，支持复杂透明，不支持动图</li>
<li>颜色丰富，复杂透明图片（专为网页而生）</li>
</ul>
</li>
<li><p>webp</p>
<ul>
<li>这种格式是谷歌新推出的专门用来表示网页中的图片的一种格式</li>
<li>它具备其他图片格式的所有优点，而且文件还特别的小</li>
<li>缺点：兼容性不好</li>
</ul>
</li>
<li><p>base64 </p>
<ul>
<li>将图片使用base64编码，这样可以将图片转换为字符，通过字符的形式来引入图片    </li>
<li>一般都是一些需要和网页一起加载的图片才会使用base64</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><ol>
<li><p>无序列表</p>
<ul>
<li>使用ul标签来创建一个无序列表</li>
<li>使用li在ul中创建一个一个的列表项</li>
<li>通过type属性修改列表中的项目符号，也可以在css中用list-style:none来去掉项目符号</li>
</ul>
</li>
<li><p>有序列表</p>
<ul>
<li>有序列表和无序列表相似，只不过他用ol来代替ul</li>
</ul>
</li>
<li><p>定义列表</p>
<ul>
<li>使用dl来创建一个定义列表</li>
<li>dt: 被定义的内容</li>
<li>dd: 对定义内容的表述</li>
</ul>
</li>
</ol>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><ol>
<li><p>html中用table标签来创建单元格</p>
<ul>
<li>table标签中用tr表示行，tr中用td表示列来创建单元格</li>
<li>colspan设置横向合并单元格，rowspan设置纵向合并单元格</li>
<li>table和td边框之间的默认距离可以用border-spacing：0或者是border-collapse：collapse来消除</li>
</ul>
</li>
<li><p>长表格可以将一个表格分成三个部分：</p>
<ul>
<li>头部 thead</li>
<li>主体 tbody</li>
<li>底部 tfoot</li>
<li>th 表示头部的单元格</li>
</ul>
</li>
</ol>
<h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><ul>
<li>form标签中必须指定一个action属性，该属性指向一个服务器地址，当我们提交表单时将会提交到action属性对应的地址，在form中添加不同的表单项</li>
<li>还可以在标签中加：<ul>
<li>autocomplete=”off” 关闭自动补全</li>
<li>readonly 将表单项设置为只读，数据会提交</li>
<li>disabled 将表单项设置为禁用，数据不会提交</li>
<li>autofocus 设置表单项自动获取焦点</li>
</ul>
</li>
</ul>
<h2 id="框架集"><a href="#框架集" class="headerlink" title="框架集"></a>框架集</h2><ul>
<li>使用frameset来创建一个框架集，注意frameset和body不能出现在一个页面中</li>
<li>框架集和内敛框架的作用相似，都是引用外部页面，但是框架集可以同时引用多个，而内联框架只能引入一个</li>
<li>框架集中的框架：rows按行排列/cols按列排列</li>
<li>frameset中可以再嵌套frameset</li>
<li>frameset和iframe一样，他里面的内容都不会被搜索引擎所检索</li>
<li>使用frameset就意味着页面中不能有自己的内容，只能引入其他的页面，而我们所加载的每一个页面浏览器都需要重新发送一次请求，用户体验差</li>
</ul>
<h2 id="hack"><a href="#hack" class="headerlink" title="hack"></a>hack</h2><blockquote>
<p>hack其实时一个特殊的代码，这段代码只有在某些浏览器可以识别，而其他浏览器不能识别，通过这种方式，来为一些浏览器设置特殊代码</p>
</blockquote>
<ul>
<li>条件hack</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--if&lt;keywords&gt;?IE&lt;version&gt;?&gt;</span><br><span class="line">html代码块</span><br><span class="line">&lt;![endif]--&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>属性hack</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">selector&#123;&lt;hack&gt;?property:value&lt;hack&gt;?;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h2><ul>
<li>audio 标签用来向页面中引入一个外部的音频文件的<ul>
<li>音视频文件引入时，默认情况下不允许用户自己控制播放停止</li>
<li>属性：<ul>
<li>controls 是否允许用户控制播放</li>
<li>autoplay 音频文件是否自动播放<ul>
<li>如果设置了autoplay 则音乐在打开页面时会自动播放</li>
<li>但是目前来讲大部分浏览器都不会自动对音乐进行播放 </li>
</ul>
</li>
<li>loop 音乐是否循环播放  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;audio src&#x3D;&quot;.&#x2F;source&#x2F;audio.mp3&quot; controls autoplay loop&gt;&lt;&#x2F;audio&gt;</span><br><span class="line"></span><br><span class="line">兼容性 &#x2F;&#x2F;第一个文件不兼容会切换到第二个文件，以此类推，如果文件全都不兼容就显示文字</span><br><span class="line">&lt;audio controls&gt;</span><br><span class="line">     对不起，您的浏览器不支持播放音频！请升级浏览器！</span><br><span class="line">    &lt;source src&#x3D;&quot;.&#x2F;source&#x2F;audio.mp3&quot;&gt;</span><br><span class="line">    &lt;source src&#x3D;&quot;.&#x2F;source&#x2F;audio.ogg&quot;&gt;</span><br><span class="line">    &lt;embed src&#x3D;&quot;.&#x2F;source&#x2F;audio.mp3&quot; type&#x3D;&quot;audio&#x2F;mp3&quot; width&#x3D;&quot;300&quot; height&#x3D;&quot;100&quot;&gt;</span><br><span class="line">&lt;&#x2F;audio&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><ul>
<li>使用video标签来向网页中引入一个视频<ul>
<li>使用方式和audio基本上是一样的<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;video controls&gt;</span><br><span class="line">    &lt;source src&#x3D;&quot;.&#x2F;source&#x2F;flower.webm&quot;&gt;</span><br><span class="line">    &lt;source src&#x3D;&quot;.&#x2F;source&#x2F;flower.mp4&quot;&gt;</span><br><span class="line">    &lt;embed src&#x3D;&quot;.&#x2F;source&#x2F;flower.mp4&quot; type&#x3D;&quot;video&#x2F;mp4&quot;&gt;</span><br><span class="line">&lt;&#x2F;video&gt;</span><br><span class="line"></span><br><span class="line">还可以用内联框架来显示视频</span><br><span class="line">&lt;iframe frameborder&#x3D;&quot;0&quot; src&#x3D;&quot;&quot; allowFullScreen&#x3D;&quot;true&quot; width&#x3D;&quot;500&quot; height&#x3D;&quot;300&quot;&gt;&lt;&#x2F;iframe&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p><a href="https://www.w3school.com.cn/html/index.asp" target="_blank" rel="noopener">html详细教程</a>\</p>
<h1 id="css"><a href="#css" class="headerlink" title="css"></a>css</h1><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><ol>
<li><p>元素选择器</p>
<ul>
<li>可以直接使用标签名做元素选择器</li>
</ul>
</li>
<li><p>id选择器</p>
<ul>
<li>【id=”p1”】-&gt;【#p1】</li>
</ul>
</li>
<li><p>class选择器</p>
<ul>
<li>【class=”p1”】-&gt;【.p1】</li>
<li><strong>class属性和id属性相似，只不过class属性可以重复拥有相同的class属性值元素，我们称它为一组元素</strong></li>
</ul>
</li>
<li><p>伪类选择器</p>
<blockquote>
<p>伪类专门用来表示元素的一种特殊的状态，当我们需要为处在特殊状态的元素设置样式时，就可以用伪类</p>
</blockquote>
<ul>
<li>a.link 没访问过的链接样式</li>
<li>a.visited 访问过的链接样式</li>
<li>a.hover 鼠标移入的状态</li>
<li>a.active 链接被点击的状态</li>
<li>a.focus 获取焦点的状态</li>
</ul>
</li>
<li><p>属性选择器</p>
<ul>
<li>可以根据元素的属性或属性值来选取制定的元素。</li>
<li><strong>选择器优先级：内联样式&gt;id选择器，class选择器&gt;伪类选择器&gt;元素选择器</strong></li>
</ul>
</li>
</ol>
<h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><ul>
<li><p>在CSS中可以直接使用颜色名来设置各种颜色</p>
<ul>
<li>比如：red、orange、yellow、blue、green … …</li>
<li>但是在css中直接使用颜色名是非常的不方便</li>
</ul>
</li>
<li><p>RGB值：</p>
<ul>
<li>RGB通过三种颜色的不同浓度来调配出不同的颜色</li>
<li>R red，G green ，B blue</li>
<li>每一种颜色的范围在 0 - 255 (0% - 100%) 之间</li>
<li>语法：RGB(红色,绿色,蓝色)</li>
</ul>
</li>
<li><p>RGBA:</p>
<ul>
<li>就是在rgb的基础上增加了一个a表示不透明度</li>
<li>需要四个值，前三个和rgb一样，第四个表示不透明度<ul>
<li>1表示完全不透明   0表示完全透明  .5半透明</li>
</ul>
</li>
</ul>
</li>
<li><p>十六进制的RGB值：</p>
<ul>
<li>语法：#红色绿色蓝色</li>
<li>颜色浓度通过 00-ff</li>
<li>如果颜色两位两位重复可以进行简写  <ul>
<li>#aabbcc –&gt; #abc</li>
</ul>
</li>
</ul>
</li>
<li><p>HSL值 HSLA值</p>
<ul>
<li>H 色相(0 - 360)</li>
<li>S 饱和度，颜色的浓度 0% - 100%</li>
<li>L 亮度，颜色的亮度 0% - 100%</li>
</ul>
</li>
</ul>
<h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><blockquote>
<p>width和height只是设置内容区的大小，而不是盒子的大小<br><br>盒子的大小由内容区，内边距，边框共同决定</p>
</blockquote>
<ol>
<li><p>border边框</p>
<ul>
<li>border-width:边框的宽度</li>
<li>border-color:边框的颜色</li>
<li>边框的宽度和颜色可以设置四个值，分别代表边框上右下左(顺时针)的属性</li>
<li>border-style:边框的样式</li>
<li>简写形式border：颜色 样式 宽度</li>
<li>outline 用来设置元素的轮廓线，用法和border一模一样<ul>
<li>轮廓和边框不同的点，就是轮廓不会影响到可见框的大小</li>
</ul>
</li>
</ul>
</li>
<li><p>padding内边框</p>
<ul>
<li>内边距会影响盒子可见框的大小</li>
<li>padding-top/right/bottom/left</li>
</ul>
</li>
<li><p>margin外边距</p>
<ul>
<li>外边距指的是当前盒子和其他盒子之间的距离</li>
<li>margin-top/right/bottom/left:正负表示相反方向</li>
</ul>
</li>
<li><p>垂直外边距的重叠</p>
<ul>
<li>在网页中垂直方向的相邻外边距会发生外边距的重叠</li>
<li>外边距重叠指兄弟元素之间的相邻外边距会取最大值而不是求和</li>
<li>如果父子元素的垂直外边距相邻了，则子元素的外边距会设置给父元素</li>
<li>解决方法：可以通过在父子元素中间加元素来隔开他们，使他们不在相邻；也可以通过设置父元素的内边距来实现</li>
</ul>
</li>
<li><p>内联元素可以设置内边距和边框，水平方向影响布局，垂直方向不影响布局；还可以设置外边距，水平方向相邻外边距是求和的，但不支持垂直方向的外边距</p>
</li>
<li><p>box-shadow </p>
<ul>
<li>用来设置元素的阴影效果，阴影不会影响页面布局 <ul>
<li>第一个值 水平偏移量 设置阴影的水平位置 正值向右移动 负值向左移动</li>
<li>第二个值 垂直偏移量 设置阴影的水平位置 正值向下移动 负值向上移动</li>
<li>第三个值 阴影的模糊半径</li>
<li>第四个值 阴影的颜色<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">box-shadow: 0px 0px 50px rgba(0, 0, 0, .3) ;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>border-radius:</p>
<ul>
<li>用来设置圆角,圆角设置的圆的半径大小<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">border-top-left-radius</span><br><span class="line">border-top-right-radius</span><br><span class="line">border-bottom-left-radius</span><br><span class="line">border-bottom-right-radius</span><br><span class="line">border-top-left-radius:50px 100px;</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ol>
<p><img src="/2020/07/04/htmlcss/htmlcss.jpg" alt></p>
<h2 id="display"><a href="#display" class="headerlink" title="display"></a>display</h2><blockquote>
<p>display可以将行内元素变成块元素，可以用来改变行内元素的宽高</p>
</blockquote>
<ol>
<li><p>display：inline 可以将一个元素作为内联元素显示</p>
</li>
<li><p>display：block 可以将一个元素设置为块元素</p>
</li>
<li><p>display：inline-block<br>将一个行内元素转换为块元素，可以使一个元素既可以设置宽高，又不会独占一行（既有行内元素的特点又有块元素的特点）</p>
<ul>
<li>如果想要元素消失后位置保留，可以用visibility：hidden</li>
</ul>
</li>
<li><p>display：none 不显示元素，并且元素不会再页面中继续占有位置</p>
</li>
</ol>
<h2 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h2><blockquote>
<p>文档流处在网页的底层，他表示的是一个页面中的位置，我们所创建的元素默认都处在文档流中</p>
</blockquote>
<ol>
<li><p>块元素在文档流中的特点</p>
<ul>
<li>块元素在文档流中会独占一行，快元素会自上向下排列</li>
<li>块元素在文档流中默认宽度是父元素的100%</li>
<li>块元素在文档流中的高度默认被内容撑开</li>
</ul>
</li>
<li><p>内联元素在文档流中的特点</p>
<ul>
<li>如果一行中不足以容纳所有的内联元素，则换到下一行，继续从左向右</li>
</ul>
</li>
<li><p>当元素的宽度的值为auto时，此时会指定内边距不影响可见框的大小，而是会自动修改宽度来适应内边距</p>
</li>
</ol>
<h2 id="float"><a href="#float" class="headerlink" title="float"></a>float</h2><blockquote>
<p>使用float来使元素浮动，从而脱离文档流</p>
</blockquote>
<ol>
<li>none：默认值，元素默认在文档流中排列</li>
<li>left：元素立即脱离文档流，向页面的左侧浮动</li>
<li>right：元素立即脱离文档流，向页面的右侧浮动</li>
</ol>
<ul>
<li><p>元素脱离文档流后，它下面的元素立即向上移动，元素浮动以后，会尽量向页面的左上或者是右上移动，直到遇到父元素的边框或者是其他浮动元素</p>
</li>
<li><p>如果浮动元素的上边是一个没有浮动的块元素，则浮动元素不会超过块元素</p>
</li>
<li><p>浮动元素不会超过他上边的兄弟元素，最多和他上面的兄弟元素并列</p>
</li>
<li><p>浮动元素不会覆盖文字，文字会自动环绕在元素的周围</p>
</li>
<li><p>块元素脱离文档流后，高度和宽度都被内容撑开</p>
</li>
<li><p>内联元素脱离文档流后，就变成了块元素，高度和宽度都被内容撑开</p>
</li>
<li><p><strong>一旦脱离文档流后，内联元素和块元素全都是块元素，不做区分</strong></p>
<blockquote>
<p>clear可以用来清除浮动</p>
</blockquote>
</li>
</ul>
<ol>
<li>none：默认值，不清除浮动</li>
<li>left: 清除左侧浮动元素对当前元素的影响</li>
<li>right：清除右侧浮动元素对当前元素的影响</li>
<li>both：清除两侧浮动元素对当前元素的影响</li>
</ol>
<h2 id="高度塌陷问题"><a href="#高度塌陷问题" class="headerlink" title="高度塌陷问题"></a>高度塌陷问题</h2><blockquote>
<p>在文档流中，父元素的高度默认是被子元素撑开的，也就是子元素多高，父元素就多高，但是当子元素设置浮动以后，子元素脱离文档流，此时将会导致子元素无法撑起父元素的高度，导致父元素的高度塌陷。由于父元素的高度塌陷了，则父元素下的所有元素都会向上移动，导致页面布局混乱。</p>
</blockquote>
<ul>
<li><p>解决方法：</p>
<ol>
<li><p>我们可以将父元素的高度写死，来避免塌陷，但是我们一旦将高度写死，父元素就不能自适应子元素的高度，所以这种方法不推荐</p>
</li>
<li><p>在页面中的元素都有一个隐含的属性叫block formatting<br>contex，简称bfc，该属性可以设置打开或者关闭，默认是关闭的</p>
<ul>
<li><p>开启bfc后，元素具有以下特征：</p>
<ol>
<li>父元素的垂直外边距不会和子元素重叠</li>
<li>开启bfc的元素不会被浮动元素所覆盖</li>
<li>开启bfc的元素可以包括浮动的子元素</li>
</ol>
</li>
<li><p>如何开启元素的bfc</p>
<ol>
<li><p>设置元素浮动</p>
<ul>
<li>使用这种方式开启，虽然可以撑开父元素，但是会导致父元素的宽度丢失，而且使用这种方式也会导致下边的元素上移，不能解决问题，不推荐</li>
</ul>
</li>
<li><p>设置元素绝对定位</p>
<ul>
<li>效果同1，不推荐</li>
</ul>
</li>
<li><p>设置元素为inline-block</p>
<ul>
<li>可以解决问题，但是会导致宽度丢失，不推荐</li>
</ul>
</li>
<li><p>将元素的overflow设置为一个非visible的值</p>
<ul>
<li><strong>推荐方式：将overflow设置为hidden是副作用最小的开启bfc的方式</strong></li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>但是在IE6及以下版本不支持bfc，所以在IE6中我们通过开haslayout来解决问题，开启方式：直接将元素的zoom设置为1</p>
</li>
<li><p>还可以在高度塌陷的父元素的最后，添加一个空白的div，由于这个div没有浮动，所以他是可以撑开父元素的高度的，然后对其进行清除浮动，这样就可以通过空白的div来撑开父元素，基本没有副作用，但是会产生一个多余的div结构，所以我们还可以用div的after伪类在元素的最后添加一个空白的块元素来实现同样的效果</p>
</li>
<li><p>clearfix</p>
<blockquote>
<p>既可以解决高度塌陷,又可以确保父元素和子元素的垂直外边距不会重叠</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.clearfix:before,</span><br><span class="line">.clearfix:after&#123;</span><br><span class="line">content:&quot;&quot;;</span><br><span class="line">display:table;</span><br><span class="line">clear:both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><blockquote>
<p>定位就是将指定的定位摆放到页面的任意位置</p>
</blockquote>
<ol>
<li><p>相对定位(position：relative)</p>
<ul>
<li>当开启了元素的相对定位以后，而不设置偏移量时，元素不会发生变化</li>
<li>当元素开启定位后，可以通过left，right，top，bottom来设置元素相对于其定位位置的偏移量</li>
<li>相对定位是相对于元素在文档流中的位置进行定位</li>
<li>相对定位的元素不会脱离文档流</li>
<li>相对定位会使元素提升一个层级(覆盖低层级元素)</li>
<li>相对定位不会改变元素的性质，块还是块，内联还是内联</li>
</ul>
</li>
<li><p>绝对定位(position：absolute)</p>
<ul>
<li>开启绝对定位后会脱离文档流</li>
<li>开启绝对定位后，如果不设置偏移量，则元素的位置不发生改变</li>
<li>绝对定位是相当于离他最近的开启了定位的祖先元素进行定位的，如果所有的祖先元素都没有开启定位，则会相对于浏览器窗口进行定位</li>
<li>绝对定位也会使元素提升一个层级(覆盖低层级元素)</li>
<li>绝对定位会改变元素的性质，内联元素变成块元素，块的宽高被内容撑开</li>
</ul>
</li>
<li><p>固定定位(position：fixed)</p>
<ul>
<li>固定定位也是一种相对定位，他的绝大多数特点和绝对定位一样</li>
<li>不同的是：固定定位永远都会相对于浏览器窗口进行定位，它永远固定在窗口的某个位置，不会随着滚动条滚动</li>
</ul>
</li>
</ol>
<h2 id="层级"><a href="#层级" class="headerlink" title="层级"></a>层级</h2><blockquote>
<p>如果定位元素的层级是一样的，则下边的元素会盖住上边的，还可以通过z-inline属性来设置元素的层级(父元素的层级再高，也不会盖住子元素)，当然没有开启定位的元素不能使用z-inline</p>
</blockquote>
<h2 id="透明背景"><a href="#透明背景" class="headerlink" title="透明背景"></a>透明背景</h2><ul>
<li>opacity可以用来设置元素背景的透明,范围：0<del>1(完全透明</del>不透明)</li>
</ul>
<h2 id="字体族"><a href="#字体族" class="headerlink" title="字体族"></a>字体族</h2><ol>
<li><p>font-size设置大小</p>
</li>
<li><p>font-style设置斜体</p>
</li>
<li><p>font-weight设置加粗效果</p>
</li>
<li><p>font-variant设置大小写</p>
</li>
<li><p>font-family 字体族（字体的格式）</p>
<ul>
<li>可选值：<ul>
<li>serif  衬线字体</li>
<li>sans-serif 非衬线字体</li>
<li>monospace 等宽字体<ul>
<li>指定字体的类别，浏览器会自动使用该类别下某一种的字体使用</li>
</ul>
</li>
</ul>
</li>
<li>font-family 可以同时指定多个字体，多个字体间使用,隔开<ul>
<li>字体生效时优先使用第一个，第一个无法使用则使用第二个 以此类推</li>
</ul>
</li>
</ul>
</li>
<li><p>iconfont（图标字体）</p>
<ul>
<li>在网页中经常需要使用一些图标，可以通过图片来引入图标<ul>
<li>但是图片大小本身比较大，并且非常的不灵活</li>
</ul>
</li>
<li>所以在使用图标时，我们还可以将图标直接设置为字体，<ul>
<li>然后通过font-face的形式来对字体进行引入</li>
</ul>
</li>
<li>这样我们就可以通过使用字体的形式来使用图标<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">以阿里图标库为例</span><br><span class="line">1. 在官网上下载图标然后用link将iconfont.css引入项目中</span><br><span class="line"></span><br><span class="line">2. 然后用i标签引入，也可以用class引入</span><br><span class="line">&lt;i class&#x3D;&quot;iconfont&quot;&gt;&amp;#xe61c;&lt;&#x2F;i&gt;</span><br><span class="line">&lt;i class&#x3D;&quot;iconfont icon-qitalaji&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line"></span><br><span class="line">3. 可以用css对样式进行设置</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    i.iconfont&#123;</span><br><span class="line">        font-size: 100px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p::before&#123;    &#x2F;&#x2F;p标签前</span><br><span class="line">        content: &#39;\e625&#39;;</span><br><span class="line">        font-family: &#39;iconfont&#39;;</span><br><span class="line">        font-size: 100px;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>line height（行高）</p>
<ul>
<li><p>行高指的是文字占有的实际高度</p>
</li>
<li><p>可以通过line-height来设置行高</p>
<ul>
<li>行高可以直接指定一个大小（px em）</li>
<li>也可以直接为行高设置一个整数 , 如果是一个整数的话，行高将会是字体的指定的倍数</li>
</ul>
</li>
<li><p>行高经常还用来设置文字的行间距</p>
<ul>
<li>行间距 = 行高 - 字体大小</li>
</ul>
</li>
<li><p>字体框</p>
<ul>
<li>字体框就是字体存在的格子，设置font-size实际上就是在设置字体框的高度</li>
</ul>
</li>
<li><p>行高会在字体框的上下平均分配</p>
</li>
<li><p>可以将行高设置为和高度一样的值，使单行文字在一个元素中垂直居中</p>
</li>
</ul>
</li>
</ol>
<h2 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h2><ol>
<li><p>text-align 文本的水平对齐</p>
<ul>
<li>可选值：<ul>
<li>left 左侧对齐</li>
<li>right 右对齐</li>
<li>center 居中对齐</li>
<li>justify 两端对齐</li>
</ul>
</li>
</ul>
</li>
<li><p>vertical-align 设置元素垂直对齐的方式</p>
<ul>
<li>可选值：子元素和父元素<ul>
<li>baseline 默认值 基线对齐</li>
<li>top 顶部对齐</li>
<li>bottom 底部对齐</li>
<li>middle 居中对齐</li>
</ul>
</li>
</ul>
</li>
<li><p>text-decoration 设置文本修饰</p>
<ul>
<li>可选值：<ul>
<li>none 什么都没有</li>
<li>underline 下划线</li>
<li>line-through 删除线</li>
<li>overline 上划线</li>
</ul>
</li>
</ul>
</li>
<li><p>white-space 设置网页如何处理空白</p>
<ul>
<li>可选值：<ul>
<li>normal 正常</li>
<li>nowrap 不换行</li>
<li>pre 保留空白</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ol>
<li><p>background-color 设置背景颜色</p>
</li>
<li><p>background-image 设置背景图片 </p>
<ul>
<li>可以同时设置背景图片和背景颜色，这样背景颜色将会成为图片的背景色</li>
<li>如果背景的图片小于元素，则背景图片会自动在元素中平铺将元素铺满</li>
<li>如果背景的图片大于元素，将会一个部分背景无法完全显示</li>
<li>如果背景图片和元素一样大，则会直接正常显示</li>
</ul>
</li>
<li><p>background-repeat 用来设置背景的重复方式</p>
<ul>
<li>可选值：<ul>
<li>repeat 默认值 ， 背景会沿着x轴 y轴双方向重复</li>
<li>repeat-x 沿着x轴方向重复</li>
<li>repeat-y 沿着y轴方向重复</li>
<li>no-repeat 背景图片不重复</li>
</ul>
</li>
</ul>
</li>
<li><p>background-position 用来设置背景图片的位置</p>
<ul>
<li><p>设置方式：</p>
<ul>
<li><p>通过 top left right bottom center 几个表示方位的词来设置背景图片的位置</p>
</li>
<li><p>使用方位词时必须要同时指定两个值，如果只写一个则第二个默认就是center</p>
</li>
<li><p>通过偏移量来指定背景图片的位置：</p>
<ul>
<li>水平方向的偏移量 垂直方向变量</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>background-clip 设置背景的范围 </p>
<ul>
<li>可选值：<ul>
<li>border-box 默认值，背景会出现在边框的下边</li>
<li>padding-box 背景不会出现在边框，只出现在内容区和内边距</li>
<li>content-box 背景只会出现在内容区</li>
</ul>
</li>
</ul>
</li>
<li><p>background-origin  背景图片的偏移量计算的原点</p>
<ul>
<li>padding-box 默认值，background-position从内边距处开始计算</li>
<li>content-box 背景图片的偏移量从内容区处计算</li>
<li>border-box 背景图片的变量从边框处开始计算</li>
</ul>
</li>
<li><p>background-size 设置背景图片的大小</p>
<ul>
<li><p>第一个值表示宽度 </p>
</li>
<li><p>第二个值表示高度</p>
</li>
<li><p>如果只写一个，则第二个值默认是 auto</p>
</li>
<li><p>cover 图片的比例不变，将元素铺满</p>
</li>
<li><p>contain 图片比例不变，将图片在元素中完整显示</p>
</li>
</ul>
</li>
<li><p>background-attachment</p>
<ul>
<li>背景图片是否跟随元素移动</li>
<li>可选值：<ul>
<li>scroll 默认值 背景图片会跟随元素移动</li>
<li>fixed 背景会固定在页面中，不会随元素移动</li>
</ul>
</li>
</ul>
</li>
<li><p>线性渐变</p>
<ul>
<li><p>通过渐变可以设置一些复杂的背景颜色，可以实现从一个颜色向其他颜色过渡的效果</p>
</li>
<li><p>渐变是图片，需要通过background-image来设置</p>
</li>
<li><p>线性渐变，颜色沿着一条直线发生变化</p>
</li>
<li><p>linear-gradient()</p>
<ul>
<li>linear-gradient(red,yellow) </li>
<li>红色在开头，黄色在结尾，中间是过渡区域</li>
<li>线性渐变的开头，我们可以指定一个渐变的方向<ul>
<li>to left</li>
<li>to right</li>
<li>to bottom</li>
<li>to top</li>
<li>xxx deg表示度数</li>
<li>turn 表示圈</li>
</ul>
</li>
</ul>
</li>
<li><p>渐变可以同时指定多个颜色，多个颜色默认情况下平均分布，<br>  也可以手动指定渐变的分布情况</p>
</li>
<li><p>repeating-linear-gradient() 可以平铺的线性渐变</p>
</li>
</ul>
</li>
<li><p>径向渐变</p>
<ul>
<li><p>radial-gradient() 径向渐变(放射性的效果) </p>
<ul>
<li><p>默认情况下径向渐变的形状根据元素的形状来计算的</p>
</li>
<li><p>正方形 –&gt; 圆形</p>
</li>
<li><p>长方形 –&gt; 椭圆形</p>
</li>
<li><p>我们也可以手动指定径向渐变的大小</p>
<ul>
<li>circle 正圆</li>
<li>ellipse 椭圆</li>
</ul>
</li>
<li><p>也可以指定渐变的位置</p>
</li>
<li><p>语法：</p>
</li>
<li><p>radial-gradient(大小 at 位置, 颜色 位置 ,颜色 位置 ,颜色 位置)</p>
<ul>
<li><p>大小：</p>
<ul>
<li>circle 圆形</li>
<li>ellipse 椭圆</li>
<li>closest-side 近边    </li>
<li>closest-corner 近角</li>
<li>farthest-side 远边</li>
<li>farthest-corner 远角</li>
</ul>
</li>
<li><p>位置：</p>
<ul>
<li>top right left center bottom</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="transition（过渡）"><a href="#transition（过渡）" class="headerlink" title="transition（过渡）"></a>transition（过渡）</h2><ul>
<li>通过过渡可以指定一个属性发生变化时的切换方式</li>
<li>通过过渡可以创建一些非常好的效果，提升用户的体验</li>
</ul>
<ol>
<li><p>transition-property: 指定要执行过渡的属性  </p>
<ul>
<li>多个属性间使用,隔开 </li>
<li>如果所有属性都需要过渡，则使用all关键字</li>
<li>大部分属性都支持过渡效果，注意过渡时必须是从一个有效数值向另外一个有效数值进行过渡</li>
</ul>
</li>
<li><p>transition-duration: 指定过渡效果的持续时间</p>
<ul>
<li>时间单位：s 和 ms  1s = 1000ms</li>
</ul>
</li>
<li><p>transition-timing-function: 过渡的时序函数</p>
<ul>
<li>指定过渡的执行的方式  </li>
<li>可选值：<ul>
<li>ease 默认值，慢速开始，先加速，再减速</li>
<li>linear 匀速运动</li>
<li>ease-in 加速运动</li>
<li>ease-out 减速运动</li>
<li>ease-in-out 先加速 后减速</li>
<li>cubic-bezier() 来指定时序函数<ul>
<li><a href="https://cubic-bezier.com" target="_blank" rel="noopener">https://cubic-bezier.com</a></li>
</ul>
</li>
<li>steps() 分步执行过渡效果<ul>
<li>可以设置一个第二个值：<ul>
<li>start ， 在时间开始时执行</li>
<li>end ， 在指定时间结束后执行过渡(默认值)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>transition-delay: 过渡效果的延迟，等待一段时间后在执行过渡 </p>
</li>
</ol>
<p>5.transition 简写</p>
<ul>
<li>可以同时设置过渡相关的所有属性，只有一个要求，如果要写延迟，则两个时间中第一个是持续时间，第二个是延迟</li>
</ul>
<h2 id="动画-animation"><a href="#动画-animation" class="headerlink" title="动画(animation)"></a>动画(animation)</h2><ul>
<li>动画和过渡类似，都是可以实现一些动态的效果，<ul>
<li>不同的是过渡需要在某个属性发生变化时才会触发</li>
<li>动画可以自动触发动态效果</li>
</ul>
</li>
<li>设置动画效果，必须先要设置一个关键帧，关键帧设置了动画执行每一个步骤</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> @keyframes test &#123;</span><br><span class="line">&#x2F;* from表示动画的开始位置 也可以使用 0% *&#x2F;</span><br><span class="line">from&#123;&#125; </span><br><span class="line"></span><br><span class="line">&#x2F;* to动画的结束位置 也可以使用100%*&#x2F;</span><br><span class="line">to&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>animation-duration: 动画的执行时间 </p>
</li>
<li><p>animation-iteration-count 动画执行的次数 </p>
<ul>
<li>可选值：<ul>
<li>次数</li>
<li>infinite 无限执行</li>
</ul>
</li>
</ul>
</li>
<li><p>animation-direction</p>
<ul>
<li>指定动画运行的方向<ul>
<li>可选值：</li>
<li>normal 默认值  从 from 向 to运行 每次都是这样 </li>
<li>reverse 从 to 向 from 运行 每次都是这样 </li>
<li>alternate 从 from 向 to运行 执行完from-to 执行to-from</li>
<li>alternate-reverse 从 to 向 from运行 重复执行动画时反向执行</li>
</ul>
</li>
</ul>
</li>
<li><p>animation-play-state: 设置动画的执行状态 </p>
<ul>
<li>可选值：<ul>
<li>running 默认值 动画执行</li>
<li>paused 动画暂停</li>
</ul>
</li>
</ul>
</li>
<li><p>animation-fill-mode: 动画的填充模式</p>
<ul>
<li>可选值：<ul>
<li>none 默认值 动画执行完毕元素回到原来位置</li>
<li>forwards 动画执行完毕元素会停止在动画结束的位置</li>
<li>backwards 动画延时等待时，元素就会处于开始位置</li>
<li>both 结合了forwards 和 backwards</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="变形-transform"><a href="#变形-transform" class="headerlink" title="变形(transform)"></a>变形(transform)</h2><ul>
<li>变形就是指通过CSS来改变元素的形状或位置<ul>
<li>变形不会影响到页面的布局</li>
<li>transform 用来设置元素的变形效果</li>
</ul>
</li>
</ul>
<ol>
<li><p>平移：</p>
<ul>
<li>translateX() 沿着x轴方向平移</li>
<li>translateY() 沿着y轴方向平移</li>
<li>translateZ() 沿着z轴方向平移<ul>
<li>如果填百分比是相对于自身计算的</li>
</ul>
</li>
<li>z轴平移，调整元素在z轴的位置，正常情况就是调整元素和人眼之间的距离，距离越大，元素离人越近</li>
<li>z轴平移属于立体效果（近大远小），默认情况下网页是不支持透视，如果需要看见效果必须要设置网页的视距</li>
<li>设置当前网页的视距为800px，人眼距离网页的距离<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">perspective: 800px;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>旋转</p>
<ul>
<li>通过旋转可以使元素沿着x y 或 z旋转指定的角度</li>
<li>rotateX()</li>
<li>rotateY()</li>
<li>rotateZ()</li>
<li>是否显示元素的背面<ul>
<li>backface-visibility: hidden;</li>
</ul>
</li>
</ul>
</li>
<li><p>缩放</p>
<ul>
<li>对元素进行缩放的函数：<ul>
<li>scaleX() 水平方向缩放</li>
<li>scaleY() 垂直方向缩放</li>
<li>scaleZ() 沿着Z轴缩放，一般只有立体的情况下可以看到效果</li>
<li>scale() 双方向的缩放</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="flex-弹性盒、伸缩盒"><a href="#flex-弹性盒、伸缩盒" class="headerlink" title="flex(弹性盒、伸缩盒)"></a>flex(弹性盒、伸缩盒)</h2><ul>
<li>是CSS中的又一种布局手段，它主要用来代替浮动来完成页面的布局</li>
<li>flex可以使元素具有弹性，让元素可以跟随页面的大小的改变而改变</li>
</ul>
<ol>
<li><strong>弹性容器</strong><ul>
<li>要使用弹性盒，必须先将一个元素设置为弹性容器</li>
<li>我们通过 display 来设置弹性容器<br>  display:flex  设置为块级弹性容器<br>  display:inline-flex 设置为行内的弹性容器</li>
</ul>
</li>
</ol>
<ul>
<li>flex-direction 指定容器中弹性元素的排列方式<ul>
<li>可选值：<ul>
<li>row 默认值，弹性元素在容器中水平排列（左向右）<ul>
<li>主轴 自左向右</li>
</ul>
</li>
<li>row-reverse 弹性元素在容器中反向水平排列（右向左）<ul>
<li>主轴 自右向左</li>
</ul>
</li>
<li>column 弹性元素纵向排列（自上向下）<ul>
<li>主轴 自上向下</li>
</ul>
</li>
<li>column-reverse 弹性元素方向纵向排列（自下向上）<ul>
<li>主轴 自下向上</li>
</ul>
</li>
</ul>
</li>
<li>主轴：<ul>
<li>弹性元素的排列方向称为主轴</li>
</ul>
</li>
<li>侧轴：<ul>
<li>与主轴垂直方向的称为侧轴</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>flex-wrap设置弹性元素是否在弹性容器中自动换行</p>
<ul>
<li>nowrap（默认）：不换行</li>
<li>wrap：元素沿着辅轴方向自动换行</li>
<li>wrap-reverse：元素沿着辅轴反方向换行</li>
</ul>
</li>
<li><p>flex-flow</p>
<ul>
<li>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap</li>
</ul>
</li>
<li><p>justify-content</p>
<ul>
<li>如何分配主轴上的空白空间（主轴上的元素如何排列）</li>
<li>可选值：<ul>
<li>flex-start 元素沿着主轴起边排列</li>
<li>flex-end 元素沿着主轴终边排列</li>
<li>center 元素居中排列</li>
<li>space-around 空白分布到元素两侧</li>
<li>space-between 空白均匀分布到元素间</li>
<li>space-evenly 空白分布到元素的单侧//兼容性不好</li>
</ul>
</li>
</ul>
</li>
<li><p>align-items: </p>
<ul>
<li>元素在辅轴上如何对齐</li>
<li>元素间的关系<ul>
<li>可选值：<ul>
<li>stretch 默认值，将元素的长度设置为相同的值</li>
<li>flex-start 元素不会拉伸，沿着辅轴起边对齐</li>
<li>flex-end 沿着辅轴的终边对齐</li>
<li>center 居中对齐</li>
<li>baseline 基线对齐</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>align-content</p>
<ul>
<li>元素之间的空白如何对齐</li>
</ul>
<ul>
<li>可选值：<ul>
<li>flex-start：与辅轴的起点对齐</li>
<li>flex-end：与辅轴的终点对齐</li>
<li>center：上下的空白相等</li>
<li>space-between：与辅轴两端对齐，轴线之间的间隔平均分布</li>
<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍</li>
<li>stretch（默认值）：轴线占满整个辅轴</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>弹性元素</strong><ul>
<li>弹性容器的子元素是弹性元素（弹性项）</li>
<li>弹性元素可以同时是弹性容器</li>
<li>弹性元素的属性：</li>
</ul>
</li>
</ol>
<ul>
<li><p>flex-grow 指定弹性元素的伸展的系数</p>
<ul>
<li>当父元素有多余空间的时，子元素如何伸展</li>
<li>父元素的剩余空间，会按照比例进行分配</li>
<li>如果flex-grow属性为1，则它们将等分剩余空间（如果有的话）</li>
<li>设置为0，即如果存在剩余空间，也不放大</li>
</ul>
</li>
<li><p>flex-shrink 指定弹性元素的收缩系数</p>
<ul>
<li>当父元素中的空间不足以容纳所有的子元素时，如果对子元素进行收缩</li>
<li>缩减多少是根据 缩减系数 和 元素大小来计算</li>
</ul>
</li>
<li><p>flex-basis 指定的是元素在主轴上的基础长度</p>
<ul>
<li>如果主轴是 横向的 则 该值指定的就是元素的宽度</li>
<li>如果主轴是 纵向的 则 该值指定的是就是元素的高度</li>
<li>默认值是 auto，表示参考元素自身的高度或宽度</li>
<li>如果传递了一个具体的数值，则以该值为准</li>
</ul>
</li>
<li><p>flex 可以设置弹性元素所有的三个样式</p>
<ul>
<li>flex 增长 缩减 基础;</li>
<li>initial “flex: 0 1 auto”.</li>
<li>auto  “flex: 1 1 auto”</li>
<li>none “flex: 0 0 auto” 弹性元素没有弹性</li>
</ul>
</li>
<li><p>order 决定弹性元素的排列顺序</p>
</li>
<li><p>align-self: 用来覆盖当前弹性元素上的align-items</p>
</li>
</ul>
<h1 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h1><h2 id="像素："><a href="#像素：" class="headerlink" title="像素："></a>像素：</h2><ul>
<li>屏幕是由一个一个发光的小点构成，这一个个的小点就是像素</li>
<li>分辨率：1920 x 1080 说的就是屏幕中小点的数量</li>
<li>在前端开发中像素要分成两种情况讨论：CSS像素 和 物理像素</li>
<li>物理像素，上述所说的小点点就属于物理像素</li>
<li>CSS像素，编写网页时，我们所用像素都是CSS像素<ul>
<li>浏览器在显示网页时，需要将CSS像素转换为物理像素然后再呈现</li>
<li>一个css像素最终由几个物理像素显示，由浏览器决定：<br>  默认情况下在pc端，一个css像素 = 一个物理像素</li>
</ul>
</li>
</ul>
<h2 id="视口（viewport）"><a href="#视口（viewport）" class="headerlink" title="视口（viewport）"></a>视口（viewport）</h2><ul>
<li><p>视口就是屏幕中用来显示网页的区域</p>
</li>
<li><p>可以通过查看视口的大小，来观察CSS像素和物理像素的比值</p>
</li>
<li><p>默认情况下：</p>
<ul>
<li>视口宽度 1920px（CSS像素）<pre><code>- 1920px（物理像素）
- 此时，css像素和物理像素的比是 1:1</code></pre></li>
</ul>
</li>
<li><p>放大两倍的情况：</p>
<ul>
<li>视口宽度 960px（CSS像素）<pre><code>- 1920px（物理像素）
- 此时，css像素和物理像素的比是1:2</code></pre></li>
</ul>
</li>
<li><p>我们可以通过改变视口的大小，来改变CSS像素和物理像素的比值</p>
</li>
<li><p>在不同的屏幕，单位像素的大小是不同的，像素越小屏幕会越清晰</p>
</li>
<li><p><strong><em>问题：一个宽度为900px的网页在手机中要如何显示呢？</em></strong></p>
<ul>
<li>默认情况下，移动端的网页都会将视口设置为980像素（css像素），以确保pc端网页可以在移动端正常访问，但是如果网页的宽度超过了980，移动端的浏览器会自动对网页缩放以完整显示网页  </li>
<li>所以基本大部分的pc端网站都可以在移动端中正常浏览，但是往往都不会有一个好的体验，为了解决这个问题，大部分网站都会专门为移动端设计网页</li>
</ul>
</li>
<li><p>移动端默认的视口大小是980px(css像素)，默认情况下，移动端的像素比就是980/移动端宽度（980/750）</p>
<ul>
<li><p>如果我们直接在网页中编写移动端代码，这样在980的视口下，像素比是非常不好，导致网页中的内容非常非常的小</p>
</li>
<li><p>编写移动页面时，必须要确保有一个比较合理的像素比：</p>
<ul>
<li>1css像素 对应 2个物理像素</li>
<li>1css像素 对应 3个物理像素</li>
</ul>
</li>
<li><p>可以通过meta标签来设置视口大小</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设置视口大小 device-width表示设备的宽度（完美视口）,初始化缩放1倍</span><br><span class="line">&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>每一款移动设备设计时，都会有一个最佳的像素比，一般我们只需要将像素比设置为该值即可得到一个最佳效果,将像素比设置为最佳像素比的视口大小我们称其为完美视口</p>
</li>
<li><p>由于不同设备视口和像素比不同，所以同样的375个像素在不同的设备下意义是不一样，比如在iphone6中 375就是全屏，而到了plus中375就会缺一块</p>
</li>
<li><p>所以在移动端开发时，就不能再使用px来进行布局了</p>
</li>
</ul>
</li>
</ul>
<h2 id="vw"><a href="#vw" class="headerlink" title="vw"></a>vw</h2><ul>
<li>vw 表示的是视口的宽度（viewport width）<ul>
<li>100vw = 一个视口的宽度</li>
<li>1vw = 1%视口宽度</li>
<li>vw这个单位永远相当于视口宽度进行计算</li>
</ul>
</li>
</ul>
<h1 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h1><ul>
<li><p>网页可以根据不通的设备或窗口大小呈现出不同的效果</p>
</li>
<li><p>使用响应式布局，可以使一个网页适用于所有设备</p>
</li>
<li><p>响应布局的关键就是 <strong>媒体查询</strong></p>
</li>
<li><p>通过媒体查询，可以为不同的设备，或设备不同状态来分别设置样式</p>
</li>
<li><p>使用媒体查询 </p>
<ul>
<li>语法： @media 查询规则{}<ul>
<li>媒体类型：<ul>
<li>all 所有设备</li>
<li>print 打印设备</li>
<li>screen 带屏幕的设备</li>
<li>speech 屏幕阅读器</li>
<li>可以使用,连接多个媒体类型，这样它们之间就是一个或的关系</li>
</ul>
</li>
<li>可以在媒体类型前添加一个only，表示只有。<ul>
<li>only的使用主要是为了兼容一些老版本浏览器</li>
</ul>
</li>
</ul>
</li>
<li>媒体特性：<ul>
<li>width 视口的宽度</li>
<li>height 视口的高度</li>
<li>min-width 视口的最小宽度（视口大于指定宽度时生效）</li>
<li>max-width 视口的最大宽度（视口小于指定宽度时生效）</li>
<li>样式切换的分界点，我们称其为断点，也就是网页的样式会在这个点时发生变化<br>一般比较常用的断点</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a href="https://www.w3school.com.cn/css/index.asp" target="_blank" rel="noopener">css详细教程</a></p>
]]></content>
      <categories>
        <category>前端三大块</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery</title>
    <url>/2020/07/10/jQuery/</url>
    <content><![CDATA[<blockquote>
<p>序<br><br>一个JS函数库</p>
</blockquote>
<a id="more"></a>

<h1 id="了解jQuery"><a href="#了解jQuery" class="headerlink" title="了解jQuery"></a>了解jQuery</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>一个JS函数库: write less, do more</li>
<li>封装简化DOM操作(CRUD) / Ajax</li>
</ul>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>强大选择器: 方便快速查找DOM元素</li>
<li>隐式遍历(迭代): 一次操作多个元素</li>
<li>读写合一: 读数据/写数据用的是一个函数</li>
<li>链式调用: 可以通过.不断调用jQuery对象的方法</li>
<li>事件处理</li>
<li>DOM操作(CUD)</li>
<li>样式操作</li>
<li>动画</li>
<li>浏览器兼容</li>
</ul>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ul>
<li>引入jQuery库<ul>
<li>本地引入与CDN远程引入<ul>
<li>CDN远程引入网站：<a href="https://www.bootcdn.cn/" target="_blank" rel="noopener">BootCDN</a></li>
</ul>
</li>
<li>测试版与生产版(压缩版)</li>
</ul>
</li>
<li>使用jQuery<ul>
<li>使用jQuery函数: $/jQuery</li>
<li>使用jQuery对象: $xxx(执行$()得到的)</li>
</ul>
</li>
</ul>
<h2 id="多库共存"><a href="#多库共存" class="headerlink" title="多库共存"></a>多库共存</h2><ul>
<li>问题 : 如果有2个库都有$, 就存在冲突</li>
<li>解决 : jQuery库可以释放$的使用权, 让另一个库可以正常使用,<br>此时jQuery库只能使用jQuery了</li>
<li>API : jQuery.noConflict()</li>
</ul>
<h1 id="jQuery的2把利器"><a href="#jQuery的2把利器" class="headerlink" title="jQuery的2把利器"></a>jQuery的2把利器</h1><h2 id="jQuery函数-jQuery"><a href="#jQuery函数-jQuery" class="headerlink" title="jQuery函数-jQuery"></a>jQuery函数-jQuery</h2><ul>
<li><p>jQuery向外暴露的就是jQuery函数, 可以直接使用</p>
</li>
<li><p>当成一般函数使用人: $(param)</p>
<ul>
<li>param是function: 相当于window.onload =<br>function(文档加载完成的监听)</li>
<li>param是选择器字符串: 查找所有匹配的DOM元素,<br>返回包含所有DOM元素的jQuery对象</li>
<li>param是DOM元素: 将DOM元素对象包装为jQuery对象返回 $(this)</li>
<li>param是标签字符串: 创建标签DOM元素对象并包装为jQuery对象返回<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  例子：</span><br><span class="line">    &#x2F;&#x2F;1). 参数为函数 : 当DOM加载完成后，执行其中的函数     回调函数</span><br><span class="line">$(function () &#123;</span><br><span class="line">&#x2F;&#x2F;2). 参数为选择器(selector)字符串: 查找所有匹配的标签, 并将它们封装成jQuery对象</span><br><span class="line">var $btn &#x3D; $(&quot;#btn&quot;)</span><br><span class="line">$btn.click(function () &#123;</span><br><span class="line">    &#x2F;&#x2F;this就是发生事件的dom元素对象(也就是button)</span><br><span class="line">    &#x2F;&#x2F;3). 参数为DOM对象: 将dom对象封装成jQuery对象</span><br><span class="line">    var text &#x3D; $(this).html()</span><br><span class="line">    alert(text)</span><br><span class="line">    &#x2F;&#x2F;4). 参数为html标签字符串 (用得少): 创建标签对象并封装成jQuery对象</span><br><span class="line">    $(&#39;&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;msg3&quot; &#x2F;&gt;&lt;br &#x2F;&gt;&#39;).appendTo(&#39;div&#39;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>当成对象使用: $.xxx</p>
<ul>
<li>each(obj/arr, function(key, value){})</li>
<li>trim(str)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  例子：</span><br><span class="line">&#x2F;*需求2. 遍历输出数组中所有元素值*&#x2F;</span><br><span class="line">var arr &#x3D; [123, &#39;xxx&#39;, true]</span><br><span class="line">&#x2F;&#x2F; 1). $.each() : 隐式遍历数组</span><br><span class="line">$.each(arr, function (index, item) &#123;</span><br><span class="line">console.log(&#39;第&#39; + (index + 1) + &#39;个元素的值为&#39; + item)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;*需求3. 去掉&quot;  my atguigu  &quot;两端的空格*&#x2F;</span><br><span class="line">var str &#x3D; &quot;  my xxx  &quot;</span><br><span class="line">&#x2F;&#x2F; 2). $.trim() : 去除两端的空格</span><br><span class="line">console.log(str.trim() &#x3D;&#x3D;&#x3D; &#39;my xxx&#39;)</span><br><span class="line">console.log($.trim(str) &#x3D;&#x3D;&#x3D; &#39;my xxx&#39;) &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="jQuery对象"><a href="#jQuery对象" class="headerlink" title="jQuery对象"></a>jQuery对象</h2><ul>
<li>包含所有匹配的n个DOM元素的伪数组对象</li>
<li>执行$()返回的就是jQuery对象</li>
<li>基本行为:<ul>
<li>length/size(): 得到dom元素的个数</li>
<li>[index] : 得到指定下标对应的dom元素</li>
<li>each(function(index, domEle){}): 遍历所有dom元素</li>
<li>index(): 得到当前dom元素在所有兄弟中的下标<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(function () &#123;</span><br><span class="line">var $btns &#x3D; $(&#39;button&#39;)</span><br><span class="line">console.log($btns)</span><br><span class="line">&#x2F;&#x2F; 需求1. 统计一共有多少个按钮</span><br><span class="line">    &#x2F;*size()&#x2F;length: 包含的DOM元素个数*&#x2F;</span><br><span class="line">console.log($btns.size(), $btns.length)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 需求2. 取出第2个button的文本</span><br><span class="line">    &#x2F;*[index]&#x2F;get(index): 得到对应位置的DOM元素*&#x2F;</span><br><span class="line">console.log($btns[1].innerHTML, $btns.get(1).innerHTML)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 需求3. 输出所有button标签的文本</span><br><span class="line">    &#x2F;*each(): 遍历包含的所有DOM元素*&#x2F;</span><br><span class="line">$btns.each(function () &#123;</span><br><span class="line">    console.log(this.innerHTML)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 需求4. 输出&#39;测试三&#39;按钮是所有按钮中的第几个</span><br><span class="line">    &#x2F;*index(): 得到在所在兄弟元素中的下标*&#x2F;</span><br><span class="line">console.log($(&#39;#btn3&#39;).index())</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>伪数组<ol>
<li>object对象</li>
<li>length属性</li>
<li>数值下标属性</li>
<li><strong>没有数组特别的方法</strong>：例如foreach()<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   &#x2F;&#x2F;自定义一个位数组</span><br><span class="line">var weiarr&#x3D;&#123;&#125;</span><br><span class="line">weiarr.length&#x3D;0</span><br><span class="line">weiarr[0]&#x3D;&#39;xxxx&#39;</span><br><span class="line">weiarr.length&#x3D;1</span><br><span class="line">weiarr[0]&#x3D;123</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h1 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><ul>
<li>有特定语法规则(css选择器)的字符串</li>
<li>用来查找某个/些DOM元素: $(selector)</li>
</ul>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li>基本选择器<ul>
<li>#id: id选择器</li>
<li>element : 元素选择器</li>
<li>.class: 属性选择器</li>
<li>selector1,selector2,selector3: 并集</li>
<li>selector1selector2selector3: 交集</li>
<li>: 任意标签</li>
</ul>
</li>
<li>层次选择器<ul>
<li>查找子元素, 后代元素, 兄弟元素的选择器</li>
<li>selector1&gt;selector2: 子元素</li>
<li>selector1 selector2: 后代元素</li>
<li>prev+next<ul>
<li>匹配所有紧接在 prev 元素后的 next 元素</li>
</ul>
</li>
<li>prev~siblings<ul>
<li>匹配 prev 元素之后的所有 siblings 元素</li>
</ul>
</li>
</ul>
</li>
<li>过滤选择器<ul>
<li>在原有选择器匹配的元素中进一步进行过滤的选择器</li>
<li>:first 获取第一个元素</li>
<li>:last 获取最后个元素</li>
<li>:eq(index) 匹配一个给定索引值的元素</li>
<li>:lt 匹配所有小于给定索引值的元素</li>
<li>:gt 匹配所有大于给定索引值的元素</li>
<li>:odd 匹配所有索引值为奇数的元素，从 0 开始计数</li>
<li>:even 匹配所有索引值为偶数的元素，从 0 开始计数</li>
<li>:not(selector) 去除所有与给定选择器匹配的元素</li>
<li>:hidden 匹配所有不可见元素，或者type为hidden的元素</li>
<li>:visible 匹配所有的可见元素</li>
<li>:contains(text) 匹配包含给定文本的元素</li>
<li>[属性] 匹配包含给定属性的元素</li>
<li>[属性=属性值] 匹配给定的属性是某个特定值的元素</li>
</ul>
</li>
<li>表单选择器<ul>
<li>:input 匹配所有 input, textarea, select 和 button 元素</li>
<li>:text 匹配所有的单行文本框</li>
<li>:checkbox 匹配所有复选框</li>
<li>:radio 匹配所有单选按钮</li>
<li>:checked:匹配所有选中的被选中元素(复选框、单选框等，不包括select中的option)</li>
</ul>
</li>
</ul>
<h2 id="工具方法"><a href="#工具方法" class="headerlink" title="$工具方法"></a>$工具方法</h2><ol>
<li>$.each(): 遍历数组或对象中的数据</li>
<li>$.trim(): 去除字符串两边的空格</li>
<li>$.type(obj): 得到数据的类型</li>
<li>$.isArray(obj): 判断是否是数组</li>
<li>$.isFunction(obj): 判断是否是函数</li>
<li>$.parseJSON(json) : 解析json字符串转换为js对象/数组</li>
</ol>
<h1 id="属性-文本"><a href="#属性-文本" class="headerlink" title="属性-文本"></a>属性-文本</h1><ul>
<li>操作标签的属性, 标签体文本</li>
<li>attr(name) / attr(name, value): 读写非布尔值的标签属性</li>
<li>prop(name) / prop(name, value): 读写布尔值的标签属性</li>
<li>removeAttr(name)/removeProp(name): 删除属性</li>
<li>addClass(classValue): 添加class</li>
<li>removeClass(classValue): 移除指定class</li>
<li>val() / val(value): 读写标签的value</li>
<li>html() / html(htmlString): 读写标签体文本</li>
</ul>
<h1 id="CSS模块"><a href="#CSS模块" class="headerlink" title="CSS模块"></a>CSS模块</h1><h2 id="style样式"><a href="#style样式" class="headerlink" title="style样式"></a>style样式</h2><ul>
<li>css(styleName): 根据样式名得到对应的值</li>
<li>css(styleName, value): 设置一个样式</li>
<li>css({多个样式对}): 设置多个样式</li>
</ul>
<h2 id="位置坐标"><a href="#位置坐标" class="headerlink" title="位置坐标"></a>位置坐标</h2><ul>
<li>offset(): 读/写当前元素坐标(原点是页面左上角)</li>
<li>position(): 读当前元素坐标(原点是父元素左上角)</li>
<li>scrollTop()/scrollLeft(): 读/写元素/页面的滚动条坐标<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;jquery实现backup</span><br><span class="line">&lt;script src&#x3D;&quot;jquery-1.10.1.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">$(function () &#123;</span><br><span class="line">    &#x2F;&#x2F;回到顶部</span><br><span class="line">    $(&#39;#to_top&#39;).click(function () &#123;</span><br><span class="line">    var $body &#x3D; $(document.body)</span><br><span class="line">    var $html &#x3D; $(document.documentElement)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;使用scrollTop(): 瞬间滚动到顶部</span><br><span class="line">    &#x2F;&#x2F; $(&#39;html,body&#39;).scrollTop(0)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;使用scrollTop(): 平滑滚动到顶部</span><br><span class="line">    var offset &#x3D; $body.scrollTop() + $html.scrollTop()&#x2F;&#x2F;总距离</span><br><span class="line">    if(offset&#x3D;&#x3D;&#x3D;0) &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    var totalTime &#x3D; 300&#x2F;&#x2F;总时间</span><br><span class="line">    var intervalTime &#x3D; 30&#x2F;&#x2F;间隔时间</span><br><span class="line">    var itemOffset &#x3D; offset&#x2F;(totalTime&#x2F;intervalTime)&#x2F;&#x2F;每一段间隔时间内滚多少距离</span><br><span class="line">    var intervalId &#x3D; setInterval(function () &#123;</span><br><span class="line">        offset -&#x3D; itemOffset&#x2F;&#x2F;总距离减去一次间隔时间内的距离</span><br><span class="line">        if(offset&lt;&#x3D;0) &#123;</span><br><span class="line">        offset &#x3D; 0</span><br><span class="line">        clearInterval(intervalId)</span><br><span class="line">        &#125;</span><br><span class="line">        $(&#39;html,body&#39;).scrollTop(offset)</span><br><span class="line">    &#125;, intervalTime)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;使用动画: 平滑滚动到顶部</span><br><span class="line">    $(&#39;body,html&#39;).animate(&#123;scrollTop:0&#125;,300)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h2><ol>
<li>内容尺寸</li>
</ol>
<ul>
<li>height(): height</li>
<li>width(): width</li>
</ul>
<ol start="2">
<li>内部尺寸</li>
</ol>
<ul>
<li>innerHeight(): height+padding</li>
<li>innerWidth(): width+padding</li>
</ul>
<ol start="3">
<li>外部尺寸</li>
</ol>
<ul>
<li>outerHeight(false/true): height+padding+border 如果是true,<br>加上margin</li>
<li>outerWidth(false/true): width+padding+border 如果是true, 加上margin</li>
</ul>
<h1 id="筛选模块"><a href="#筛选模块" class="headerlink" title="筛选模块"></a>筛选模块</h1><h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><ul>
<li>在jQuery对象内部的元素中找出部分匹配的元素,<br>并封装成新的jQuery对象返回</li>
<li>first()：获取第一个元素</li>
<li>last()：获取最后一个元素</li>
<li>eq(index)：获取第N个元素</li>
<li>filter(selector): 筛选出与指定表达式匹配的元素集合</li>
<li>not(selector): 指定表达式匹配的元素，并取反</li>
<li>has(selector): 保留包含特定后代的元素，去掉那些不含有指定后代的元素</li>
</ul>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><ul>
<li>查找jQuery对象内部的元素的子孙/兄弟/父母元素,<br>并封装成新的jQuery对象返回</li>
<li>children(selector): 子元素</li>
<li>parent(): 父元素</li>
<li>find(selector): 后代元素</li>
<li>preAll(selector): 查找当前元素之前所有的同辈元素</li>
<li>siblings(selector):<br>取得一个包含匹配的元素集合中每一个元素的所有唯一同辈元素的元素集合。可以用可选的表达式进行筛选</li>
</ul>
<h1 id="文档处理-CUD-模块"><a href="#文档处理-CUD-模块" class="headerlink" title="文档处理-CUD-模块"></a>文档处理-CUD-模块</h1><h2 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h2><ul>
<li>append() / appendTo(): 向当前匹配的所有元素内部的最后插入指定内容</li>
<li>preppend() / preppendTo():<br>向当前匹配的所有元素内部的最前面插入指定内容</li>
<li>before(): 将指定内容插入到当前所有匹配元素的前面</li>
<li>after(): 在每个匹配的元素之后插入内容</li>
</ul>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><ul>
<li>remove(): 将自己及内部的孩子都删除</li>
<li>empty(): 掏空(自己还在)</li>
</ul>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><ul>
<li>replaceWith()：将所有匹配的元素替换成指定的HTML或DOM元素</li>
</ul>
<h1 id="事件模块"><a href="#事件模块" class="headerlink" title="事件模块"></a>事件模块</h1><h2 id="绑定事件"><a href="#绑定事件" class="headerlink" title="绑定事件"></a>绑定事件</h2><ul>
<li>eventName(function(){})<ul>
<li>绑定对应事件名的监听, 例如：$(‘#div’).click(function(){});</li>
</ul>
</li>
<li>on(‘eventName’, function(){})<ul>
<li>通用的绑定事件监听, 例如：$(‘#div’).on(‘click’, function(){})</li>
</ul>
</li>
<li>常用: click, mouseenter/mouseleave mouseover/mouseout focus/blur</li>
<li>hover(function(){}, function(){})</li>
</ul>
<h2 id="解绑事件"><a href="#解绑事件" class="headerlink" title="解绑事件"></a>解绑事件</h2><ul>
<li>off(‘eventName’)</li>
</ul>
<h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><ul>
<li>理解<ul>
<li>将多个子元素的事件监听委托给父辈元素处理</li>
<li>监听回调是加在了父辈元素上</li>
<li>当操作任何一个子元素时, 事件会冒泡到父辈元素</li>
<li>父辈元素不会直接处理事件,<br>而是根据event.target得到发生事件的子元素,<br>通过这个子元素调用事件回调函数</li>
</ul>
</li>
<li>好处<ul>
<li>添加新的子元素, 自动有事件响应处理</li>
<li>减少事件监听的数量: n==&gt;1</li>
</ul>
</li>
<li>jQuery的事件委托API<ul>
<li>设置事件委托: $(parentSelector).delegate(childrenSelector,<br>eventName, callback)// 回调函数中的this是子元素</li>
<li>移除事件委托: $(parentSelector).undelegate(eventName)</li>
</ul>
</li>
</ul>
<h2 id="事件坐标"><a href="#事件坐标" class="headerlink" title="事件坐标"></a>事件坐标</h2><ul>
<li>event.offsetX: 原点是当前元素左上角</li>
<li>event.clientX: 原点是窗口左上角</li>
<li>event.pageX: 原点是页面左上角</li>
</ul>
<h2 id="事件相关"><a href="#事件相关" class="headerlink" title="事件相关"></a>事件相关</h2><ul>
<li>停止事件冒泡: event.stopPropagation()</li>
<li>阻止事件的默认行为: event.preventDefault()</li>
</ul>
<h2 id="区别mouseover与mouseenter"><a href="#区别mouseover与mouseenter" class="headerlink" title="区别mouseover与mouseenter"></a>区别mouseover与mouseenter</h2><ul>
<li><p>mouseover: 在移入子元素时也会触发, 对应mouseout</p>
</li>
<li><p>mouseenter: 只在移入当前元素时才触发, 对应mouseleave</p>
</li>
<li><p>hover()使用的就是mouseenter()和mouseleave()</p>
<h1 id="动画效果"><a href="#动画效果" class="headerlink" title="动画效果"></a>动画效果</h1></li>
<li><p>在一定的时间内, 不断改变元素样式</p>
</li>
</ul>
<h2 id="淡入淡出-不断改变元素的透明度来实现的"><a href="#淡入淡出-不断改变元素的透明度来实现的" class="headerlink" title="淡入淡出-不断改变元素的透明度来实现的"></a>淡入淡出-不断改变元素的透明度来实现的</h2><pre><code>1.  fadeIn(): 带动画的显示
2.  fadeOut(): 带动画隐藏
3.  fadeToggle(): 带动画切换显示/隐藏</code></pre><h2 id="滑动动画"><a href="#滑动动画" class="headerlink" title="滑动动画"></a>滑动动画</h2><ol>
<li>slideDown(): 带动画的展开</li>
<li>slideUp(): 带动画的收缩</li>
<li>slideToggle(): 带动画的切换展开/收缩</li>
</ol>
<h2 id="显示隐藏，默认没有动画"><a href="#显示隐藏，默认没有动画" class="headerlink" title="显示隐藏，默认没有动画"></a>显示隐藏，默认没有动画</h2><ol>
<li>show(): (不)带动画的显示</li>
<li>hide(): (不)带动画的隐藏</li>
<li>toggle(): (不)带动画的切换显示/隐藏</li>
</ol>
<h2 id="jQuery动画本质-在指定时间内不断改变元素样式值来实现的"><a href="#jQuery动画本质-在指定时间内不断改变元素样式值来实现的" class="headerlink" title="jQuery动画本质-在指定时间内不断改变元素样式值来实现的"></a>jQuery动画本质-在指定时间内不断改变元素样式值来实现的</h2><ol>
<li>animate(): 自定义动画效果的动画</li>
<li>stop(): 停止动画</li>
</ol>
<h1 id="插件机制"><a href="#插件机制" class="headerlink" title="插件机制"></a>插件机制</h1><h2 id="扩展jQuery函数对象的方法"><a href="#扩展jQuery函数对象的方法" class="headerlink" title="扩展jQuery函数对象的方法"></a>扩展jQuery函数对象的方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$.extend(&#123;</span><br><span class="line">  xxx: fuction () &#123;&#125; &#x2F;&#x2F; this是$</span><br><span class="line">&#125;)</span><br><span class="line">$.xxx()</span><br></pre></td></tr></table></figure>

<h2 id="扩展jQuery对象的方法"><a href="#扩展jQuery对象的方法" class="headerlink" title="扩展jQuery对象的方法"></a>扩展jQuery对象的方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$.fn.extend(&#123;</span><br><span class="line">  xxx: function()&#123;&#125;  &#x2F;&#x2F; this是jQuery对象</span><br><span class="line">&#125;)</span><br><span class="line">$obj.xxx()</span><br></pre></td></tr></table></figure>

<p>#其他  </p>
<h2 id="window-onload与-document-ready-的区别"><a href="#window-onload与-document-ready-的区别" class="headerlink" title="window-onload与-document-ready-的区别"></a>window-onload与-document-ready-的区别</h2><ul>
<li>window.onload<ul>
<li>包括页面的图片加载完后才会回调(晚)</li>
<li>只能有一个监听回调</li>
</ul>
</li>
<li>$(document).ready()<ul>
<li>等同于: $(function(){})</li>
<li>页面加载完就回调(早)</li>
<li>可以有多个监听回调</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>Gulp</title>
    <url>/2020/07/18/Gulp/</url>
    <content><![CDATA[<blockquote>
<p>序<br><br>gulp是与grunt功能类似的<strong>前端项目构建</strong>工具, 也是基于Nodejs的自动<strong>任务运行器</strong></p>
</blockquote>
<a id="more"></a>

<h1 id="Gulp"><a href="#Gulp" class="headerlink" title="Gulp"></a>Gulp</h1><ul>
<li>中文主页: <a href="http://www.gulpjs.com.cn/" target="_blank" rel="noopener">http://www.gulpjs.com.cn/</a></li>
<li>gulp是与grunt功能类似的<strong>前端项目构建</strong>工具, 也是基于Nodejs的自动<strong>任务运行器</strong></li>
<li>能自动化地完成 javascript/coffee/sass/less/html/image/css 等文件的合并、压缩、检查、监听文件变化、浏览器自动刷新、测试等任务</li>
<li>gulp更高效(异步多任务), 更易于使用, 插件高质量</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul>
<li>举例创建一个简单的应用gulp_test<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|- dist&#x2F;&#x2F;放打包生成的文件</span><br><span class="line">|- src</span><br><span class="line">  |- js</span><br><span class="line">  |- css</span><br><span class="line">  |- less</span><br><span class="line">|- index.html</span><br><span class="line">|- gulpfile.js-----gulp配置文件</span><br><span class="line">|- package.json</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;name&quot;: &quot;gulp_test&quot;,</span><br><span class="line">    &quot;version&quot;: &quot;1.0.0&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li>安装nodejs, 查看版本<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure></li>
<li>安装gulp:<ul>
<li>全局安装gulp<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install gulp -g</span><br></pre></td></tr></table></figure></li>
<li>局部安装gulp<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install gulp@3.9.1 --save-dev </span><br><span class="line">&#x2F;&#x2F;以下指令都是3.9版本的，4.0以上版本指令与3.9不同</span><br></pre></td></tr></table></figure></li>
<li>配置编码: gulpfile.js<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;引入gulp模块</span><br><span class="line">var gulp &#x3D; require(&#39;gulp&#39;);</span><br><span class="line">&#x2F;&#x2F;定义默认任务</span><br><span class="line">gulp.task(&#39;任务名&#39;, function() &#123;</span><br><span class="line">  &#x2F;&#x2F; 将你的任务的任务代码放在这</span><br><span class="line">&#125;);</span><br><span class="line">gulp.task(&#39;default&#39;, [&#39;任务&#39;])&#x2F;&#x2F;异步执行</span><br></pre></td></tr></table></figure></li>
<li>构建命令: <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gulp</span><br></pre></td></tr></table></figure>
<h2 id="使用gulp插件"><a href="#使用gulp插件" class="headerlink" title="使用gulp插件"></a>使用gulp插件</h2></li>
<li>相关插件:<ul>
<li>gulp-concat : 合并文件(js/css)</li>
<li>gulp-uglify : 压缩js文件</li>
<li>gulp-rename : 文件重命名</li>
<li>gulp-less : 编译less</li>
<li>gulp-clean-css : 压缩css</li>
<li>gulp-livereload : 实时自动编译刷新</li>
</ul>
</li>
<li><strong>重要API</strong><ul>
<li>gulp.src(filePath/pathArr) : <ul>
<li>指向指定路径的所有文件, 返回文件流对象</li>
<li>用于读取文件</li>
</ul>
</li>
<li>gulp.dest(dirPath/pathArr)<ul>
<li>指向指定的所有文件夹</li>
<li>用于向文件夹中输出文件</li>
</ul>
</li>
<li>gulp.task(name, [deps], fn) <ul>
<li>定义一个任务</li>
</ul>
</li>
<li>gulp.watch() <ul>
<li>监视文件的变化</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="处理js"><a href="#处理js" class="headerlink" title="处理js"></a>处理js</h2><ul>
<li>下载插件:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install gulp-concat gulp-uglify gulp-rename --save-dev</span><br></pre></td></tr></table></figure></li>
<li>配置编码  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var concat &#x3D; require(&#39;gulp-concat&#39;);</span><br><span class="line">var uglify &#x3D; require(&#39;gulp-uglify&#39;);</span><br><span class="line">var rename &#x3D; require(&#39;gulp-rename&#39;);</span><br><span class="line"></span><br><span class="line">gulp.task(&#39;minifyjs&#39;, function() &#123;</span><br><span class="line">    return gulp.src(&#39;src&#x2F;js&#x2F;*.js&#39;) &#x2F;&#x2F;找到操作的源文件，将文件读取到gulp的内存</span><br><span class="line">        .pipe(concat(&#39;built.js&#39;)) &#x2F;&#x2F;合并到临时文件     </span><br><span class="line">        .pipe(gulp.dest(&#39;dist&#x2F;js&#39;)) &#x2F;&#x2F;临时生成到目标文件夹</span><br><span class="line">        .pipe(rename(&#123;suffix: &#39;.min&#39;&#125;)) &#x2F;&#x2F;重命名（后缀名+min）  </span><br><span class="line">        .pipe(uglify())    &#x2F;&#x2F;压缩</span><br><span class="line">        .pipe(gulp.dest(&#39;dist&#x2F;js&#39;));&#x2F;&#x2F;生成到目标文件夹</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(&#39;default&#39;, [&#39;minifyjs&#39;]);</span><br></pre></td></tr></table></figure></li>
<li>页面引入js浏览测试 : index.html  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;dist&#x2F;js&#x2F;built.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li>
<li>打包测试: gulp</li>
</ul>
<h2 id="处理css"><a href="#处理css" class="headerlink" title="处理css"></a>处理css</h2><ul>
<li>下载插件:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install gulp-less gulp-clean-css --save-dev</span><br></pre></td></tr></table></figure></li>
<li>配置编码  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var less &#x3D; require(&#39;gulp-less&#39;);</span><br><span class="line">var cleanCSS &#x3D; require(&#39;gulp-clean-css&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;less处理任务</span><br><span class="line">gulp.task(&#39;lessTask&#39;, function () &#123;</span><br><span class="line">return gulp.src(&#39;src&#x2F;less&#x2F;*.less&#39;)</span><br><span class="line">    .pipe(less())               &#x2F;&#x2F;编译less文件为css文件</span><br><span class="line">    .pipe(gulp.dest(&#39;src&#x2F;css&#39;));</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;css处理任务, 指定依赖的任务,当lessTask执行完在执行该任务</span><br><span class="line">gulp.task(&#39;cssTask&#39;,[&#39;lessTask&#39;], function () &#123;</span><br><span class="line"></span><br><span class="line">return gulp.src(&#39;src&#x2F;css&#x2F;*.css&#39;)</span><br><span class="line">    .pipe(concat(&#39;built.css&#39;))</span><br><span class="line">    .pipe(gulp.dest(&#39;dist&#x2F;css&#39;))</span><br><span class="line">    .pipe(rename(&#123;suffix: &#39;.min&#39;&#125;))</span><br><span class="line">    .pipe(cleanCSS(&#123;compatibility: &#39;ie8&#39;&#125;)) &#x2F;&#x2F;兼容到ie8</span><br><span class="line">    .pipe(gulp.dest(&#39;dist&#x2F;css&#39;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(&#39;default&#39;, [&#39;minifyjs&#39;, &#39;cssTask&#39;]);</span><br></pre></td></tr></table></figure></li>
<li>页面引入css浏览测试 : index.html  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;dist&#x2F;css&#x2F;built.min.css&quot;&gt;</span><br></pre></td></tr></table></figure></li>
<li>打包测试: gulp</li>
</ul>
<h2 id="处理html"><a href="#处理html" class="headerlink" title="处理html"></a>处理html</h2><ul>
<li>下载插件:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install gulp-htmlmin --save-dev</span><br></pre></td></tr></table></figure></li>
<li>配置编码  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var htmlmin &#x3D; require(&#39;gulp-htmlmin&#39;);</span><br><span class="line">&#x2F;&#x2F;压缩html任务</span><br><span class="line">gulp.task(&#39;htmlMinify&#39;, function() &#123;</span><br><span class="line">    return gulp.src(&#39;index.html&#39;)</span><br><span class="line">        .pipe(htmlmin(&#123;collapseWhitespace: true&#125;))&#x2F;&#x2F;清除空格</span><br><span class="line">        .pipe(gulp.dest(&#39;dist&#39;));</span><br><span class="line">&#125;);</span><br><span class="line">gulp.task(&#39;default&#39;, [&#39;minifyjs&#39;, &#39;cssTask&#39;, &#39;htmlMinify&#39;]);</span><br></pre></td></tr></table></figure></li>
<li>修改页面引入  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;css&#x2F;built.min.css&quot;&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;js&#x2F;built.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li>
<li>打包测试: gulp    </li>
</ul>
<h2 id="自动编译"><a href="#自动编译" class="headerlink" title="自动编译"></a>自动编译</h2><ul>
<li>下载插件  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install gulp-livereload --save-dev</span><br></pre></td></tr></table></figure></li>
<li>配置编码:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var livereload &#x3D; require(&#39;gulp-livereload&#39;);</span><br><span class="line">        </span><br><span class="line">&#x2F;&#x2F;所有的pipe</span><br><span class="line">.pipe(livereload());</span><br><span class="line"></span><br><span class="line">gulp.task(&#39;watch&#39;, [&#39;default&#39;], function () &#123;    </span><br><span class="line">&#x2F;&#x2F;开启监视</span><br><span class="line">livereload.listen();</span><br><span class="line">&#x2F;&#x2F;监视指定的文件, 并指定对应的处理任务</span><br><span class="line">gulp.watch(&#39;src&#x2F;js&#x2F;*.js&#39;, [&#39;minifyjs&#39;])</span><br><span class="line">gulp.watch([&#39;src&#x2F;css&#x2F;*.css&#39;,&#39;src&#x2F;less&#x2F;*.less&#39;], [&#39;cssTask&#39;,&#39;lessTask&#39;]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="热加载-实时加载"><a href="#热加载-实时加载" class="headerlink" title="热加载(实时加载)"></a>热加载(实时加载)</h2><ul>
<li>下载插件：gulp-connect<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、npm install gulp-connect --save-dev</span><br><span class="line"></span><br><span class="line">2、注册 热加载的任务 server，注意依赖build任务 </span><br><span class="line">gulp.task(&#39;watch&#39;, [&#39;default&#39;], function () &#123;&#125;</span><br><span class="line"></span><br><span class="line">3、注册热加载的任务</span><br><span class="line">    &#x2F;&#x2F;配置加载的选项</span><br><span class="line">    connect.server(&#123;</span><br><span class="line">            root : &#39;dist&#x2F;&#39;,&#x2F;&#x2F;监视的源目标文件路径</span><br><span class="line">            livereload : true,&#x2F;&#x2F;是否实时刷新</span><br><span class="line">            port : 5000&#x2F;&#x2F;开启端口号</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 自动开启链接</span><br><span class="line">    open(&#39;http:&#x2F;&#x2F;localhost:5000&#39;);</span><br><span class="line">    &#x2F;&#x2F;npm install open --save-dev</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 监视目标文件</span><br><span class="line">    gulp.watch(&#39;src&#x2F;js&#x2F;*.js&#39;, [&#39;js&#39;]);</span><br><span class="line">    gulp.watch([&#39;src&#x2F;css&#x2F;*.css&#39;, &#39;src&#x2F;css&#x2F;*.less&#39;], [&#39;cssMin&#39;, &#39;less&#39;]);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul>
<li>打包加载gulp插件</li>
<li>前提：将插件下载好。</li>
<li>下载打包插件： gulp-load-plugins</li>
<li>npm install gulp-load-plugins –save-dev</li>
<li>引入： var $ = require(‘gulp-load-plugins’)();！！！引入的插件是个方法，必须记住调用。</li>
<li>其他的插件不用再引入了</li>
<li>使用方法：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 所有的插件用 $ 引出，其他插件的方法名统一为插件的功能名字(即插件名字的最后一部分)：如：concat,connect,cssmin...</span><br><span class="line">gulp.task(&#39;less&#39;, function () &#123;</span><br><span class="line">    return gulp.src(&#39;src&#x2F;less&#x2F;*.less&#39;)</span><br><span class="line">    .pipe($.less())&#x2F;&#x2F;将less转换为less</span><br><span class="line">    .pipe(gulp.dest(&#39;src&#x2F;css&#x2F;&#39;))</span><br><span class="line">    &#x2F;&#x2F;将转换为less的文件输出到src下</span><br><span class="line">    .pipe($.livereload())&#x2F;&#x2F;实时刷新</span><br><span class="line">    .pipe($.connect.reload())</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>自动化构建工具</category>
      </categories>
      <tags>
        <tag>Gulp</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack</title>
    <url>/2020/07/18/Webpack/</url>
    <content><![CDATA[<blockquote>
<p>序<br><br>webpack是一种前端资源构建工具，一个静态模块打包器(modulebundler)<br><br>在webpack看来,前端的所有资源文件(js/json/css/img/less/…)都会作为模块处理<br><br>它将根据模块的依赖关系进行静态分析，打包生成对应的静态资源(bundle)<br></p>
</blockquote>
<a id="more"></a>
<p><img src="/2020/07/18/Webpack/1.png" alt></p>
<h1 id="webpack五个核心概念"><a href="#webpack五个核心概念" class="headerlink" title="webpack五个核心概念"></a>webpack五个核心概念</h1><ol>
<li>Entry<ul>
<li>入口(Entry)指示webpack以哪个文件为入口起点开始打包，分析构建内部依赖图</li>
</ul>
</li>
<li>Output<ul>
<li>输出(Output)指示webpack打包后的资源bundles输出到哪里去，以及如何命名</li>
</ul>
</li>
<li>Loader<ul>
<li>Loader让webpack能够去处理那些非JavaScript文件(webpack自身只理解JavaScript)</li>
</ul>
</li>
<li>Plugins<ul>
<li>插件(Plugins)可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量等</li>
</ul>
</li>
<li>Mode<ul>
<li>模式(Mode)指示webpack使用相应模式的配置<br><img src="/2020/07/18/Webpack/mode.png" alt></li>
</ul>
</li>
</ol>
<h1 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h1><h2 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h2><ol>
<li>初始化package.json<ul>
<li>输入指令:npminit</li>
</ul>
</li>
</ol>
<p>2.下载并安装webpack</p>
<ul>
<li>输入指令：<ul>
<li>npm install webpack webpack-cli -g //全局安装</li>
<li>npm install webpack webpack-cli -D </li>
</ul>
</li>
</ul>
<h2 id="编译打包应用"><a href="#编译打包应用" class="headerlink" title="编译打包应用"></a>编译打包应用</h2><ul>
<li>开发环境：webpack ./src/index.js -o ./build/built.js –mode=development<ul>
<li>webpack会以 ./src/index.js 为入口文件开始打包，打包后输出到 ./build/built.js 整体打包环境是开发环境</li>
<li>功能：webpack能够编译打包js和json文件，并且能将es6的模块化语法转换成浏览器能识别的语法</li>
</ul>
</li>
<li>生产环境：webpack ./src/index.js -o ./build/built.js –mode=production<ul>
<li>webpack会以 ./src/index.js 为入口文件开始打包，打包后输出到 ./build/built.js，整体打包环境是生产环境</li>
<li>功能：在开发配置功能上多一个功能，压缩代码</li>
</ul>
</li>
</ul>
<h1 id="webpack开发环境配置"><a href="#webpack开发环境配置" class="headerlink" title="webpack开发环境配置"></a>webpack开发环境配置</h1><h2 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h2><ul>
<li>webpack.config.js  <ul>
<li>webpack的配置文件</li>
<li>作用: 指示 webpack 干哪些活（当你运行 webpack 指令时，会加载里面的配置）</li>
<li>所有构建工具都是基于nodejs平台运行的~模块化默认采用commonjs<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; resolve用来拼接绝对路径的方法</span><br><span class="line">const &#123; resolve &#125; &#x3D; require(&#39;path&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">&#x2F;&#x2F; webpack配置</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 入口起点</span><br><span class="line">entry: &#39;.&#x2F;src&#x2F;index.js&#39;,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出</span><br><span class="line">output: &#123;</span><br><span class="line">    &#x2F;&#x2F; 输出文件名</span><br><span class="line">    filename: &#39;built.js&#39;,</span><br><span class="line">    &#x2F;&#x2F; 输出路径</span><br><span class="line">    &#x2F;&#x2F; __dirname nodejs的变量，代表当前文件的目录绝对路径</span><br><span class="line">    path: resolve(__dirname, &#39;build&#39;)</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; loader的配置</span><br><span class="line">module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">    &#x2F;&#x2F; 详细loader配置</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 举例</span><br><span class="line">    &#x2F;&#x2F; 不同文件必须配置不同loader处理</span><br><span class="line">  &#123;</span><br><span class="line">    &#x2F;&#x2F; 匹配.css后缀的文件</span><br><span class="line">    test: &#x2F;\.css$&#x2F;,</span><br><span class="line">    &#x2F;&#x2F; 使用哪些loader进行处理</span><br><span class="line">    use: [</span><br><span class="line">      &#x2F;&#x2F; use数组中loader执行顺序：从右到左，从下到上 依次执行</span><br><span class="line">      &#x2F;&#x2F; 创建style标签，将js中的样式资源插入进行，添加到head中生效</span><br><span class="line">      &#39;style-loader&#39;,</span><br><span class="line">      &#x2F;&#x2F; 将css文件变成commonjs模块加载js中，里面内容是样式字符串</span><br><span class="line">      &#39;css-loader&#39;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &#x2F;&#x2F; 匹配.less后缀的文件  </span><br><span class="line">    test: &#x2F;\.less$&#x2F;,</span><br><span class="line">    use: [</span><br><span class="line">      &#39;style-loader&#39;,</span><br><span class="line">      &#39;css-loader&#39;,</span><br><span class="line">      &#x2F;&#x2F; 将less文件编译成css文件</span><br><span class="line">      &#x2F;&#x2F; 需要下载 less-loader和less</span><br><span class="line">      &#39;less-loader&#39;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; plugins的配置</span><br><span class="line">plugins: [</span><br><span class="line">    &#x2F;&#x2F; 详细plugins的配置</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 模式</span><br><span class="line">mode: &#39;development&#39;, &#x2F;&#x2F; 开发模式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>运行指令：webpack</li>
</ul>
<h2 id="打包HTML资源"><a href="#打包HTML资源" class="headerlink" title="打包HTML资源"></a>打包HTML资源</h2><ol>
<li>下载安装plugin包<ul>
<li>npm install –save-dev html -webpack-plugin</li>
</ul>
</li>
<li>修改配置文件 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; resolve &#125; &#x3D; require(&#39;path&#39;);</span><br><span class="line">const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">entry: &#39;.&#x2F;src&#x2F;index.js&#39;,</span><br><span class="line">output: &#123;</span><br><span class="line">    filename: &#39;built.js&#39;,</span><br><span class="line">    path: resolve(__dirname, &#39;build&#39;)</span><br><span class="line">&#125;,</span><br><span class="line">module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">    &#x2F;&#x2F; loader的配置</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line">    &#x2F;&#x2F; plugins的配置</span><br><span class="line">    &#x2F;&#x2F; html-webpack-plugin</span><br><span class="line">    &#x2F;&#x2F; 功能：默认会创建一个空的HTML，自动引入打包输出的所有资源（JS&#x2F;CSS）</span><br><span class="line">    &#x2F;&#x2F; 需求：需要有结构的HTML文件</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">    &#x2F;&#x2F; 复制 &#39;.&#x2F;src&#x2F;index.html&#39; 文件，并自动引入打包输出的所有资源（JS&#x2F;CSS）</span><br><span class="line">    template: &#39;.&#x2F;src&#x2F;index.html&#39;</span><br><span class="line">    &#125;)</span><br><span class="line">],</span><br><span class="line">mode: &#39;development&#39;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>运行指令：webpack</li>
</ol>
<h2 id="打包图片资源"><a href="#打包图片资源" class="headerlink" title="打包图片资源"></a>打包图片资源</h2><ol>
<li>下载安装loader包<ul>
<li>npm install –save-dev html-loader url-loader file-loader</li>
</ul>
</li>
<li>修改配置文件 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; resolve &#125; &#x3D; require(&#39;path&#39;);</span><br><span class="line">const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">entry: &#39;.&#x2F;src&#x2F;index.js&#39;,</span><br><span class="line">output: &#123;</span><br><span class="line">    filename: &#39;built.js&#39;,</span><br><span class="line">    path: resolve(__dirname, &#39;build&#39;)</span><br><span class="line">&#125;,</span><br><span class="line">module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">    &#123;</span><br><span class="line">        test: &#x2F;\.less$&#x2F;,</span><br><span class="line">        &#x2F;&#x2F; 要使用多个loader处理用use</span><br><span class="line">        use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;less-loader&#39;]</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 问题：默认处理不了html中img图片</span><br><span class="line">        &#x2F;&#x2F; 处理图片资源</span><br><span class="line">        test: &#x2F;\.(jpg|png|gif)$&#x2F;,</span><br><span class="line">        &#x2F;&#x2F; 使用一个loader</span><br><span class="line">        &#x2F;&#x2F; 下载 url-loader file-loader</span><br><span class="line"></span><br><span class="line">        loader: &#39;url-loader&#39;,</span><br><span class="line">        options: &#123;</span><br><span class="line">        limit: 8 * 1024,</span><br><span class="line">        &#x2F;&#x2F; 图片小于8kb，就会被base64处理</span><br><span class="line">        &#x2F;&#x2F; 优点: 减少请求数量（减轻服务器压力）</span><br><span class="line">        &#x2F;&#x2F; 缺点：图片体积会更大（文件请求速度更慢）</span><br><span class="line">        &#x2F;&#x2F; base64在本地解码，所以会减少服务器压力，如果图片过大还继续采用base64编码会导致cpu调用率上升，网页加载时变卡</span><br><span class="line">       </span><br><span class="line">        &#x2F;&#x2F; 问题：因为url-loader默认使用es6模块化解析，而html-loader引入图片是commonjs</span><br><span class="line">        &#x2F;&#x2F; 解析时会出问题：[object Module]</span><br><span class="line">        &#x2F;&#x2F; 解决：关闭url-loader的es6模块化，使用commonjs解析</span><br><span class="line">        esModule: false,</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 给图片进行重命名</span><br><span class="line">        &#x2F;&#x2F; [hash:10]取图片的hash的前10位</span><br><span class="line">        &#x2F;&#x2F; [ext]取文件原来扩展名</span><br><span class="line">        name: &#39;[hash:10].[ext]&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        test: &#x2F;\.html$&#x2F;,</span><br><span class="line">        &#x2F;&#x2F; 处理html文件的img图片（负责引入img，从而能被url-loader进行处理）</span><br><span class="line">        loader: &#39;html-loader&#39;</span><br><span class="line">    &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">    template: &#39;.&#x2F;src&#x2F;index.html&#39;</span><br><span class="line">    &#125;)</span><br><span class="line">],</span><br><span class="line">mode: &#39;development&#39;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>运行指令：webpack</li>
</ol>
<h2 id="打包其他资源"><a href="#打包其他资源" class="headerlink" title="打包其他资源"></a>打包其他资源</h2><ol>
<li>修改配置文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; resolve &#125; &#x3D; require(&#39;path&#39;);</span><br><span class="line">const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  entry: &#39;.&#x2F;src&#x2F;index.js&#39;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#39;built.js&#39;,</span><br><span class="line">    path: resolve(__dirname, &#39;build&#39;)</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: &#x2F;\.css$&#x2F;,</span><br><span class="line">        use: [&#39;style-loader&#39;, &#39;css-loader&#39;]</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 打包其他资源(除了html&#x2F;js&#x2F;css资源以外的资源)</span><br><span class="line">      &#123;</span><br><span class="line">        &#x2F;&#x2F; 排除css&#x2F;js&#x2F;html资源，剩下的资源用file loader进行处理</span><br><span class="line">        exclude: &#x2F;\.(css|js|html|less)$&#x2F;,</span><br><span class="line">        loader: &#39;file-loader&#39;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          name: &#39;[hash:10].[ext]&#39;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: &#39;.&#x2F;src&#x2F;index.html&#39;</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  mode: &#39;development&#39;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>运行指令：webpack</li>
</ol>
<h2 id="devserver"><a href="#devserver" class="headerlink" title="devserver"></a>devserver</h2><ul>
<li>开发服务器 devServer：用来自动化（自动编译，自动打开浏览器，自动刷新浏览器~~）</li>
<li>特点：只会在内存中编译打包，不会有任何输出</li>
<li>下载：npm install webpack-dev-server -D //本地下载</li>
<li>启动devServer指令为：npx webpack-dev-server</li>
</ul>
<ol>
<li>修改配置文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; resolve &#125; &#x3D; require(&#39;path&#39;);</span><br><span class="line">const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  entry: &#39;.&#x2F;src&#x2F;index.js&#39;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#39;built.js&#39;,</span><br><span class="line">    path: resolve(__dirname, &#39;build&#39;)</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: &#x2F;\.css$&#x2F;,</span><br><span class="line">        use: [&#39;style-loader&#39;, &#39;css-loader&#39;]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#x2F;&#x2F; 打包其他资源(除了html&#x2F;js&#x2F;css资源以外的资源)</span><br><span class="line">      &#123;</span><br><span class="line">        &#x2F;&#x2F; 排除css&#x2F;js&#x2F;html资源</span><br><span class="line">        exclude: &#x2F;\.(css|js|html|less)$&#x2F;,</span><br><span class="line">        loader: &#39;file-loader&#39;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          name: &#39;[hash:10].[ext]&#39;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: &#39;.&#x2F;src&#x2F;index.html&#39;</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  mode: &#39;development&#39;,</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">  devServer: &#123;</span><br><span class="line">    &#x2F;&#x2F; 项目构建后路径</span><br><span class="line">    contentBase: resolve(__dirname, &#39;build&#39;),</span><br><span class="line">    &#x2F;&#x2F; 启动gzip压缩</span><br><span class="line">    compress: true,</span><br><span class="line">    &#x2F;&#x2F; 端口号</span><br><span class="line">    port: 3000,</span><br><span class="line">    &#x2F;&#x2F; 自动打开浏览器</span><br><span class="line">    open: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>运行指令:npx webpack-dev-server</li>
</ol>
<h2 id="开发环境配置"><a href="#开发环境配置" class="headerlink" title="开发环境配置"></a>开发环境配置</h2><ul>
<li>配置文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">  开发环境配置：能让代码运行</span><br><span class="line">    运行项目指令：</span><br><span class="line">      webpack 会将打包结果输出出去</span><br><span class="line">      npx webpack-dev-server 只会在内存中编译打包，没有输出</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">const &#123; resolve &#125; &#x3D; require(&#39;path&#39;);</span><br><span class="line">const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  entry: &#39;.&#x2F;src&#x2F;js&#x2F;index.js&#39;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#39;js&#x2F;built.js&#39;,</span><br><span class="line">    path: resolve(__dirname, &#39;build&#39;)</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#x2F;&#x2F; loader的配置</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line">        &#x2F;&#x2F; 处理less资源</span><br><span class="line">        test: &#x2F;\.less$&#x2F;,</span><br><span class="line">        use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;less-loader&#39;]</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line">        &#x2F;&#x2F; 处理css资源</span><br><span class="line">        test: &#x2F;\.css$&#x2F;,</span><br><span class="line">        use: [&#39;style-loader&#39;, &#39;css-loader&#39;]</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line">        &#x2F;&#x2F; 处理图片资源</span><br><span class="line">        test: &#x2F;\.(jpg|png|gif)$&#x2F;,</span><br><span class="line">        loader: &#39;url-loader&#39;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          limit: 8 * 1024,</span><br><span class="line">          name: &#39;[hash:10].[ext]&#39;,</span><br><span class="line">          &#x2F;&#x2F; 关闭es6模块化</span><br><span class="line">          esModule: false,</span><br><span class="line">          outputPath: &#39;imgs&#39;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line">        &#x2F;&#x2F; 处理html中img资源</span><br><span class="line">        test: &#x2F;\.html$&#x2F;,</span><br><span class="line">        loader: &#39;html-loader&#39;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line">        &#x2F;&#x2F; 处理其他资源</span><br><span class="line">        exclude: &#x2F;\.(html|js|css|less|jpg|png|gif)&#x2F;,</span><br><span class="line">        loader: &#39;file-loader&#39;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          name: &#39;[hash:10].[ext]&#39;,</span><br><span class="line">          outputPath: &#39;media&#39;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  plugins: [</span><br><span class="line">    &#x2F;&#x2F; plugins的配置</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: &#39;.&#x2F;src&#x2F;index.html&#39;</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  mode: &#39;development&#39;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: resolve(__dirname, &#39;build&#39;),</span><br><span class="line">    compress: true,</span><br><span class="line">    port: 3000,</span><br><span class="line">    open: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="webpack生产环境配置"><a href="#webpack生产环境配置" class="headerlink" title="webpack生产环境配置"></a>webpack生产环境配置</h1><h2 id="提取js中的css成单独文件"><a href="#提取js中的css成单独文件" class="headerlink" title="提取js中的css成单独文件"></a>提取js中的css成单独文件</h2><ol>
<li>下载插件<ul>
<li>npm install –save-dev mini-css-extract-plugin</li>
</ul>
</li>
<li>修改配置文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; resolve &#125; &#x3D; require(&#39;path&#39;);</span><br><span class="line">const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);</span><br><span class="line">const MiniCssExtractPlugin &#x3D; require(&#39;mini-css-extract-plugin&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  entry: &#39;.&#x2F;src&#x2F;js&#x2F;index.js&#39;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#39;js&#x2F;built.js&#39;,</span><br><span class="line">    path: resolve(__dirname, &#39;build&#39;)</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: &#x2F;\.css$&#x2F;,</span><br><span class="line">        use: [</span><br><span class="line">          &#x2F;&#x2F; 创建style标签，将样式放入</span><br><span class="line">          &#x2F;&#x2F; &#39;style-loader&#39;, </span><br><span class="line">          &#x2F;&#x2F; 这个loader取代style-loader。作用：提取js中的css成单独文件</span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          &#x2F;&#x2F; 将css文件整合到js文件中</span><br><span class="line">          &#39;css-loader&#39;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: &#39;.&#x2F;src&#x2F;index.html&#39;</span><br><span class="line">    &#125;),</span><br><span class="line">    new MiniCssExtractPlugin(&#123;</span><br><span class="line">      &#x2F;&#x2F; 对输出的css文件进行重命名</span><br><span class="line">      filename: &#39;css&#x2F;built.css&#39;</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  mode: &#39;development&#39;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>运行指令：webpack</li>
</ol>
<h2 id="css兼容性处理"><a href="#css兼容性处理" class="headerlink" title="css兼容性处理"></a>css兼容性处理</h2><ol>
<li>下载loader<ul>
<li>npm install –save-dev postcss-loader postcss-preset-env</li>
</ul>
</li>
<li>修改配置文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; resolve &#125; &#x3D; require(&#39;path&#39;);</span><br><span class="line">const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);</span><br><span class="line">const MiniCssExtractPlugin &#x3D; require(&#39;mini-css-extract-plugin&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置nodejs环境变量</span><br><span class="line">&#x2F;&#x2F; process.env.NODE_ENV &#x3D; &#39;development&#39;;</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  entry: &#39;.&#x2F;src&#x2F;js&#x2F;index.js&#39;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#39;js&#x2F;built.js&#39;,</span><br><span class="line">    path: resolve(__dirname, &#39;build&#39;)</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: &#x2F;\.css$&#x2F;,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          &#39;css-loader&#39;,</span><br><span class="line"></span><br><span class="line">          &#x2F;*</span><br><span class="line">            css兼容性处理：postcss --&gt; postcss-loader postcss-preset-env</span><br><span class="line"></span><br><span class="line">            帮postcss找到package.json中browserslist里面的配置，通过配置加载指定的css兼容性样式</span><br><span class="line"></span><br><span class="line">            在package.json中添加：</span><br><span class="line">            &quot;browserslist&quot;: &#123;</span><br><span class="line">              &#x2F;&#x2F; 转换到开发环境 --&gt; 设置node环境变量：process.env.NODE_ENV &#x3D; development</span><br><span class="line">              &quot;development&quot;: [</span><br><span class="line">                &quot;last 1 chrome version&quot;,</span><br><span class="line">                &quot;last 1 firefox version&quot;,</span><br><span class="line">                &quot;last 1 safari version&quot;</span><br><span class="line">              ],</span><br><span class="line">              &#x2F;&#x2F; 生产环境：默认是看生产环境</span><br><span class="line">              &quot;production&quot;: [</span><br><span class="line">                &quot;&gt;0.2%&quot;,  兼容大于99.8%的浏览器</span><br><span class="line">                &quot;not dead&quot;, 不用已经消失的浏览器</span><br><span class="line">                &quot;not op_mini all&quot; 不用op_mini浏览器</span><br><span class="line">              ]</span><br><span class="line">            &#125;</span><br><span class="line">          *&#x2F;</span><br><span class="line"></span><br><span class="line">          &#x2F;&#x2F; 使用loader的默认配置</span><br><span class="line">          &#x2F;&#x2F; &#39;postcss-loader&#39;,</span><br><span class="line">          &#x2F;&#x2F; 修改loader的配置</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &#39;postcss-loader&#39;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              ident: &#39;postcss&#39;,</span><br><span class="line">              plugins: () &#x3D;&gt; [</span><br><span class="line">                &#x2F;&#x2F; postcss的插件</span><br><span class="line">                require(&#39;postcss-preset-env&#39;)()</span><br><span class="line">              ]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: &#39;.&#x2F;src&#x2F;index.html&#39;</span><br><span class="line">    &#125;),</span><br><span class="line">    new MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: &#39;css&#x2F;built.css&#39;</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  mode: &#39;development&#39;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>修改package.json<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在package.json中添加：</span><br><span class="line">&quot;browserslist&quot;: &#123;</span><br><span class="line">    &#x2F;&#x2F; 转换到开发环境 --&gt; 设置node环境变量：process.env.NODE_ENV &#x3D; development</span><br><span class="line">    &quot;development&quot;: [</span><br><span class="line">    &quot;last 1 chrome version&quot;,</span><br><span class="line">    &quot;last 1 firefox version&quot;,</span><br><span class="line">    &quot;last 1 safari version&quot;</span><br><span class="line">    ],</span><br><span class="line">    &#x2F;&#x2F; 生产环境：默认是看生产环境</span><br><span class="line">    &quot;production&quot;: [</span><br><span class="line">    &quot;&gt;0.2%&quot;,  兼容大于99.8%的浏览器</span><br><span class="line">    &quot;not dead&quot;, 不用已经消失的浏览器</span><br><span class="line">    &quot;not op_mini all&quot; 不用op_mini浏览器</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>运行指令：webpack</li>
</ol>
<h2 id="压缩css"><a href="#压缩css" class="headerlink" title="压缩css"></a>压缩css</h2><ol>
<li>下载安装包<ul>
<li>npm install –save-dev optimize-css-assets-webpack-plugin</li>
</ul>
</li>
<li>修改配置文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; resolve &#125; &#x3D; require(&#39;path&#39;);</span><br><span class="line">const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);</span><br><span class="line">const MiniCssExtractPlugin &#x3D; require(&#39;mini-css-extract-plugin&#39;);</span><br><span class="line">const OptimizeCssAssetsWebpackPlugin &#x3D; require(&#39;optimize-css-assets-webpack-plugin&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置nodejs环境变量</span><br><span class="line">&#x2F;&#x2F; process.env.NODE_ENV &#x3D; &#39;development&#39;;</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  entry: &#39;.&#x2F;src&#x2F;js&#x2F;index.js&#39;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#39;js&#x2F;built.js&#39;,</span><br><span class="line">    path: resolve(__dirname, &#39;build&#39;)</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: &#x2F;\.css$&#x2F;,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          &#39;css-loader&#39;,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &#39;postcss-loader&#39;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              ident: &#39;postcss&#39;,</span><br><span class="line">              plugins: () &#x3D;&gt; [</span><br><span class="line">                &#x2F;&#x2F; postcss的插件</span><br><span class="line">                require(&#39;postcss-preset-env&#39;)()</span><br><span class="line">              ]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: &#39;.&#x2F;src&#x2F;index.html&#39;</span><br><span class="line">    &#125;),</span><br><span class="line">    new MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: &#39;css&#x2F;built.css&#39;</span><br><span class="line">    &#125;),</span><br><span class="line">    &#x2F;&#x2F; 压缩css</span><br><span class="line">    new OptimizeCssAssetsWebpackPlugin()</span><br><span class="line">  ],</span><br><span class="line">  mode: &#39;development&#39;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>运行指令：webpack</li>
</ol>
<h2 id="js语法检查"><a href="#js语法检查" class="headerlink" title="js语法检查"></a>js语法检查</h2><ol>
<li>下载安装包<ul>
<li>npm install –save-dev eslint-loader eslint  eslint-config-airbnb-base eslint-plugin-import</li>
</ul>
</li>
<li>修改配置文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; resolve &#125; &#x3D; require(&#39;path&#39;);</span><br><span class="line">const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  entry: &#39;.&#x2F;src&#x2F;js&#x2F;index.js&#39;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#39;js&#x2F;built.js&#39;,</span><br><span class="line">    path: resolve(__dirname, &#39;build&#39;)</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#x2F;*</span><br><span class="line">        语法检查： eslint-loader  eslint</span><br><span class="line">          注意：只检查自己写的源代码，第三方的库是不用检查的</span><br><span class="line">          设置检查规则：</span><br><span class="line">            package.json中eslintConfig中设置~</span><br><span class="line">              &quot;eslintConfig&quot;: &#123;</span><br><span class="line">                &quot;extends&quot;: &quot;airbnb-base&quot;</span><br><span class="line">              &#125;</span><br><span class="line">            airbnb --&gt; eslint-config-airbnb-base  eslint-plugin-import eslint</span><br><span class="line">      *&#x2F;</span><br><span class="line">      &#123;</span><br><span class="line">        test: &#x2F;\.js$&#x2F;,</span><br><span class="line">        exclude: &#x2F;node_modules&#x2F;, &#x2F;&#x2F;排除node_modules</span><br><span class="line">        loader: &#39;eslint-loader&#39;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          &#x2F;&#x2F; 自动修复eslint的错误</span><br><span class="line">          fix: true</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: &#39;.&#x2F;src&#x2F;index.html&#39;</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  mode: &#39;development&#39;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>修改package.json<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设置检查规则：</span><br><span class="line">&#x2F;&#x2F;package.json中eslintConfig中设置~</span><br><span class="line">    &quot;eslintConfig&quot;: &#123;</span><br><span class="line">    &quot;extends&quot;: &quot;airbnb-base&quot;,&#x2F;&#x2F;使用airbnb-base的代码风格</span><br><span class="line">    &quot;env&quot;: &#123;</span><br><span class="line">      &quot;browser&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="js兼容性处理"><a href="#js兼容性处理" class="headerlink" title="js兼容性处理"></a>js兼容性处理</h2><ol>
<li>下载安装包<ul>
<li>npm install –save-dev babel-loader @babel/core @babel/preset-env @babel/polyfill core-js</li>
</ul>
</li>
<li>修改配置文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; resolve &#125; &#x3D; require(&#39;path&#39;);</span><br><span class="line">const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  entry: &#39;.&#x2F;src&#x2F;js&#x2F;index.js&#39;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#39;js&#x2F;built.js&#39;,</span><br><span class="line">    path: resolve(__dirname, &#39;build&#39;)</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#x2F;*</span><br><span class="line">        js兼容性处理：babel-loader @babel&#x2F;core </span><br><span class="line">          1. 基本js兼容性处理 --&gt; @babel&#x2F;preset-env</span><br><span class="line">            问题：只能转换基本语法，如promise高级语法不能转换</span><br><span class="line">          2. 全部js兼容性处理 --&gt; @babel&#x2F;polyfill  </span><br><span class="line">            问题：我只要解决部分兼容性问题，但是将所有兼容性代码全部引入，体积太大了~</span><br><span class="line">          3. 需要做兼容性处理的就做：按需加载  --&gt; core-js</span><br><span class="line">      *&#x2F;  </span><br><span class="line">      &#123;</span><br><span class="line">        test: &#x2F;\.js$&#x2F;,</span><br><span class="line">        exclude: &#x2F;node_modules&#x2F;,</span><br><span class="line">        loader: &#39;babel-loader&#39;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          &#x2F;&#x2F; 预设：指示babel做怎么样的兼容性处理</span><br><span class="line">          presets: [</span><br><span class="line">            [</span><br><span class="line">              &#39;@babel&#x2F;preset-env&#39;,</span><br><span class="line">              &#123;</span><br><span class="line">                &#x2F;&#x2F; 按需加载</span><br><span class="line">                useBuiltIns: &#39;usage&#39;,</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 指定core-js版本</span><br><span class="line">                corejs: &#123;</span><br><span class="line">                  version: 3</span><br><span class="line">                &#125;,</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 指定兼容性做到哪个版本浏览器</span><br><span class="line">                targets: &#123;</span><br><span class="line">                  chrome: &#39;60&#39;,</span><br><span class="line">                  firefox: &#39;60&#39;,</span><br><span class="line">                  ie: &#39;9&#39;,</span><br><span class="line">                  safari: &#39;10&#39;,</span><br><span class="line">                  edge: &#39;17&#39;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: &#39;.&#x2F;src&#x2F;index.html&#39;</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  mode: &#39;development&#39;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>运行指令：webpack</li>
</ol>
<h2 id="js压缩"><a href="#js压缩" class="headerlink" title="js压缩"></a>js压缩</h2><ol>
<li>修改配置文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; resolve &#125; &#x3D; require(&#39;path&#39;);</span><br><span class="line">const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  entry: &#39;.&#x2F;src&#x2F;js&#x2F;index.js&#39;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#39;js&#x2F;built.js&#39;,</span><br><span class="line">    path: resolve(__dirname, &#39;build&#39;)</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: &#39;.&#x2F;src&#x2F;index.html&#39;</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  &#x2F;&#x2F; 生产环境下会自动压缩js代码</span><br><span class="line">  mode: &#39;production&#39;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>运行指令：webpack</li>
</ol>
<h2 id="html压缩"><a href="#html压缩" class="headerlink" title="html压缩"></a>html压缩</h2><ol>
<li>修改配置文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; resolve &#125; &#x3D; require(&#39;path&#39;);</span><br><span class="line">const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  entry: &#39;.&#x2F;src&#x2F;js&#x2F;index.js&#39;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#39;js&#x2F;built.js&#39;,</span><br><span class="line">    path: resolve(__dirname, &#39;build&#39;)</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: &#39;.&#x2F;src&#x2F;index.html&#39;,</span><br><span class="line">      &#x2F;&#x2F; 压缩html代码</span><br><span class="line">      minify: &#123;</span><br><span class="line">        &#x2F;&#x2F; 移除空格</span><br><span class="line">        collapseWhitespace: true,</span><br><span class="line">        &#x2F;&#x2F; 移除注释</span><br><span class="line">        removeComments: true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  mode: &#39;production&#39;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>运行指令：webpack</li>
</ol>
<h2 id="生产环境配置"><a href="#生产环境配置" class="headerlink" title="生产环境配置"></a>生产环境配置</h2><ol>
<li>修改配置文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; resolve &#125; &#x3D; require(&#39;path&#39;);</span><br><span class="line">const MiniCssExtractPlugin &#x3D; require(&#39;mini-css-extract-plugin&#39;);</span><br><span class="line">const OptimizeCssAssetsWebpackPlugin &#x3D; require(&#39;optimize-css-assets-webpack-plugin&#39;);</span><br><span class="line">const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义nodejs环境变量：决定使用browserslist的哪个环境</span><br><span class="line">process.env.NODE_ENV &#x3D; &#39;production&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 复用loader</span><br><span class="line">const commonCssLoader &#x3D; [</span><br><span class="line">  MiniCssExtractPlugin.loader,</span><br><span class="line">  &#39;css-loader&#39;,</span><br><span class="line">  &#123;</span><br><span class="line">    &#x2F;&#x2F; 还需要在package.json中定义browserslist</span><br><span class="line">    loader: &#39;postcss-loader&#39;,</span><br><span class="line">    options: &#123;</span><br><span class="line">      ident: &#39;postcss&#39;,</span><br><span class="line">      plugins: () &#x3D;&gt; [require(&#39;postcss-preset-env&#39;)()]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  entry: &#39;.&#x2F;src&#x2F;js&#x2F;index.js&#39;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#39;js&#x2F;built.js&#39;,</span><br><span class="line">    path: resolve(__dirname, &#39;build&#39;)</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: &#x2F;\.css$&#x2F;,</span><br><span class="line">        use: [...commonCssLoader]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: &#x2F;\.less$&#x2F;,</span><br><span class="line">        use: [...commonCssLoader, &#39;less-loader&#39;]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#x2F;*</span><br><span class="line">        正常来讲，一个文件只能被一个loader处理。</span><br><span class="line">        当一个文件要被多个loader处理，那么一定要指定loader执行的先后顺序：</span><br><span class="line">          先执行eslint 在执行babel</span><br><span class="line">      *&#x2F;</span><br><span class="line">      &#123;</span><br><span class="line">        &#x2F;&#x2F; 在package.json中eslintConfig --&gt; airbnb</span><br><span class="line">        test: &#x2F;\.js$&#x2F;,</span><br><span class="line">        exclude: &#x2F;node_modules&#x2F;,</span><br><span class="line">        &#x2F;&#x2F; 优先执行</span><br><span class="line">        enforce: &#39;pre&#39;,</span><br><span class="line">        loader: &#39;eslint-loader&#39;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          fix: true</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: &#x2F;\.js$&#x2F;,</span><br><span class="line">        exclude: &#x2F;node_modules&#x2F;,</span><br><span class="line">        loader: &#39;babel-loader&#39;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          presets: [</span><br><span class="line">            [</span><br><span class="line">              &#39;@babel&#x2F;preset-env&#39;,</span><br><span class="line">              &#123;</span><br><span class="line">                useBuiltIns: &#39;usage&#39;,</span><br><span class="line">                corejs: &#123;version: 3&#125;,</span><br><span class="line">                targets: &#123;</span><br><span class="line">                  chrome: &#39;60&#39;,</span><br><span class="line">                  firefox: &#39;50&#39;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: &#x2F;\.(jpg|png|gif)&#x2F;,</span><br><span class="line">        loader: &#39;url-loader&#39;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          limit: 8 * 1024,</span><br><span class="line">          name: &#39;[hash:10].[ext]&#39;,</span><br><span class="line">          outputPath: &#39;imgs&#39;,</span><br><span class="line">          esModule: false</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: &#x2F;\.html$&#x2F;,</span><br><span class="line">        loader: &#39;html-loader&#39;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        exclude: &#x2F;\.(js|css|less|html|jpg|png|gif)&#x2F;,</span><br><span class="line">        loader: &#39;file-loader&#39;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          outputPath: &#39;media&#39;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: &#39;css&#x2F;built.css&#39;</span><br><span class="line">    &#125;),</span><br><span class="line">    new OptimizeCssAssetsWebpackPlugin(),</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: &#39;.&#x2F;src&#x2F;index.html&#39;,</span><br><span class="line">      minify: &#123;</span><br><span class="line">          &#x2F;&#x2F;移除空格和注释</span><br><span class="line">        collapseWhitespace: true,</span><br><span class="line">        removeComments: true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  mode: &#39;production&#39;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>运行指令：webpack</li>
</ol>
<h1 id="webpack优化环境配置"><a href="#webpack优化环境配置" class="headerlink" title="webpack优化环境配置"></a>webpack优化环境配置</h1><ol>
<li><p>开发环境性能优化</p>
<ul>
<li>优化打包构建速度<ul>
<li>HMR</li>
</ul>
</li>
<li>优化代码调试<ul>
<li>source-map</li>
</ul>
</li>
</ul>
</li>
<li><p>生产环境性能优化</p>
<ul>
<li>优化打包构建速度<ul>
<li>oneOf</li>
<li>babel缓存</li>
<li>多进程打包</li>
<li>externals</li>
<li>dll</li>
</ul>
</li>
<li>优化代码运行的性能<ul>
<li>缓存(hash-chunkhash-contenthash)</li>
<li>tree shaking</li>
<li>code split</li>
<li>懒加载/预加载</li>
<li>pwa</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="HMR"><a href="#HMR" class="headerlink" title="HMR"></a>HMR</h2><ul>
<li><p>HMR: hot module replacement 热模块替换 / 模块热替换</p>
<ul>
<li>作用：一个模块发生变化，只会重新打包这一个模块（而不是打包所有模块） 极大提升构建速度</li>
</ul>
</li>
<li><p>css文件：可以使用HMR功能：因为style-loader内部实现了~</p>
</li>
<li><p>js文件：默认不能使用HMR功能 –&gt; 需要修改js代码，添加支持HMR功能的代码</p>
<ul>
<li>注意：HMR功能对js的处理，只能处理非入口js文件的其他文件</li>
</ul>
</li>
<li><p>html文件: 默认不能使用HMR功能.同时会导致问题：html文件不能热更新了（不用做HMR功能）</p>
<ul>
<li>解决：修改entry入口，将html文件引入</li>
</ul>
</li>
</ul>
<ol>
<li>修改配置文件 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; resolve &#125; &#x3D; require(&#39;path&#39;);</span><br><span class="line">const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  entry: [&#39;.&#x2F;src&#x2F;js&#x2F;index.js&#39;, &#39;.&#x2F;src&#x2F;index.html&#39;],</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#39;js&#x2F;built.js&#39;,</span><br><span class="line">    path: resolve(__dirname, &#39;build&#39;)</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#x2F;&#x2F; loader的配置</span><br><span class="line">      &#123;</span><br><span class="line">        &#x2F;&#x2F; 处理less资源</span><br><span class="line">        test: &#x2F;\.less$&#x2F;,</span><br><span class="line">        use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;less-loader&#39;]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &#x2F;&#x2F; 处理css资源</span><br><span class="line">        test: &#x2F;\.css$&#x2F;,</span><br><span class="line">        use: [&#39;style-loader&#39;, &#39;css-loader&#39;]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &#x2F;&#x2F; 处理图片资源</span><br><span class="line">        test: &#x2F;\.(jpg|png|gif)$&#x2F;,</span><br><span class="line">        loader: &#39;url-loader&#39;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          limit: 8 * 1024,</span><br><span class="line">          name: &#39;[hash:10].[ext]&#39;,</span><br><span class="line">          &#x2F;&#x2F; 关闭es6模块化</span><br><span class="line">          esModule: false,</span><br><span class="line">          outputPath: &#39;imgs&#39;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &#x2F;&#x2F; 处理html中img资源</span><br><span class="line">        test: &#x2F;\.html$&#x2F;,</span><br><span class="line">        loader: &#39;html-loader&#39;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &#x2F;&#x2F; 处理其他资源</span><br><span class="line">        exclude: &#x2F;\.(html|js|css|less|jpg|png|gif)&#x2F;,</span><br><span class="line">        loader: &#39;file-loader&#39;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          name: &#39;[hash:10].[ext]&#39;,</span><br><span class="line">          outputPath: &#39;media&#39;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    &#x2F;&#x2F; plugins的配置</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: &#39;.&#x2F;src&#x2F;index.html&#39;</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  mode: &#39;development&#39;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: resolve(__dirname, &#39;build&#39;),</span><br><span class="line">    compress: true,</span><br><span class="line">    port: 3000,</span><br><span class="line">    open: true,</span><br><span class="line">    &#x2F;&#x2F; 开启HMR功能</span><br><span class="line">    &#x2F;&#x2F; 当修改了webpack配置，新配置要想生效，必须重新webpack服务</span><br><span class="line">    hot: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>js文件处理<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (module.hot) &#123;</span><br><span class="line">  &#x2F;&#x2F; 一旦 module.hot 为true，说明开启了HMR功能。 --&gt; 让HMR功能代码生效</span><br><span class="line">  module.hot.accept(&#39;.&#x2F;print.js&#39;, function() &#123;</span><br><span class="line">    &#x2F;&#x2F; 方法会监听 print.js 文件的变化，一旦发生变化，其他模块不会重新打包构建。</span><br><span class="line">    &#x2F;&#x2F; 会执行后面的回调函数</span><br><span class="line">    print();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>运行指令：webpack</li>
</ol>
<h2 id="source-map"><a href="#source-map" class="headerlink" title="source-map"></a>source-map</h2><ul>
<li><p>source-map: 一种 提供源代码到构建后代码映射 技术 （如果构建后代码出错了，通过映射可以追踪源代码错误）</p>
</li>
<li><p>内联 和 外部的区别：</p>
<ol>
<li>外部生成了文件，内联没有 </li>
<li>内联构建速度更快</li>
</ol>
</li>
<li><p>inline-|hidden-|eval-][nosources-][cheap-[module-]]source-map</p>
<ul>
<li>source-map：外部<ul>
<li>错误代码准确信息 和 源代码的错误位置</li>
</ul>
</li>
<li>inline-source-map：内联<ul>
<li>只生成一个内联source-map</li>
<li>错误代码准确信息 和 源代码的错误位置</li>
</ul>
</li>
<li>hidden-source-map：外部<ul>
<li>错误代码错误原因，但是没有错误位置</li>
<li>不能追踪源代码错误，只能提示到构建后代码的错误位置</li>
</ul>
</li>
<li>eval-source-map：内联<ul>
<li>每一个文件都生成对应的source-map，都在eval</li>
<li>错误代码准确信息 和 源代码的错误位置</li>
</ul>
</li>
<li>nosources-source-map：外部<ul>
<li>错误代码准确信息, 但是没有任何源代码信息</li>
</ul>
</li>
<li>cheap-source-map：外部<ul>
<li>错误代码准确信息 和 源代码的错误位置 </li>
<li>只能精确到行</li>
</ul>
</li>
<li>cheap-module-source-map：外部<ul>
<li>错误代码准确信息 和 源代码的错误位置 </li>
<li>module会将loader的source map加入</li>
</ul>
</li>
</ul>
</li>
<li><p>开发环境：速度快，调试更友好</p>
<ul>
<li>速度快(eval&gt;inline&gt;cheap&gt;…)<ul>
<li>eval-cheap-souce-map</li>
<li>eval-source-map</li>
</ul>
</li>
<li>调试更友好  <ul>
<li>souce-map</li>
<li>cheap-module-souce-map</li>
<li>cheap-souce-map</li>
</ul>
</li>
<li>平衡性好<ul>
<li>eval-source-map  / eval-cheap-module-souce-map</li>
</ul>
</li>
</ul>
</li>
<li><p>生产环境：源代码要不要隐藏? 调试要不要更友好</p>
<ul>
<li>内联会让代码体积变大，所以在生产环境不用内联</li>
<li>nosources-source-map 全部隐藏</li>
<li>hidden-source-map 只隐藏源代码，会提示构建后代码错误信息</li>
<li>平衡性<ul>
<li>source-map / cheap-module-souce-map</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li>配置文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; resolve &#125; &#x3D; require(&#39;path&#39;);</span><br><span class="line">const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  entry: [&#39;.&#x2F;src&#x2F;js&#x2F;index.js&#39;, &#39;.&#x2F;src&#x2F;index.html&#39;],</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#39;js&#x2F;built.js&#39;,</span><br><span class="line">    path: resolve(__dirname, &#39;build&#39;)</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#x2F;&#x2F; loader的配置</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    &#x2F;&#x2F; plugins的配置</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: &#39;.&#x2F;src&#x2F;index.html&#39;</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  mode: &#39;development&#39;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: resolve(__dirname, &#39;build&#39;),</span><br><span class="line">    compress: true,</span><br><span class="line">    port: 3000,</span><br><span class="line">    open: true,</span><br><span class="line">    hot: true</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; source -map 配置</span><br><span class="line">  devtool: &#39;eval-source-map&#39;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>运行指令：webpack</li>
</ol>
<h2 id="oneof"><a href="#oneof" class="headerlink" title="oneof"></a>oneof</h2><ul>
<li>提升构建速度，把所有的loader都放进oneof里就不会加载多次loader了</li>
</ul>
<ol>
<li>配置文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; resolve &#125; &#x3D; require(&#39;path&#39;);</span><br><span class="line">const MiniCssExtractPlugin &#x3D; require(&#39;mini-css-extract-plugin&#39;);</span><br><span class="line">const OptimizeCssAssetsWebpackPlugin &#x3D; require(&#39;optimize-css-assets-webpack-plugin&#39;);</span><br><span class="line">const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义nodejs环境变量：决定使用browserslist的哪个环境</span><br><span class="line">process.env.NODE_ENV &#x3D; &#39;production&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 复用loader</span><br><span class="line">const commonCssLoader &#x3D; [</span><br><span class="line">  MiniCssExtractPlugin.loader,</span><br><span class="line">  &#39;css-loader&#39;,</span><br><span class="line">  &#123;</span><br><span class="line">    &#x2F;&#x2F; 还需要在package.json中定义browserslist</span><br><span class="line">    loader: &#39;postcss-loader&#39;,</span><br><span class="line">    options: &#123;</span><br><span class="line">      ident: &#39;postcss&#39;,</span><br><span class="line">      plugins: () &#x3D;&gt; [require(&#39;postcss-preset-env&#39;)()]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  entry: &#39;.&#x2F;src&#x2F;js&#x2F;index.js&#39;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#39;js&#x2F;built.js&#39;,</span><br><span class="line">    path: resolve(__dirname, &#39;build&#39;)</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        &#x2F;&#x2F; 在package.json中eslintConfig --&gt; airbnb</span><br><span class="line">        test: &#x2F;\.js$&#x2F;,</span><br><span class="line">        exclude: &#x2F;node_modules&#x2F;,</span><br><span class="line">        &#x2F;&#x2F; 优先执行</span><br><span class="line">        enforce: &#39;pre&#39;,</span><br><span class="line">        loader: &#39;eslint-loader&#39;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          fix: true</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &#x2F;&#x2F; 以下loader只会匹配一个</span><br><span class="line">        &#x2F;&#x2F; 注意：不能有两个配置处理同一种类型文件,所以在js语法检查和兼容性问题时，需要将其中一个loader拿到oneof外面</span><br><span class="line">        oneOf: [</span><br><span class="line">          &#123;</span><br><span class="line">            test: &#x2F;\.css$&#x2F;,</span><br><span class="line">            use: [...commonCssLoader]</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            test: &#x2F;\.less$&#x2F;,</span><br><span class="line">            use: [...commonCssLoader, &#39;less-loader&#39;]</span><br><span class="line">          &#125;,</span><br><span class="line">          &#x2F;*</span><br><span class="line">            正常来讲，一个文件只能被一个loader处理。</span><br><span class="line">            当一个文件要被多个loader处理，那么一定要指定loader执行的先后顺序：</span><br><span class="line">              先执行eslint 在执行babel</span><br><span class="line">          *&#x2F;</span><br><span class="line">          &#123;</span><br><span class="line">            test: &#x2F;\.js$&#x2F;,</span><br><span class="line">            exclude: &#x2F;node_modules&#x2F;,</span><br><span class="line">            loader: &#39;babel-loader&#39;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              presets: [</span><br><span class="line">                [</span><br><span class="line">                  &#39;@babel&#x2F;preset-env&#39;,</span><br><span class="line">                  &#123;</span><br><span class="line">                    useBuiltIns: &#39;usage&#39;,</span><br><span class="line">                    corejs: &#123;version: 3&#125;,</span><br><span class="line">                    targets: &#123;</span><br><span class="line">                      chrome: &#39;60&#39;,</span><br><span class="line">                      firefox: &#39;50&#39;</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                ]</span><br><span class="line">              ]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            test: &#x2F;\.(jpg|png|gif)&#x2F;,</span><br><span class="line">            loader: &#39;url-loader&#39;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              limit: 8 * 1024,</span><br><span class="line">              name: &#39;[hash:10].[ext]&#39;,</span><br><span class="line">              outputPath: &#39;imgs&#39;,</span><br><span class="line">              esModule: false</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            test: &#x2F;\.html$&#x2F;,</span><br><span class="line">            loader: &#39;html-loader&#39;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            exclude: &#x2F;\.(js|css|less|html|jpg|png|gif)&#x2F;,</span><br><span class="line">            loader: &#39;file-loader&#39;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              outputPath: &#39;media&#39;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: &#39;css&#x2F;built.css&#39;</span><br><span class="line">    &#125;),</span><br><span class="line">    new OptimizeCssAssetsWebpackPlugin(),</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: &#39;.&#x2F;src&#x2F;index.html&#39;,</span><br><span class="line">      minify: &#123;</span><br><span class="line">        collapseWhitespace: true,</span><br><span class="line">        removeComments: true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  mode: &#39;production&#39;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2></li>
</ol>
<ul>
<li>babel缓存<ul>
<li>cacheDirectory: true</li>
<li>–&gt; 让第二次打包构建速度更快</li>
</ul>
</li>
<li>文件资源缓存<ul>
<li>hash: 每次wepack构建时会生成一个唯一的hash值。<ul>
<li>问题: 因为js和css同时使用一个hash值。<ul>
<li>如果重新打包，会导致所有缓存失效。（可能我却只改动一个文件）</li>
</ul>
</li>
</ul>
</li>
<li>chunkhash：根据chunk生成的hash值。如果打包来源于同一个chunk，那么hash值就一样<ul>
<li>问题: js和css的hash值还是一样的<ul>
<li>因为css是在js中被引入的，所以同属于一个chunk</li>
</ul>
</li>
</ul>
</li>
<li>contenthash: 根据文件的内容生成hash值。不同文件hash值一定不一样    </li>
<li>–&gt; 让代码上线运行缓存更好使用</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; resolve &#125; &#x3D; require(&#39;path&#39;);</span><br><span class="line">const MiniCssExtractPlugin &#x3D; require(&#39;mini-css-extract-plugin&#39;);</span><br><span class="line">const OptimizeCssAssetsWebpackPlugin &#x3D; require(&#39;optimize-css-assets-webpack-plugin&#39;);</span><br><span class="line">const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义nodejs环境变量：决定使用browserslist的哪个环境</span><br><span class="line">process.env.NODE_ENV &#x3D; &#39;production&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 复用loader</span><br><span class="line">const commonCssLoader &#x3D; [</span><br><span class="line">  MiniCssExtractPlugin.loader,</span><br><span class="line">  &#39;css-loader&#39;,</span><br><span class="line">  &#123;</span><br><span class="line">    &#x2F;&#x2F; 还需要在package.json中定义browserslist</span><br><span class="line">    loader: &#39;postcss-loader&#39;,</span><br><span class="line">    options: &#123;</span><br><span class="line">      ident: &#39;postcss&#39;,</span><br><span class="line">      plugins: () &#x3D;&gt; [require(&#39;postcss-preset-env&#39;)()]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  entry: &#39;.&#x2F;src&#x2F;js&#x2F;index.js&#39;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#39;js&#x2F;built.[contenthash:10].js&#39;,</span><br><span class="line">    path: resolve(__dirname, &#39;build&#39;)</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        &#x2F;&#x2F; 在package.json中eslintConfig --&gt; airbnb</span><br><span class="line">        test: &#x2F;\.js$&#x2F;,</span><br><span class="line">        exclude: &#x2F;node_modules&#x2F;,</span><br><span class="line">        &#x2F;&#x2F; 优先执行</span><br><span class="line">        enforce: &#39;pre&#39;,</span><br><span class="line">        loader: &#39;eslint-loader&#39;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          fix: true</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        oneOf: [</span><br><span class="line">          &#123;</span><br><span class="line">            test: &#x2F;\.css$&#x2F;,</span><br><span class="line">            use: [...commonCssLoader]</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            test: &#x2F;\.less$&#x2F;,</span><br><span class="line">            use: [...commonCssLoader, &#39;less-loader&#39;]</span><br><span class="line">          &#125;,</span><br><span class="line"></span><br><span class="line">          &#123;</span><br><span class="line">            test: &#x2F;\.js$&#x2F;,</span><br><span class="line">            exclude: &#x2F;node_modules&#x2F;,</span><br><span class="line">            loader: &#39;babel-loader&#39;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              presets: [</span><br><span class="line">                [</span><br><span class="line">                  &#39;@babel&#x2F;preset-env&#39;,</span><br><span class="line">                  &#123;</span><br><span class="line">                    useBuiltIns: &#39;usage&#39;,</span><br><span class="line">                    corejs: &#123; version: 3 &#125;,</span><br><span class="line">                    targets: &#123;</span><br><span class="line">                      chrome: &#39;60&#39;,</span><br><span class="line">                      firefox: &#39;50&#39;</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                ]</span><br><span class="line">              ],</span><br><span class="line">              &#x2F;&#x2F; 开启babel缓存</span><br><span class="line">              &#x2F;&#x2F; 第二次构建时，会读取之前的缓存</span><br><span class="line">              cacheDirectory: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            test: &#x2F;\.(jpg|png|gif)&#x2F;,</span><br><span class="line">            loader: &#39;url-loader&#39;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              limit: 8 * 1024,</span><br><span class="line">              name: &#39;[hash:10].[ext]&#39;,</span><br><span class="line">              outputPath: &#39;imgs&#39;,</span><br><span class="line">              esModule: false</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            test: &#x2F;\.html$&#x2F;,</span><br><span class="line">            loader: &#39;html-loader&#39;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            exclude: &#x2F;\.(js|css|less|html|jpg|png|gif)&#x2F;,</span><br><span class="line">            loader: &#39;file-loader&#39;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              outputPath: &#39;media&#39;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: &#39;css&#x2F;built.[contenthash:10].css&#39;</span><br><span class="line">    &#125;),</span><br><span class="line">    new OptimizeCssAssetsWebpackPlugin(),</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: &#39;.&#x2F;src&#x2F;index.html&#39;,</span><br><span class="line">      minify: &#123;</span><br><span class="line">        collapseWhitespace: true,</span><br><span class="line">        removeComments: true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  mode: &#39;production&#39;,</span><br><span class="line">  devtool: &#39;source-map&#39;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree shaking"></a>tree shaking</h2><ul>
<li><p>tree shaking：去除无用代码</p>
<ul>
<li>前提：<ol>
<li>必须使用ES6模块化  </li>
<li>开启production环境</li>
</ol>
</li>
<li>作用: 减少代码体积</li>
</ul>
</li>
<li><p>在package.json中配置 </p>
<ul>
<li>“sideEffects”: false 所有代码都没有副作用（都可以进行tree shaking）</li>
<li>问题：可能会把css / @babel/polyfill （副作用）文件干掉<br>“sideEffects”: [“<em>.css”, “</em>.less”]</li>
</ul>
</li>
</ul>
<ol>
<li>配置package.json文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;sideEffects&quot;: [</span><br><span class="line">  &quot;*.css&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="code-split"><a href="#code-split" class="headerlink" title="code split"></a>code split</h2><ul>
<li>将一个大的js文件分割成几个小文件，这样就可以实现按需加载</li>
</ul>
<ol>
<li>配置文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; resolve &#125; &#x3D; require(&#39;path&#39;);</span><br><span class="line">const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F; 单入口</span><br><span class="line">  &#x2F;&#x2F; entry: &#39;.&#x2F;src&#x2F;js&#x2F;index.js&#39;,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: &#39;.&#x2F;src&#x2F;js&#x2F;index.js&#39;,</span><br><span class="line">    test: &#39;.&#x2F;src&#x2F;js&#x2F;test.js&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    &#x2F;&#x2F; [name]：取文件名</span><br><span class="line">    filename: &#39;js&#x2F;[name].[contenthash:10].js&#39;,</span><br><span class="line">    path: resolve(__dirname, &#39;build&#39;)</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: &#39;.&#x2F;src&#x2F;index.html&#39;,</span><br><span class="line">      minify: &#123;</span><br><span class="line">        collapseWhitespace: true,</span><br><span class="line">        removeComments: true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  &#x2F;*</span><br><span class="line">    1. 可以将node_modules中代码单独打包一个chunk最终输出</span><br><span class="line">    2. 自动分析多入口chunk中，有没有公共的文件。如果有会打包成单独一个chunk</span><br><span class="line">  *&#x2F;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      chunks: &#39;all&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mode: &#39;production&#39;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="懒加载和预加载"><a href="#懒加载和预加载" class="headerlink" title="懒加载和预加载"></a>懒加载和预加载</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.getElementById(&#39;btn&#39;).onclick &#x3D; function() &#123;</span><br><span class="line">  &#x2F;&#x2F; 懒加载：当文件需要使用时才加载</span><br><span class="line">  &#x2F;&#x2F; 预加载 prefetch：会在使用之前，提前加载js文件 </span><br><span class="line">  &#x2F;&#x2F; 正常加载可以认为是并行加载（同一时间加载多个文件）  </span><br><span class="line">  &#x2F;&#x2F; 预加载 prefetch：等其他资源加载完毕，浏览器空闲了，再偷偷加载资源</span><br><span class="line">  import(&#x2F;* webpackChunkName: &#39;test&#39;, webpackPrefetch: true *&#x2F;&#39;.&#x2F;test&#39;).then((&#123; mul &#125;) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(mul(4, 5));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="pwa"><a href="#pwa" class="headerlink" title="pwa"></a>pwa</h2><ul>
<li>渐进式网络开发应用程序(离线可访问)<ul>
<li>workbox –&gt; workbox-webpack-plugin</li>
</ul>
</li>
</ul>
<ol>
<li>配置文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; resolve &#125; &#x3D; require(&#39;path&#39;);</span><br><span class="line">const MiniCssExtractPlugin &#x3D; require(&#39;mini-css-extract-plugin&#39;);</span><br><span class="line">const OptimizeCssAssetsWebpackPlugin &#x3D; require(&#39;optimize-css-assets-webpack-plugin&#39;);</span><br><span class="line">const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);</span><br><span class="line">const WorkboxWebpackPlugin &#x3D; require(&#39;workbox-webpack-plugin&#39;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义nodejs环境变量：决定使用browserslist的哪个环境</span><br><span class="line">process.env.NODE_ENV &#x3D; &#39;production&#39;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  entry: &#39;.&#x2F;src&#x2F;js&#x2F;index.js&#39;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#39;js&#x2F;built.[contenthash:10].js&#39;,</span><br><span class="line">    path: resolve(__dirname, &#39;build&#39;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      </span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: &#39;css&#x2F;built.[contenthash:10].css&#39;</span><br><span class="line">    &#125;),</span><br><span class="line">    new OptimizeCssAssetsWebpackPlugin(),</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: &#39;.&#x2F;src&#x2F;index.html&#39;,</span><br><span class="line">      minify: &#123;</span><br><span class="line">        collapseWhitespace: true,</span><br><span class="line">        removeComments: true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    </span><br><span class="line">    new WorkboxWebpackPlugin.GenerateSW(&#123;</span><br><span class="line">      &#x2F;*</span><br><span class="line">        1. 帮助serviceworker快速启动</span><br><span class="line">        2. 删除旧的 serviceworker</span><br><span class="line"></span><br><span class="line">        生成一个 serviceworker 配置文件~</span><br><span class="line">      *&#x2F;</span><br><span class="line">      clientsClaim: true,</span><br><span class="line">      skipWaiting: true</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  mode: &#39;production&#39;,</span><br><span class="line">  devtool: &#39;source-map&#39;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>修改入口js文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*&#x2F;</span><br><span class="line">  1. eslint不认识 window、navigator全局变量</span><br><span class="line">    解决：需要修改package.json中eslintConfig配置</span><br><span class="line">      &quot;env&quot;: &#123;</span><br><span class="line">        &quot;browser&quot;: true &#x2F;&#x2F; 支持浏览器端全局变量</span><br><span class="line">      &#125;</span><br><span class="line">   2. sw代码必须运行在服务器上</span><br><span class="line">      --&gt; nodejs</span><br><span class="line">      --&gt;</span><br><span class="line">        npm i serve -g</span><br><span class="line">        serve -s build 启动服务器，将build目录下所有资源作为静态资源暴露出去</span><br><span class="line">*&#x2F;</span><br><span class="line">&#x2F;&#x2F; 注册serviceWorker</span><br><span class="line">&#x2F;&#x2F; 处理兼容性问题</span><br><span class="line">if (&#39;serviceWorker&#39; in navigator) &#123;</span><br><span class="line">  window.addEventListener(&#39;load&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">    navigator.serviceWorker</span><br><span class="line">      .register(&#39;&#x2F;service-worker.js&#39;)</span><br><span class="line">      .then(() &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;sw注册成功了~&#39;);</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(() &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;sw注册失败了~&#39;);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="多进程打包"><a href="#多进程打包" class="headerlink" title="多进程打包"></a>多进程打包</h2><ul>
<li>thread-loader</li>
</ul>
<ol>
<li>配置文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; resolve &#125; &#x3D; require(&#39;path&#39;);</span><br><span class="line">const MiniCssExtractPlugin &#x3D; require(&#39;mini-css-extract-plugin&#39;);</span><br><span class="line">const OptimizeCssAssetsWebpackPlugin &#x3D; require(&#39;optimize-css-assets-webpack-plugin&#39;);</span><br><span class="line">const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);</span><br><span class="line">const WorkboxWebpackPlugin &#x3D; require(&#39;workbox-webpack-plugin&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义nodejs环境变量：决定使用browserslist的哪个环境</span><br><span class="line">process.env.NODE_ENV &#x3D; &#39;production&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 复用loader</span><br><span class="line">const commonCssLoader &#x3D; [</span><br><span class="line">  MiniCssExtractPlugin.loader,</span><br><span class="line">  &#39;css-loader&#39;,</span><br><span class="line">  &#123;</span><br><span class="line">    &#x2F;&#x2F; 还需要在package.json中定义browserslist</span><br><span class="line">    loader: &#39;postcss-loader&#39;,</span><br><span class="line">    options: &#123;</span><br><span class="line">      ident: &#39;postcss&#39;,</span><br><span class="line">      plugins: () &#x3D;&gt; [require(&#39;postcss-preset-env&#39;)()]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  entry: &#39;.&#x2F;src&#x2F;js&#x2F;index.js&#39;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#39;js&#x2F;built.[contenthash:10].js&#39;,</span><br><span class="line">    path: resolve(__dirname, &#39;build&#39;)</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        &#x2F;&#x2F; 在package.json中eslintConfig --&gt; airbnb</span><br><span class="line">        test: &#x2F;\.js$&#x2F;,</span><br><span class="line">        exclude: &#x2F;node_modules&#x2F;,</span><br><span class="line">        &#x2F;&#x2F; 优先执行</span><br><span class="line">        enforce: &#39;pre&#39;,</span><br><span class="line">        loader: &#39;eslint-loader&#39;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          fix: true</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &#x2F;&#x2F; 以下loader只会匹配一个</span><br><span class="line">        &#x2F;&#x2F; 注意：不能有两个配置处理同一种类型文件</span><br><span class="line">        oneOf: [</span><br><span class="line">          &#123;</span><br><span class="line">            test: &#x2F;\.css$&#x2F;,</span><br><span class="line">            use: [...commonCssLoader]</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            test: &#x2F;\.less$&#x2F;,</span><br><span class="line">            use: [...commonCssLoader, &#39;less-loader&#39;]</span><br><span class="line">          &#125;,</span><br><span class="line">          &#x2F;*</span><br><span class="line">            正常来讲，一个文件只能被一个loader处理。</span><br><span class="line">            当一个文件要被多个loader处理，那么一定要指定loader执行的先后顺序：</span><br><span class="line">              先执行eslint 在执行babel</span><br><span class="line">          *&#x2F;</span><br><span class="line">          &#123;</span><br><span class="line">            test: &#x2F;\.js$&#x2F;,</span><br><span class="line">            exclude: &#x2F;node_modules&#x2F;,</span><br><span class="line">            use: [</span><br><span class="line">              &#x2F;* </span><br><span class="line">                开启多进程打包。 </span><br><span class="line">                进程启动大概为600ms，进程通信也有开销。</span><br><span class="line">                只有工作消耗时间比较长，才需要多进程打包</span><br><span class="line">              *&#x2F;</span><br><span class="line">              &#123;</span><br><span class="line">                loader: &#39;thread-loader&#39;,</span><br><span class="line">                options: &#123;</span><br><span class="line">                  workers: 2 &#x2F;&#x2F; 进程2个</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                loader: &#39;babel-loader&#39;,</span><br><span class="line">                options: &#123;</span><br><span class="line">                  presets: [</span><br><span class="line">                    [</span><br><span class="line">                      &#39;@babel&#x2F;preset-env&#39;,</span><br><span class="line">                      &#123;</span><br><span class="line">                        useBuiltIns: &#39;usage&#39;,</span><br><span class="line">                        corejs: &#123; version: 3 &#125;,</span><br><span class="line">                        targets: &#123;</span><br><span class="line">                          chrome: &#39;60&#39;,</span><br><span class="line">                          firefox: &#39;50&#39;</span><br><span class="line">                        &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                    ]</span><br><span class="line">                  ],</span><br><span class="line">                  &#x2F;&#x2F; 开启babel缓存</span><br><span class="line">                  &#x2F;&#x2F; 第二次构建时，会读取之前的缓存</span><br><span class="line">                  cacheDirectory: true</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            test: &#x2F;\.(jpg|png|gif)&#x2F;,</span><br><span class="line">            loader: &#39;url-loader&#39;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              limit: 8 * 1024,</span><br><span class="line">              name: &#39;[hash:10].[ext]&#39;,</span><br><span class="line">              outputPath: &#39;imgs&#39;,</span><br><span class="line">              esModule: false</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            test: &#x2F;\.html$&#x2F;,</span><br><span class="line">            loader: &#39;html-loader&#39;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            exclude: &#x2F;\.(js|css|less|html|jpg|png|gif)&#x2F;,</span><br><span class="line">            loader: &#39;file-loader&#39;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              outputPath: &#39;media&#39;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: &#39;css&#x2F;built.[contenthash:10].css&#39;</span><br><span class="line">    &#125;),</span><br><span class="line">    new OptimizeCssAssetsWebpackPlugin(),</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: &#39;.&#x2F;src&#x2F;index.html&#39;,</span><br><span class="line">      minify: &#123;</span><br><span class="line">        collapseWhitespace: true,</span><br><span class="line">        removeComments: true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    new WorkboxWebpackPlugin.GenerateSW(&#123;</span><br><span class="line">      &#x2F;*</span><br><span class="line">        1. 帮助serviceworker快速启动</span><br><span class="line">        2. 删除旧的 serviceworker</span><br><span class="line"></span><br><span class="line">        生成一个 serviceworker 配置文件~</span><br><span class="line">      *&#x2F;</span><br><span class="line">      clientsClaim: true,</span><br><span class="line">      skipWaiting: true</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  mode: &#39;production&#39;,</span><br><span class="line">  devtool: &#39;source-map&#39;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="externals"><a href="#externals" class="headerlink" title="externals"></a>externals</h2><ul>
<li>防止将某些包打包到最终输出的文件中</li>
</ul>
<ol>
<li>配置文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; resolve &#125; &#x3D; require(&#39;path&#39;);</span><br><span class="line">const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  entry: &#39;.&#x2F;src&#x2F;js&#x2F;index.js&#39;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#39;js&#x2F;built.js&#39;,</span><br><span class="line">    path: resolve(__dirname, &#39;build&#39;)</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: &#39;.&#x2F;src&#x2F;index.html&#39;</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  mode: &#39;production&#39;,</span><br><span class="line">  externals: &#123;</span><br><span class="line">    &#x2F;&#x2F; 拒绝jQuery被打包进来</span><br><span class="line">    jquery: &#39;jQuery&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="dll"><a href="#dll" class="headerlink" title="dll"></a>dll</h2><ul>
<li>动态链接库，类似于externals，不同的是dll会将多个库单独的打包，将多个库打包成一个chunk</li>
</ul>
<ol>
<li>配置dll.js<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">  使用dll技术，对某些库（第三方库：jquery、react、vue...）进行单独打包</span><br><span class="line">    当你运行 webpack 时，默认查找 webpack.config.js 配置文件</span><br><span class="line">    需求：需要运行 webpack.dll.js 文件</span><br><span class="line">      --&gt; webpack --config webpack.dll.js</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">const &#123; resolve &#125; &#x3D; require(&#39;path&#39;);</span><br><span class="line">const webpack &#x3D; require(&#39;webpack&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    &#x2F;&#x2F; 最终打包生成的[name] --&gt; jquery</span><br><span class="line">    &#x2F;&#x2F; [&#39;jquery&#39;] --&gt; 要打包的库是jquery</span><br><span class="line">    jquery: [&#39;jquery&#39;],</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#39;[name].js&#39;,</span><br><span class="line">    path: resolve(__dirname, &#39;dll&#39;),</span><br><span class="line">    library: &#39;[name]_[hash]&#39; &#x2F;&#x2F; 打包的库里面向外暴露出去的内容叫什么名字</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    &#x2F;&#x2F; 打包生成一个 manifest.json --&gt; 提供和jquery映射</span><br><span class="line">    new webpack.DllPlugin(&#123;</span><br><span class="line">      name: &#39;[name]_[hash]&#39;, &#x2F;&#x2F; 映射库的暴露的内容名称</span><br><span class="line">      path: resolve(__dirname, &#39;dll&#x2F;manifest.json&#39;) &#x2F;&#x2F; 输出文件路径</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  mode: &#39;production&#39;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="2">
<li>配置config文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; resolve &#125; &#x3D; require(&#39;path&#39;);</span><br><span class="line">const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);</span><br><span class="line">const webpack &#x3D; require(&#39;webpack&#39;);</span><br><span class="line">const AddAssetHtmlWebpackPlugin &#x3D; require(&#39;add-asset-html-webpack-plugin&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  entry: &#39;.&#x2F;src&#x2F;index.js&#39;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#39;built.js&#39;,</span><br><span class="line">    path: resolve(__dirname, &#39;build&#39;)</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: &#39;.&#x2F;src&#x2F;index.html&#39;</span><br><span class="line">    &#125;),</span><br><span class="line">    &#x2F;&#x2F; 告诉webpack哪些库不参与打包，同时使用时的名称也得变~</span><br><span class="line">    new webpack.DllReferencePlugin(&#123;</span><br><span class="line">      manifest: resolve(__dirname, &#39;dll&#x2F;manifest.json&#39;)</span><br><span class="line">    &#125;),</span><br><span class="line">    &#x2F;&#x2F; 将某个文件打包输出去，并在html中自动引入该资源</span><br><span class="line">    new AddAssetHtmlWebpackPlugin(&#123;</span><br><span class="line">      filepath: resolve(__dirname, &#39;dll&#x2F;jquery.js&#39;)</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  mode: &#39;production&#39;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>运行指令：webpack</li>
</ol>
<h1 id="webpack配置详解"><a href="#webpack配置详解" class="headerlink" title="webpack配置详解"></a>webpack配置详解</h1><h2 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; resolve &#125; &#x3D; require(&#39;path&#39;);</span><br><span class="line">const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">  entry: 入口起点</span><br><span class="line">    1. string --&gt; &#39;.&#x2F;src&#x2F;index.js&#39;</span><br><span class="line">      单入口</span><br><span class="line">      打包形成一个chunk。 输出一个bundle文件。</span><br><span class="line">      此时chunk的名称默认是 main</span><br><span class="line">    2. array  --&gt; [&#39;.&#x2F;src&#x2F;index.js&#39;, &#39;.&#x2F;src&#x2F;add.js&#39;]</span><br><span class="line">      多入口</span><br><span class="line">      所有入口文件最终只会形成一个chunk, 输出出去只有一个bundle文件。</span><br><span class="line">        --&gt; 只有在HMR功能中让html热更新生效~</span><br><span class="line">    3. object</span><br><span class="line">      多入口</span><br><span class="line">      有几个入口文件就形成几个chunk，输出几个bundle文件</span><br><span class="line">      此时chunk的名称是 key</span><br><span class="line"></span><br><span class="line">      --&gt; 特殊用法</span><br><span class="line">        &#123;</span><br><span class="line">          &#x2F;&#x2F; 所有入口文件最终只会形成一个chunk, 输出出去只有一个bundle文件。</span><br><span class="line">          index: [&#39;.&#x2F;src&#x2F;index.js&#39;, &#39;.&#x2F;src&#x2F;count.js&#39;], </span><br><span class="line">          &#x2F;&#x2F; 形成一个chunk，输出一个bundle文件。</span><br><span class="line">          add: &#39;.&#x2F;src&#x2F;add.js&#39;</span><br><span class="line">        &#125;</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: [&#39;.&#x2F;src&#x2F;index.js&#39;, &#39;.&#x2F;src&#x2F;count.js&#39;], </span><br><span class="line">    add: &#39;.&#x2F;src&#x2F;add.js&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#39;[name].js&#39;,</span><br><span class="line">    path: resolve(__dirname, &#39;build&#39;)</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [new HtmlWebpackPlugin()],</span><br><span class="line">  mode: &#39;development&#39;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="output"><a href="#output" class="headerlink" title="output"></a>output</h2><ol>
<li>配置文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; resolve &#125; &#x3D; require(&#39;path&#39;);</span><br><span class="line">const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  entry: &#39;.&#x2F;src&#x2F;index.js&#39;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    &#x2F;&#x2F; 文件名称（指定名称+目录）</span><br><span class="line">    filename: &#39;js&#x2F;[name].js&#39;,</span><br><span class="line">    &#x2F;&#x2F; 输出文件目录（将来所有资源输出的公共目录）</span><br><span class="line">    path: resolve(__dirname, &#39;build&#39;),</span><br><span class="line">    &#x2F;&#x2F; 所有资源引入公共路径前缀 --&gt; &#39;imgs&#x2F;a.jpg&#39; --&gt; &#39;&#x2F;imgs&#x2F;a.jpg&#39;</span><br><span class="line">    publicPath: &#39;&#x2F;&#39;,</span><br><span class="line">    chunkFilename: &#39;js&#x2F;[name]_chunk.js&#39;, &#x2F;&#x2F; 非入口chunk的名称</span><br><span class="line">    &#x2F;&#x2F; library: &#39;[name]&#39;, &#x2F;&#x2F; 整个库向外暴露的变量名</span><br><span class="line">    &#x2F;&#x2F; libraryTarget: &#39;window&#39; &#x2F;&#x2F; 变量名添加到哪个属性上 browser</span><br><span class="line">    &#x2F;&#x2F; libraryTarget: &#39;global&#39; &#x2F;&#x2F; 变量名添加到哪个属性上 node</span><br><span class="line">    &#x2F;&#x2F; libraryTarget: &#39;commonjs&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [new HtmlWebpackPlugin()],</span><br><span class="line">  mode: &#39;development&#39;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="module"><a href="#module" class="headerlink" title="module"></a>module</h2><ol>
<li>配置文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; resolve &#125; &#x3D; require(&#39;path&#39;);</span><br><span class="line">const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  entry: &#39;.&#x2F;src&#x2F;index.js&#39;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#39;js&#x2F;[name].js&#39;,</span><br><span class="line">    path: resolve(__dirname, &#39;build&#39;)</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#x2F;&#x2F; loader的配置</span><br><span class="line">      &#123;</span><br><span class="line">        test: &#x2F;\.css$&#x2F;,</span><br><span class="line">        &#x2F;&#x2F; 多个loader用use</span><br><span class="line">        use: [&#39;style-loader&#39;, &#39;css-loader&#39;]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: &#x2F;\.js$&#x2F;,</span><br><span class="line">        &#x2F;&#x2F; 排除node_modules下的js文件</span><br><span class="line">        exclude: &#x2F;node_modules&#x2F;,</span><br><span class="line">        &#x2F;&#x2F; 只检查 src 下的js文件</span><br><span class="line">        include: resolve(__dirname, &#39;src&#39;),</span><br><span class="line">        &#x2F;&#x2F; 优先执行</span><br><span class="line">        enforce: &#39;pre&#39;,</span><br><span class="line">        &#x2F;&#x2F; 延后执行</span><br><span class="line">        &#x2F;&#x2F; enforce: &#39;post&#39;,</span><br><span class="line">        &#x2F;&#x2F; 单个loader用loader</span><br><span class="line">        loader: &#39;eslint-loader&#39;,</span><br><span class="line">        options: &#123;&#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &#x2F;&#x2F; 以下配置只会生效一个</span><br><span class="line">        oneOf: []</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [new HtmlWebpackPlugin()],</span><br><span class="line">  mode: &#39;development&#39;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h2><ol>
<li>配置文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; resolve &#125; &#x3D; require(&#39;path&#39;);</span><br><span class="line">const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  entry: &#39;.&#x2F;src&#x2F;js&#x2F;index.js&#39;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#39;js&#x2F;[name].js&#39;,</span><br><span class="line">    path: resolve(__dirname, &#39;build&#39;)</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: &#x2F;\.css$&#x2F;,</span><br><span class="line">        use: [&#39;style-loader&#39;, &#39;css-loader&#39;]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [new HtmlWebpackPlugin()],</span><br><span class="line">  mode: &#39;development&#39;,</span><br><span class="line">  &#x2F;&#x2F; 解析模块的规则</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    &#x2F;&#x2F; 配置解析模块路径别名: 优点简写路径 缺点路径没有提示</span><br><span class="line">    alias: &#123;</span><br><span class="line">      $css: resolve(__dirname, &#39;src&#x2F;css&#39;)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 配置省略文件路径的后缀名</span><br><span class="line">    extensions: [&#39;.js&#39;, &#39;.json&#39;, &#39;.jsx&#39;, &#39;.css&#39;],</span><br><span class="line">    &#x2F;&#x2F; 告诉 webpack 解析模块是去找哪个目录</span><br><span class="line">    modules: [resolve(__dirname, &#39;..&#x2F;..&#x2F;node_modules&#39;), &#39;node_modules&#39;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="dev-server"><a href="#dev-server" class="headerlink" title="dev server"></a>dev server</h2></li>
<li>配置文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  &#x2F;&#x2F; 运行代码的目录</span><br><span class="line">  contentBase: resolve(__dirname, &#39;build&#39;),</span><br><span class="line">  &#x2F;&#x2F; 监视 contentBase 目录下的所有文件，一旦文件变化就会 reload</span><br><span class="line">  watchContentBase: true,</span><br><span class="line">  watchOptions: &#123;</span><br><span class="line">    &#x2F;&#x2F; 忽略文件</span><br><span class="line">    ignored: &#x2F;node_modules&#x2F;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; 启动gzip压缩</span><br><span class="line">  compress: true,</span><br><span class="line">  &#x2F;&#x2F; 端口号</span><br><span class="line">  port: 5000,</span><br><span class="line">  &#x2F;&#x2F; 域名</span><br><span class="line">  host: &#39;localhost&#39;,</span><br><span class="line">  &#x2F;&#x2F; 自动打开浏览器</span><br><span class="line">  open: true,</span><br><span class="line">  &#x2F;&#x2F; 开启HMR功能</span><br><span class="line">  hot: true,</span><br><span class="line">  &#x2F;&#x2F; 不要显示启动服务器日志信息</span><br><span class="line">  clientLogLevel: &#39;none&#39;,</span><br><span class="line">  &#x2F;&#x2F; 除了一些基本启动信息以外，其他内容都不要显示</span><br><span class="line">  quiet: true,</span><br><span class="line">  &#x2F;&#x2F; 如果出错了，不要全屏提示~</span><br><span class="line">  overlay: false,</span><br><span class="line">  &#x2F;&#x2F; 服务器代理 --&gt; 解决开发环境跨域问题</span><br><span class="line">  proxy: &#123;</span><br><span class="line">    &#x2F;&#x2F; 一旦devServer(5000)服务器接受到 &#x2F;api&#x2F;xxx 的请求，就会把请求转发到另外一个服务器(3000)</span><br><span class="line">    &#39;&#x2F;api&#39;: &#123;</span><br><span class="line">      target: &#39;http:&#x2F;&#x2F;localhost:3000&#39;,</span><br><span class="line">      &#x2F;&#x2F; 发送请求时，请求路径重写：将 &#x2F;api&#x2F;xxx --&gt; &#x2F;xxx （去掉&#x2F;api）</span><br><span class="line">      pathRewrite: &#123;</span><br><span class="line">        &#39;^&#x2F;api&#39;: &#39;&#39;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="optimization"><a href="#optimization" class="headerlink" title="optimization"></a>optimization</h2><ol>
<li>配置文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   splitChunks: &#123;</span><br><span class="line">     chunks: &#39;all&#39;</span><br><span class="line">     &#x2F;&#x2F; 默认值，可以不写~</span><br><span class="line">     &#x2F;* minSize: 30 * 1024, &#x2F;&#x2F; 分割的chunk最小为30kb</span><br><span class="line">     maxSiza: 0, &#x2F;&#x2F; 最大没有限制</span><br><span class="line">     minChunks: 1, &#x2F;&#x2F; 要提取的chunk最少被引用1次</span><br><span class="line">     maxAsyncRequests: 5, &#x2F;&#x2F; 按需加载时并行加载的文件的最大数量</span><br><span class="line">     maxInitialRequests: 3, &#x2F;&#x2F; 入口js文件最大并行请求数量</span><br><span class="line">     automaticNameDelimiter: &#39;~&#39;, &#x2F;&#x2F; 名称连接符</span><br><span class="line">     name: true, &#x2F;&#x2F; 可以使用命名规则</span><br><span class="line">     cacheGroups: &#123;</span><br><span class="line">       &#x2F;&#x2F; 分割chunk的组</span><br><span class="line">       &#x2F;&#x2F; node_modules文件会被打包到 vendors 组的chunk中。--&gt; vendors~xxx.js</span><br><span class="line">       &#x2F;&#x2F; 满足上面的公共规则，如：大小超过30kb，至少被引用一次。</span><br><span class="line">       vendors: &#123;</span><br><span class="line">         test: &#x2F;[\\&#x2F;]node_modules[\\&#x2F;]&#x2F;,</span><br><span class="line">         &#x2F;&#x2F; 优先级</span><br><span class="line">         priority: -10</span><br><span class="line">       &#125;,</span><br><span class="line">       default: &#123;</span><br><span class="line">         &#x2F;&#x2F; 要提取的chunk最少被引用2次</span><br><span class="line">         minChunks: 2,</span><br><span class="line">         &#x2F;&#x2F; 优先级</span><br><span class="line">         priority: -20,</span><br><span class="line">         &#x2F;&#x2F; 如果当前要打包的模块，和之前已经被提取的模块是同一个，就会复用，而不是重新打包模块</span><br><span class="line">         reuseExistingChunk: true</span><br><span class="line">       &#125; </span><br><span class="line">     &#125;*&#x2F;</span><br><span class="line">   &#125;,</span><br><span class="line">   &#x2F;&#x2F; 将当前模块的记录其他模块的hash单独打包为一个文件 runtime</span><br><span class="line">   &#x2F;&#x2F; 解决：修改a文件导致b文件的contenthash变化</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   runtimeChunk: &#123;</span><br><span class="line">     name: entrypoint &#x3D;&gt; &#96;runtime-$&#123;entrypoint.name&#125;&#96;</span><br><span class="line">   &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   minimizer: [</span><br><span class="line">     &#x2F;&#x2F; 配置生产环境的压缩方案：js和css</span><br><span class="line">     new TerserWebpackPlugin(&#123;</span><br><span class="line">       &#x2F;&#x2F; 开启缓存</span><br><span class="line">       cache: true,</span><br><span class="line">       &#x2F;&#x2F; 开启多进程打包</span><br><span class="line">       parallel: true,</span><br><span class="line">       &#x2F;&#x2F; 启动source-map</span><br><span class="line">       sourceMap: true</span><br><span class="line">     &#125;)</span><br><span class="line">   ]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="webpack5（正在开发中-71-）"><a href="#webpack5（正在开发中-71-）" class="headerlink" title="webpack5（正在开发中 71%）"></a>webpack5（正在开发中 71%）</h1><p>此版本重点关注以下内容:</p>
<ul>
<li>通过持久缓存提高构建性能.</li>
<li>使用更好的算法和默认值来改善长期缓存.</li>
<li>通过更好的树摇和代码生成来改善捆绑包大小.</li>
<li>清除处于怪异状态的内部结构，同时在 v4 中实现功能而不引入任何重大更改.</li>
<li>通过引入重大更改来为将来的功能做准备，以使我们能够尽可能长时间地使用 v5.</li>
</ul>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><ul>
<li>npm i webpack@next webpack-cli -D</li>
</ul>
<h2 id="自动删除-Node-js-Polyfills"><a href="#自动删除-Node-js-Polyfills" class="headerlink" title="自动删除 Node.js Polyfills"></a>自动删除 Node.js Polyfills</h2><ul>
<li><p>早期，webpack 的目标是允许在浏览器中运行大多数 node.js 模块，但是模块格局发生了变化，许多模块用途现在主要是为前端目的而编写的。<br>webpack &lt;= 4 附带了许多 node.js 核心模块的 polyfill，一旦模块使用任何核心模块（即 crypto 模块），这些模块就会自动应用。</p>
</li>
<li><p>尽管这使使用为 node.js 编写的模块变得容易，但它会将这些巨大的 polyfill 添加到包中。在许多情况下，这些 polyfill 是不必要的。</p>
</li>
<li><p>webpack 5 会自动停止填充这些核心模块，并专注于与前端兼容的模块。</p>
</li>
</ul>
<p>迁移：</p>
<ul>
<li>尽可能尝试使用与前端兼容的模块。</li>
<li>可以为 node.js 核心模块手动添加一个 polyfill。错误消息将提示如何实现该目标。</li>
</ul>
<h2 id="Chunk-和模块-ID"><a href="#Chunk-和模块-ID" class="headerlink" title="Chunk 和模块 ID"></a>Chunk 和模块 ID</h2><ul>
<li>添加了用于长期缓存的新算法。在生产模式下默认情况下启用这些功能。</li>
</ul>
<p><code>chunkIds: &quot;deterministic&quot;, moduleIds: &quot;deterministic&quot;</code></p>
<h2 id="Chunk-ID"><a href="#Chunk-ID" class="headerlink" title="Chunk ID"></a>Chunk ID</h2><ul>
<li><p>你可以不用使用 <code>import(/* webpackChunkName: &quot;name&quot; */ &quot;module&quot;)</code> 在开发环境来为 chunk 命名，生产环境还是有必要的</p>
</li>
<li><p>webpack 内部有 chunk 命名规则，不再是以 id(0, 1, 2)命名了</p>
</li>
</ul>
<h2 id="Tree-Shaking"><a href="#Tree-Shaking" class="headerlink" title="Tree Shaking"></a>Tree Shaking</h2><ol>
<li>webpack 现在能够处理对嵌套模块的 tree shaking</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// inner.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// module.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> inner <span class="keyword">from</span> <span class="string">'./inner'</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; inner &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// user.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="built_in">module</span> <span class="keyword">from</span> <span class="string">'./module'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>.inner.a);</span><br></pre></td></tr></table></figure>

<ul>
<li>在生产环境中, inner 模块暴露的 <code>b</code> 会被删除</li>
</ul>
<ol start="2">
<li>webpack 现在能够多个模块之前的关系</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; something &#125; <span class="keyword">from</span> <span class="string">'./something'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">usingSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> usingSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当设置了<code>&quot;sideEffects&quot;: false</code>时，一旦发现<code>test</code>方法没有使用，不但删除<code>test</code>，还会删除<code>&quot;./something&quot;</code></li>
</ul>
<ol start="3">
<li>webpack 现在能处理对 Commonjs 的 tree shaking</li>
</ol>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><ul>
<li><p>webpack 4 默认只能输出 ES5 代码</p>
</li>
<li><p>webpack 5 开始新增一个属性 output.ecmaVersion, 可以生成 ES5 和 ES6 / ES2015 代码.</p>
</li>
<li><p>如：<code>output.ecmaVersion: 2015</code></p>
</li>
</ul>
<h2 id="SplitChunk"><a href="#SplitChunk" class="headerlink" title="SplitChunk"></a>SplitChunk</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack4</span></span><br><span class="line">minSize: <span class="number">30000</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack5</span></span><br><span class="line">minSize: &#123;</span><br><span class="line">  javascript: <span class="number">30000</span>,</span><br><span class="line">  style: <span class="number">50000</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Caching"><a href="#Caching" class="headerlink" title="Caching"></a>Caching</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置缓存</span></span><br><span class="line">cache: &#123;</span><br><span class="line">  <span class="comment">// 磁盘存储</span></span><br><span class="line">  type: <span class="string">"filesystem"</span>,</span><br><span class="line">  buildDependencies: &#123;</span><br><span class="line">    <span class="comment">// 当配置修改时，缓存失效</span></span><br><span class="line">    config: [__filename]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>-缓存将存储到 <code>node_modules/.cache/webpack</code></p>
<h2 id="监视输出文件"><a href="#监视输出文件" class="headerlink" title="监视输出文件"></a>监视输出文件</h2><ul>
<li><p>之前 webpack 总是在第一次构建时输出全部文件，但是监视重新构建时会只更新修改的文件。</p>
</li>
<li><p>此次更新在第一次构建时会找到输出文件看是否有变化，从而决定要不要输出全部文件。</p>
</li>
</ul>
<h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><ul>
<li><code>entry: &quot;./src/index.js</code></li>
<li><code>output.path: path.resolve(__dirname, &quot;dist&quot;)</code></li>
<li><code>output.filename: &quot;[name].js&quot;</code></li>
</ul>
<h2 id="更多内容"><a href="#更多内容" class="headerlink" title="更多内容"></a>更多内容</h2><p><a href="https://github.com/webpack/changelog-v5" target="_blank" rel="noopener">https://github.com/webpack/changelog-v5</a></p>
]]></content>
      <categories>
        <category>自动化构建工具</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Git&amp;Github</title>
    <url>/2020/07/17/Git-Github/</url>
    <content><![CDATA[<blockquote>
<p>序<br><br> Git是一个分布式版本控制系统， Github是一个为用户提供Git服务的网站</p>
</blockquote>
<a id="more"></a>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul>
<li><p>仓库(Repository):存放项目代码，多个开源项目存放多个仓库</p>
</li>
<li><p>收藏（star）：收藏项目</p>
</li>
<li><p>复制克隆项目（fork）：该fork的项目时独立存在的，把项目复制过来自己用</p>
</li>
<li><p>发起请求（Pull request）：基于fork的动作，在别人的fork项目上新增了功能，觉得不错，想合并到原本项目里，会向原有项目创建人发送请求，原有项目人同意即可添加你的代码</p>
</li>
<li><p>关注（watch）：关注别人项目，及时收到更新的消息</p>
</li>
<li><p>事物卡片（lssue）：发现代码BUG，但是目前没有成型代码，需要讨论时用，比如别人发现你的项目中有bug就会给你发送issue来提醒你</p>
</li>
</ul>
<h1 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h1><ul>
<li>关于GitHub访问的问题</li>
</ul>
<ol>
<li>第一种方法就是挂梯子了，毕竟GitHub是国外的服务器，这点理所应当，不止是一般的VPN，我在挂学校的vpn时也能实现很流畅的访问</li>
<li>第二种就是我在网上搜罗了一种不用挂梯子也能访问的方法<ol>
<li>访问<a href="https://www.ipaddress.com/" target="_blank" rel="noopener">IP查询网站</a></li>
<li>在搜索框里搜索(GitHub.com),就会出现以下页面，找到该地址并记下来<br><img src="/2020/07/17/Git-Github/ip.png" alt></li>
<li>然后再在搜索框中搜索（github.global.ssl.fastly.net），找到地址并记下来<br><img src="/2020/07/17/Git-Github/ip2.png" alt></li>
<li>将这两个地址写到C:\Windows\System32\drivers\etc 路径下的 hosts文件<br><img src="/2020/07/17/Git-Github/host.png" alt></li>
<li>刷新dns后(ipconfig /flushdns)就可以访问啦，不过速度emmm</li>
</ol>
</li>
</ol>
<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><ul>
<li><p>Git和Github的区别</p>
<ul>
<li><p>Git是一个分布式版本控制系统，简单的说就是一个软件，用于记录一个或若干文件内容变化，以便来查阅特定版本修订情况的软件。</p>
</li>
<li><p>Github是一个为用户提供Git服务的网站，简单说就是一个可以放代码的地方（也可以放其他内容）。Github除了提供管理Git的web界面外，还提供了订阅、关注、讨论组,在线编辑器等丰富的功能。</p>
</li>
<li><p>目前我们使用到的 Git 命令都是在本地执行，如果你想通过 Git 分享你的代码或者与其他开发人员合作。你就需要将数据放到一台其他开发人员能够连接的服务器上,所以就可以使用 Github 作为远程仓库</p>
</li>
</ul>
</li>
</ul>
<h2 id="基本工作流程"><a href="#基本工作流程" class="headerlink" title="基本工作流程"></a>基本工作流程</h2><ul>
<li><p>Git工作区域<br><img src="/2020/07/17/Git-Github/Gitwork.png" alt></p>
</li>
<li><p>向仓库中添加文件流程<br><img src="/2020/07/17/Git-Github/gitstep.png" alt></p>
</li>
</ul>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><ol>
<li>基本信息设置<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &#39;用户名&#39;</span><br><span class="line">git config --global user.email &#39;邮箱地址&#39;</span><br><span class="line"></span><br><span class="line">该设置在github仓库主页显示谁提交了该文件</span><br></pre></td></tr></table></figure></li>
<li>Git仓库的初始化</li>
</ol>
<ul>
<li>即让Git知道需要他来管理这个目录<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></li>
<li>执行后，打开这个项目目录下，点击隐藏目录你会发现多了一个.git文件夹。不能删除，也不能随意更改</li>
</ul>
<h2 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h2><ul>
<li><p>上传文件至仓库</p>
<ol>
<li>git status:查看当前工作状态</li>
<li>git add:将工作区文件添加到缓存区，可以加–all批量提交</li>
<li>git commit -m “注释内容”:提交至版本库</li>
</ol>
</li>
<li><p>删除文件</p>
<ol>
<li>git rm:从git中删除文件</li>
</ol>
</li>
<li><p>将本地仓库同步到远程仓库</p>
<ol>
<li>先将远程仓库的项目复制到本地<ul>
<li>git clone 线上仓库地址</li>
</ul>
</li>
<li>操作完文件将文件添加到本地仓库</li>
<li>git push可将本地仓库同步到远程仓库</li>
<li>用git pull拉取线上的最新版本</li>
</ol>
<ul>
<li>如果要同步到其他仓库<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">先建立连接</span><br><span class="line">git remote add name http:&#x2F;&#x2F;xxxxxxxx.git   (如果是clone下来的可以省略) </span><br><span class="line"></span><br><span class="line">然后拉取最新版</span><br><span class="line">git pull  name branch &#x2F;&#x2F;有一种情况是因为readme.md文件不在本地会报错 只需要git pull --rebase name branch本地生成readme文件</span><br><span class="line"></span><br><span class="line">然后推送到仓库</span><br><span class="line">git push name branch</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<ul>
<li><p>查询文件</p>
<ul>
<li>git  status   :  查看工作目录中文件的状态(已跟踪(已提交 已暂存 已修改) 未跟踪)</li>
<li>git  diff     :  查看未暂存的修改</li>
<li>git  diff –cache : 查看未提交的暂存</li>
<li>git  log –oneline : 查看提交记录</li>
</ul>
</li>
<li><p>分支</p>
<ul>
<li>分支的本质其实就是一个提交对象!!!</li>
<li>HEAD: 是一个指针 它默认指向master分支 切换分支时其实就是让HEAD指向不同的分支，每次有新的提交时 HEAD都会带着当前指向的分支 一起往前移动</li>
<li>创建分支            : git branch branchname</li>
<li>切换分支           : git checkout  branchname</li>
<li>创建&amp;切换分支     : git checkout -b branchname</li>
<li>版本穿梭(时光机) :  git branch branchname commitHash  </li>
<li>普通删除分支      : git  branch -d branchname</li>
<li>强制删除分支      : git  branch -D branchname</li>
<li>合并分支         : git merge branchname</li>
</ul>
</li>
<li><p>git分支的注意点：在切换的时候 一定要保证当前分支是干净的（已提交状态）!!!</p>
</li>
<li><p>后悔药</p>
<ul>
<li>工作区<ul>
<li>如何撤回自己在工作目录中的修改 : git checkout –filename</li>
</ul>
</li>
<li>暂存区<ul>
<li>如何撤回自己的暂存  : git reset HEAD filename</li>
</ul>
</li>
<li>版本库              <ul>
<li>如何撤回自己的提交    : git commit –amend<ol>
<li>注释写错了,重新给用户一次机会改注释</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>版本控制工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>Grunt</title>
    <url>/2020/07/18/Grunt/</url>
    <content><![CDATA[<blockquote>
<p>序<br><br>使用构建工具去对 JS、CSS、HTML、LESS、IMG 等进行合并压缩构建到最后实现自动化构建项目。是前端工程师必备的技能之一</p>
</blockquote>
<a id="more"></a>

<ul>
<li>什么是项目构建？<ul>
<li>编译项目中的js,sass,less</li>
<li>合并js/css等资源文件</li>
<li>压缩js/css/html等资源文件</li>
<li>js语法的检查</li>
</ul>
</li>
<li>构建工具的作用？<ul>
<li>简化项目构建，自动化完成构建<h1 id="Grunt"><a href="#Grunt" class="headerlink" title="Grunt"></a>Grunt</h1></li>
</ul>
</li>
<li><a href="https://www.gruntjs.net/" target="_blank" rel="noopener">Grunt中文官网</a></li>
<li>是一套前端<strong>自动化构建</strong>工具，一个基于nodeJs的命令行工具</li>
<li>它是一个<strong>任务运行器</strong>, 配合其丰富强大的<strong>插件</strong></li>
<li>常用功能:<ul>
<li><strong>合并文件</strong>(js/css)</li>
<li><strong>压缩文件</strong>(js/css)</li>
<li><strong>语法检查</strong>(js)</li>
<li><strong>less/sass预编译处理</strong> </li>
</ul>
</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul>
<li><p>举例创建一个简单的应用grunt_test</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  |- build----------构建生成的文件所在的文件夹</span><br><span class="line">  |- src------------源码文件夹   </span><br><span class="line">      |- js---------------js源文件夹</span><br><span class="line">      |- css--------------css源文件夹</span><br><span class="line">  |- index.html-----页面文件</span><br><span class="line">  |- Gruntfile.js---grunt配置文件(去官网获取，注意首字母大写)</span><br><span class="line">  |- package.json---项目包配置文件</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;name&quot;: &quot;grunt_test&quot;,</span><br><span class="line">        &quot;version&quot;: &quot;1.0.0&quot;   </span><br><span class="line">      &#125;</span><br><span class="line">  &#96;&#96;&#96;  </span><br><span class="line">* 安装nodejs, 查看版本</span><br></pre></td></tr></table></figure>
<p>node -v</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 全局安装 grunt-cli</span><br></pre></td></tr></table></figure>
<p>npm install -g grunt-cli </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 安装grunt</span><br></pre></td></tr></table></figure>
<p>npm install grunt –save-dev</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 运行构建项目命令</span><br></pre></td></tr></table></figure>
<p>grunt  //提示 Warning: Task “default” not found</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 配置文件: Gruntfile.js</span><br><span class="line">  * 此配置文件本质就是一个node函数类型模块</span><br><span class="line">  * 配置编码包含3步:</span><br><span class="line">    1. 初始化插件配置</span><br><span class="line">    2. 加载插件任务</span><br><span class="line">    3. 注册构建任务</span><br><span class="line">  * 基本编码:</span><br></pre></td></tr></table></figure>
<p>  官网有详细介绍<br>  module.exports = function(grunt){</p>
<pre><code>// 1. 初始化插件配置
grunt.initConfig({
    //主要编码处
});

// 2. 加载插件任务
// grunt.loadNpmTasks(&apos;grunt-contrib-concat&apos;);

// 3. 注册构建任务
grunt.registerTask(&apos;default&apos;, []);</code></pre><p>  };</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  * 命令: grunt  &#x2F;&#x2F;提示成功, 但没有任何效果(还没有使用插件定义任务)</span><br><span class="line"></span><br><span class="line">## Grunt插件介绍</span><br><span class="line">* grunt官网的插件列表页面 http:&#x2F;&#x2F;www.gruntjs.net&#x2F;plugins </span><br><span class="line">* 插件分类:</span><br><span class="line">    * grunt团队贡献的插件 : 插件名大都以contrib-开头</span><br><span class="line">    * 第三方提供的插件 : 大都不以contrib-开头</span><br><span class="line">* 常用的插件:</span><br><span class="line">    * grunt-contrib-clean——清除文件(打包处理生成的)</span><br><span class="line">    * grunt-contrib-concat——合并多个文件的代码到一个文件中</span><br><span class="line">    * grunt-contrib-uglify——压缩js文件</span><br><span class="line">    * grunt-contrib-jshint——javascript语法错误检查；</span><br><span class="line">    * grunt-contrib-cssmin——压缩&#x2F;合并css文件</span><br><span class="line">    * grunt-contrib-htmlmin——压缩html文件</span><br><span class="line">    * grunt-contrib-imagemin——压缩图片文件(无损)</span><br><span class="line">    * grunt-contrib-copy——复制文件、文件夹</span><br><span class="line">    * **grunt-contrib-requirejs**——合并压缩requirejs管理的所有js模块文件</span><br><span class="line">    * grunt-contrib-watch——实时监控文件变化、调用相应的任务重新执行</span><br><span class="line"></span><br><span class="line">## 合并js: 使用concat插件</span><br><span class="line">  * 命令:</span><br></pre></td></tr></table></figure>
<p>  npm install grunt-contrib-concat –save-dev</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* 配置: Gruntfile.js</span><br><span class="line">  * 配置任务:</span><br></pre></td></tr></table></figure>
<pre><code> concat: {
   options: { //可选项配置
     separator: &apos;;&apos;   //使用;连接合并
   },
   build: { //此名称任意
     src:  [&quot;src/js/*.js&quot;],  //合并哪些js文件
     dest: &quot;build/js/built.js&quot; //输出的js文件
   }
 }
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 加载插件:</span><br></pre></td></tr></table></figure>
grunt.loadNpmTasks(&apos;grunt-contrib-concat&apos;);
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 注册任务:</span><br></pre></td></tr></table></figure>
grunt.registerTask(&apos;default&apos;, [&apos;concat&apos;]);
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* **grunt执行任务是同步的**，插件顺序要放对</span><br><span class="line">* 命令:</span><br></pre></td></tr></table></figure>
grunt   //会在build下生成一个built.js
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line"></span><br><span class="line">## 压缩js: 使用uglify插件</span><br><span class="line">  * 先合并后压缩 </span><br><span class="line">  * 下载</span><br></pre></td></tr></table></figure></code></pre><p>  npm install grunt-contrib-uglify –save-dev</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 配置: Gruntfile.js</span><br><span class="line">  * 配置任务:</span><br></pre></td></tr></table></figure>
<pre><code>pkg : grunt.file.readJSON(&apos;package.json&apos;),
uglify : {
  options: {  //不是必须的
    banner: &apos;/*! &lt;%= pkg.name %&gt; - v&lt;%= pkg.version %&gt; - &apos; +
    &apos;&lt;%= grunt.template.today(&quot;yyyy-mm-dd&quot;) %&gt; */&apos;
  },
  build: {
    files: {
      &apos;build/js/built.min.js&apos;: [&apos;build/js/built.js&apos;]
    }
  }
}
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 加载任务:</span><br></pre></td></tr></table></figure>
grunt.loadNpmTasks(&apos;grunt-contrib-uglify&apos;);
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 注册任务:</span><br></pre></td></tr></table></figure>
grunt.registerTask(&apos;default&apos;, [&apos;concat&apos;, &apos;uglify&apos;]);
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 命令:</span><br></pre></td></tr></table></figure>
grunt   //会在build下生成一个压缩的js文件
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## js语法检查: 使用jshint插件</span><br><span class="line">  * 命令:</span><br></pre></td></tr></table></figure></code></pre><p>  npm install grunt-contrib-jshint –save-dev</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 编码: 创建.jshintrc</span><br></pre></td></tr></table></figure>
<p>   {</p>
<pre><code>&quot;curly&quot;: true,
&quot;eqeqeq&quot;: true,
&quot;eqnull&quot;: true,
&quot;expr&quot; : true,
&quot;immed&quot;: true,
&quot;newcap&quot;: true,
&quot;noempty&quot;: true,
&quot;noarg&quot;: true,
&quot;regexp&quot;: true,
&quot;browser&quot;: true,
&quot;devel&quot;: true,
&quot;node&quot;: true,
&quot;boss&quot;: false,

//不能使用未定义的变量
&quot;undef&quot;: true,
//语句后面必须有分号
&quot;asi&quot;: false,
//预定义不检查的全局变量
&quot;predef&quot;: [ &quot;define&quot;, &quot;BMap&quot;, &quot;angular&quot;, &quot;BMAP_STATUS_SUCCESS&quot;]</code></pre><p>   }</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* 配置 : Gruntfile.js</span><br><span class="line">  * 配置任务:</span><br></pre></td></tr></table></figure>
<pre><code>jshint : {
  options: {
    jshintrc : &apos;.jshintrc&apos; //指定配置文件
  },
  build : [&apos;Gruntfile.js&apos;, &apos;src/js/*.js&apos;] //指定检查的文件
}
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 加载任务:</span><br></pre></td></tr></table></figure>
grunt.loadNpmTasks(&apos;grunt-contrib-jshint&apos;);
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 注册任务:</span><br></pre></td></tr></table></figure>
grunt.registerTask(&apos;default&apos;, [&apos;concat&apos;, &apos;uglify&apos;, &apos;jshint&apos;]);
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 命令:</span><br></pre></td></tr></table></figure>
grunt   //提示变量未定义和语句后未加分号 --&gt;修改后重新编译
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 压缩&#x2F;合并css文件：使用cssmin插件</span><br><span class="line">  * 安装:</span><br></pre></td></tr></table></figure></code></pre><p>  npm install grunt-contrib-cssmin –save-dev</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 配置 : Gruntfile.js</span><br><span class="line">  * 配置任务:</span><br></pre></td></tr></table></figure>
<pre><code>cssmin:{
  options: {
    shorthandCompacting: false,//快速压缩
    roundingPrecision: -1//精确度
  },
  build: {
    files: {
        &apos;build/css/output.min.css&apos;: [&apos;src/css/*.css&apos;]
    }
  }
}
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 加载任务:</span><br></pre></td></tr></table></figure>
grunt.loadNpmTasks(&apos;grunt-contrib-cssmin&apos;);
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 注册任务:</span><br></pre></td></tr></table></figure>
grunt.registerTask(&apos;default&apos;, [&apos;concat&apos;, &apos;uglify&apos;, &apos;jshint&apos;, &apos;cssmin&apos;]);
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 命令:</span><br></pre></td></tr></table></figure>
grunt    //在build/css/下生成output.min.css
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 使用watch插件:(真正实现自动化-实时监控文件变化、调用相应的任务重新执行)</span><br><span class="line">  * 命令: npm install grunt-contrib-watch --save-dev</span><br><span class="line">  * 配置 : Gruntfile.js</span><br><span class="line">  </span><br><span class="line">    * 配置任务:</span><br></pre></td></tr></table></figure>
watch : {
  scripts : {
    files : [&apos;src/js/*.js&apos;, &apos;src/css/*.css&apos;],
    tasks : [&apos;concat&apos;, &apos;jshint&apos;, &apos;uglify&apos;, &apos;cssmin&apos;],
    options : {spawn : false}  
  }
}
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 加载任务:</span><br></pre></td></tr></table></figure>
grunt.loadNpmTasks(&apos;grunt-contrib-watch&apos;);
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 注册任务:</span><br></pre></td></tr></table></figure>
grunt.registerTask(&apos;default&apos;, [&apos;concat&apos;, &apos;uglify&apos;, &apos;jshint&apos;, &apos;watch&apos;]);
改进：grunt.registerTask(&apos;myWatch&apos;, [&apos;default&apos;,&apos;watch&apos;]);
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 命令:</span><br></pre></td></tr></table></figure>
grunt   //控制台提示watch已经开始监听, 修改保存后自动编译处理
```</code></pre></li>
</ul>
]]></content>
      <categories>
        <category>自动化构建工具</category>
      </categories>
      <tags>
        <tag>Grunt</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器竟然被挖矿程序攻击！？</title>
    <url>/2020/07/20/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%9F%E7%84%B6%E8%A2%AB%E6%8C%96%E7%9F%BF%E7%A8%8B%E5%BA%8F%E6%94%BB%E5%87%BB%EF%BC%81%EF%BC%9F/</url>
    <content><![CDATA[<blockquote>
<p>序<br><br>今天一大早醒来，洗漱了吃完饭，准备接着进度学习呢，突然手机短信提示服务器安全紧急事件：挖矿程序，上云服务控制台一顿找才发现服务器的cpu竟然爆了，平时服务器就放个博客，cpu利用率也才10%都不到，于是开始着手解决这个问题</p>
</blockquote>
<a id="more"></a>

<h1 id="挖矿程序是什么？"><a href="#挖矿程序是什么？" class="headerlink" title="挖矿程序是什么？"></a>挖矿程序是什么？</h1><ul>
<li><p>挖矿是跟区块链以及虚拟币有关系，虚拟币是挖矿挖出来的，每间隔一段时间，比特币或者以太坊虚拟币就会在他们的区块链系统上生成一个块的随机代码，网络上的所有服务器都可以去找这个随机代码，也就是挖矿的过程对这个随机代码进行挖掘，谁挖到这个代码就会产生一个区块链的块，那么比特币跟以太坊就会奖励找到随机代码的人，奖励一定数量的虚拟币，那么挖矿的人就会有动力去挖矿，去维护整个区块链节点的网络正常运行，挖矿需要计算哈希值需要服务器的处理能力，所以有些攻击者利用入侵别人服务器来给自己挖矿，获取利润。</p>
</li>
<li><p>简单的来说就是别人利用你服务器的漏洞植入一段程序，然后用你的服务器帮他挖矿来帮他谋求利益</p>
</li>
</ul>
<h1 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a>处理过程</h1><ol>
<li><strong>找到占用率高的进程并杀死</strong></li>
</ol>
<ul>
<li>首先我们用 top 指令来查看服务器的进程<br><img src="/2020/07/20/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%9F%E7%84%B6%E8%A2%AB%E6%8C%96%E7%9F%BF%E7%A8%8B%E5%BA%8F%E6%94%BB%E5%87%BB%EF%BC%81%EF%BC%9F/%5C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%9F%E7%84%B6%E8%A2%AB%E6%8C%96%E7%9F%BF%E7%A8%8B%E5%BA%8F%E6%94%BB%E5%87%BB%EF%BC%81%EF%BC%9F%5C1.png" alt></li>
<li>发现cpu占用率爆满</li>
<li>然后我们找到占有率最高的进程，找到他的pid</li>
<li>然后把该进程kill掉  kill -9 pid</li>
<li>然后cpu恢复了平静<br><img src="/2020/07/20/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%9F%E7%84%B6%E8%A2%AB%E6%8C%96%E7%9F%BF%E7%A8%8B%E5%BA%8F%E6%94%BB%E5%87%BB%EF%BC%81%EF%BC%9F/%5C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%9F%E7%84%B6%E8%A2%AB%E6%8C%96%E7%9F%BF%E7%A8%8B%E5%BA%8F%E6%94%BB%E5%87%BB%EF%BC%81%EF%BC%9F%5C2.png" alt></li>
</ul>
<ol start="2">
<li><strong>查看是否有定时任务</strong></li>
</ol>
<ul>
<li>我等待了半个小时发现挖矿程序并没有卷土重来</li>
<li>但是为了以防万一我还是把备用方案做好</li>
<li>挖矿程序一般都有定时任务，查看定时任务得去crontab文件里找<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;crontab</span><br><span class="line">一般在下面会有可疑的任务，根据任务找到脚本，并且删掉他</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="3">
<li><strong>删除残余文件</strong></li>
</ol>
<ul>
<li>cd /proc/进程号</li>
<li>删除路径下的所有文件</li>
</ul>
<p><strong><em>不得不说阿里云安全售卖的那些服务并不是没有道理的，原来我他给我提示的那些风险警告并不是没用的，我一直以为是他为了售卖自己的产品故意安排这么多漏洞的，这会见识到了</em></strong></p>
<h1 id="7-21"><a href="#7-21" class="headerlink" title="7.21"></a>7.21</h1><ul>
<li>我太天真了，他又来了，这回是在凌晨4点启动的<br><img src="/2020/07/20/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%9F%E7%84%B6%E8%A2%AB%E6%8C%96%E7%9F%BF%E7%A8%8B%E5%BA%8F%E6%94%BB%E5%87%BB%EF%BC%81%EF%BC%9F/%5C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%9F%E7%84%B6%E8%A2%AB%E6%8C%96%E7%9F%BF%E7%A8%8B%E5%BA%8F%E6%94%BB%E5%87%BB%EF%BC%81%EF%BC%9F%5C721.png" alt></li>
<li>我收到危险提示短信后，去服务器查看服务器进程<br><img src="/2020/07/20/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%9F%E7%84%B6%E8%A2%AB%E6%8C%96%E7%9F%BF%E7%A8%8B%E5%BA%8F%E6%94%BB%E5%87%BB%EF%BC%81%EF%BC%9F/%5C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%9F%E7%84%B6%E8%A2%AB%E6%8C%96%E7%9F%BF%E7%A8%8B%E5%BA%8F%E6%94%BB%E5%87%BB%EF%BC%81%EF%BC%9F%5C7211.png" alt></li>
<li>果然有人在用我的服务器挖矿</li>
<li>这次我没有直接杀死进程，而是先找到他的进程文件<br><img src="/2020/07/20/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%9F%E7%84%B6%E8%A2%AB%E6%8C%96%E7%9F%BF%E7%A8%8B%E5%BA%8F%E6%94%BB%E5%87%BB%EF%BC%81%EF%BC%9F/%5C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%9F%E7%84%B6%E8%A2%AB%E6%8C%96%E7%9F%BF%E7%A8%8B%E5%BA%8F%E6%94%BB%E5%87%BB%EF%BC%81%EF%BC%9F%5C72111.png" alt></li>
<li>发现了他的启动程序在/home/git/xmr64下</li>
<li>然后杀死进程</li>
<li>删除rm -f启动程序</li>
<li>删除rm -rf进程残留文件</li>
</ul>
<p><strong><em>这下应该清净了吧，启动文件都没有了，应该不会再找上门了吧</em></strong></p>
]]></content>
      <categories>
        <category>后台服务器端</category>
      </categories>
      <tags>
        <tag>阿里云服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>Bootstrap</title>
    <url>/2020/07/21/Bootstrap/</url>
    <content><![CDATA[<blockquote>
<p>序<br><br>简洁、直观、强悍的前端开发框架，让web开发更迅速、简单</p>
</blockquote>
<a id="more"></a>
<ul>
<li>中文网 ： <a href="http://www.bootcss.com/" target="_blank" rel="noopener">http://www.bootcss.com/</a></li>
<li>英文网 :  <a href="http://getbootstrap.com/" target="_blank" rel="noopener">http://getbootstrap.com/</a><h1 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h1><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2></li>
</ul>
<ol>
<li><p>流体布局容器</p>
<ul>
<li>容器的width为auto，只是两边加了15px的padding</li>
<li>源码 ：<ul>
<li>流体容器&amp;固定容器 公共样式：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">margin-right: auto;</span><br><span class="line">margin-left: auto;</span><br><span class="line">padding-left:  15px;</span><br><span class="line">padding-right: 15px;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>固定布局</p>
<ul>
<li>容器的width会随设备分辨率的不同而生产变化<ul>
<li>分辨率阈值<ul>
<li>w &gt;=1200(lg 大屏pc)             容器的width为1170 （1140+槽宽）</li>
<li>1200&gt; w &gt;=992(md 中屏pc)        容器的width为970 （940+槽宽）</li>
<li>992 &gt; w &gt;=768(sm 平板)        容器的width为750 （720+槽宽）</li>
<li>768 &gt; w  (xs 移动手机)          容器的width为auto </li>
</ul>
</li>
</ul>
</li>
<li>源码：<ul>
<li>固定容器 特定样式<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">顺序不可变</span><br><span class="line">@media (min-width: @screen-sm-min) &#123;</span><br><span class="line">width: @container-sm;</span><br><span class="line">&#125;</span><br><span class="line">@media (min-width: @screen-md-min) &#123;</span><br><span class="line">width: @container-md;</span><br><span class="line">&#125;</span><br><span class="line">@media (min-width: @screen-lg-min) &#123;</span><br><span class="line">width: @container-lg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="栅格系统"><a href="#栅格系统" class="headerlink" title="栅格系统"></a>栅格系统</h2><ol>
<li><p>栅格系统<br> <img src="/2020/07/21/Bootstrap/%E6%A0%85%E6%A0%BC.png" alt></p>
<ul>
<li>按照不同屏幕划分为12等分</li>
<li>行（row）可以清除父容器的边距15px</li>
<li>列数大于12，会另起一行排列</li>
<li>可以同时为一列指定多个设备的类名，以便适应不同屏幕下划分不同的份数，例如：class=”col-xs-6 col-md-4”</li>
</ul>
</li>
<li><p>列嵌套</p>
<ul>
<li>简单的理解就是一行内分成若干个小块后，每一个小块还能再等分成12小块<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;col-xs-8 col-sm-6&quot;&gt;</span><br><span class="line">&#x2F;&#x2F;我们在列嵌套时最好加一个行row 这样可以取消父元素的padding值 而且高度自动和父级一样高</span><br><span class="line"> &lt;div class&#x3D;&quot;row&quot;&gt;</span><br><span class="line">   &lt;div class&#x3D;&quot;col-sm-6&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">   &lt;div class&#x3D;&quot;col-sm-6&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>列偏移</p>
<ul>
<li>使用 .col-md-offset-类可以将列向右侧(按份数)偏移。这些类实际是通过使用选*择器为当前元素增加了左侧的边距（margin）。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;row&quot;&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;col-md-4&quot;&gt;.col-md-4&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;col-md-4 col-md-offset-4&quot;&gt;.col-md-4 .col-md-offset-4&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>列排序</p>
<ul>
<li>通过使用 .col-md-push-* 和 .col-md-pull-* 类就可以很容易的改变列（column）的顺序。</li>
<li>push是将块向右推</li>
<li>pull是将块向左拉</li>
</ul>
</li>
</ol>
<h2 id="响应式工具"><a href="#响应式工具" class="headerlink" title="响应式工具"></a>响应式工具</h2><ul>
<li>通过单独或联合使用以下列出的类，可以针对不同屏幕尺寸隐藏或显示页面内容。<br><img src="/2020/07/21/Bootstrap/xiang.png" alt></li>
</ul>
<p><strong><em>现在暂时先了解这么多，bootstrap的精髓主要体现在栅格系统上，日后如果再用到其他东西再去<a href="https://v3.bootcss.com/css/" target="_blank" rel="noopener">bootstrap官方文档</a>查阅即可</em></strong></p>
]]></content>
      <categories>
        <category>前端三大块</category>
      </categories>
      <tags>
        <tag>Bootstrap</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>less</title>
    <url>/2020/07/21/less/</url>
    <content><![CDATA[<blockquote>
<p>序<br><br>less是一门css的预处理语言</p>
</blockquote>
<a id="more"></a>
<h1 id="less"><a href="#less" class="headerlink" title="less"></a>less</h1><ul>
<li>less是一门css的预处理语言<ul>
<li>less是一个css的增强版，通过less可以编写更少的代码实现更强大的样式</li>
<li>在less中添加了许多的新特性：像对变量的支持、对mixin的支持… …</li>
<li>less的语法大体上和css语法一致，但是less中增添了许多对css的扩展，<br>  所以浏览器无法直接执行less代码，要执行必须向将less转换为css，然后再由浏览器执行</li>
<li>在vscode中下载easy less插件，它可以将less准换成css，只需要.less和.css文件取相同的文件名即可</li>
</ul>
</li>
</ul>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul>
<li><p>变量，在变量中可以存储一个任意的值</p>
<ul>
<li><p>并且我们可以在需要时，任意的修改变量中的值</p>
</li>
<li><p>变量的语法： @变量名</p>
</li>
<li><p>作为变量时，如果是直接使用则以 @变量名 的形式使用即可</p>
</li>
<li><p>作为类名，或者一部分值使用时必须以 @{变量名} 的形式使用</p>
</li>
<li><p>变量发生重名时，会优先使用比较近的变量</p>
</li>
<li><p>可以在变量声明前就使用变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@a:200px;</span><br><span class="line">@b:#bfa;</span><br><span class="line">@c:box6;</span><br><span class="line">.box5&#123;</span><br><span class="line">  </span><br><span class="line">width: @a;</span><br><span class="line">color:@b;</span><br><span class="line">&#125;</span><br><span class="line">.@&#123;c&#125;&#123;</span><br><span class="line">width: @a;</span><br><span class="line">background-image: url(&quot;@&#123;c&#125;&#x2F;1.png&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2></li>
</ul>
</li>
<li><p>子元素选择器&gt;</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">less:</span><br><span class="line">.box1&#123;</span><br><span class="line">.box2&#123;&#125;</span><br><span class="line">&gt;.box3&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">css:</span><br><span class="line">.box1 .box2 &#123;&#125;</span><br><span class="line">.box1 &gt; .box3 &#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>&amp; 表示外层(只向外一层)的父元素</p>
</li>
<li><p>:extend() 对当前选择器扩展指定选择器的样式（选择器分组）</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">less:</span><br><span class="line">.p1&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 200px;</span><br><span class="line">&#125;</span><br><span class="line">.p2:extend(.p1)&#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">css:</span><br><span class="line">.p1,</span><br><span class="line">.p2 &#123;</span><br><span class="line">width: 100px;</span><br><span class="line">height: 200px;</span><br><span class="line">&#125;</span><br><span class="line">.p2 &#123;</span><br><span class="line">color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>mixin 混合</p>
<ul>
<li>直接对指定的样式进行引用，这里就相当于将p1的样式在这里进行了复制</li>
<li>使用类选择器时可以在选择器后边添加一个括号，这时我们实际上就创建了一个mixins<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">less:</span><br><span class="line">.p3&#123;</span><br><span class="line">.p1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p4()&#123;</span><br><span class="line">width: 100px;</span><br><span class="line">height: 100px;</span><br><span class="line">&#125;</span><br><span class="line">.p5&#123;</span><br><span class="line">    .p4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">css:</span><br><span class="line">.p3 &#123;</span><br><span class="line">width: 100px;</span><br><span class="line">height: 200px;</span><br><span class="line">&#125;</span><br><span class="line">.p5 &#123;</span><br><span class="line">width: 100px;</span><br><span class="line">height: 100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="混合函数"><a href="#混合函数" class="headerlink" title="混合函数"></a>混合函数</h2></li>
</ul>
</li>
<li><p>在混合函数中可以直接设置变量</p>
</li>
<li><p>还可以调用混合函数，按顺序传递参数</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">less:</span><br><span class="line">.test(@w:100px,@h:200px,@bg-color:red)&#123;</span><br><span class="line">width: @w;</span><br><span class="line">height: @h;</span><br><span class="line">border: 1px solid @bg-color;</span><br><span class="line">&#125;</span><br><span class="line">div&#123;</span><br><span class="line">.test(300px);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">css:</span><br><span class="line">div &#123;</span><br><span class="line">width: 300px;</span><br><span class="line">height: 200px;</span><br><span class="line">border: 1px solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>平均值average()可以设置颜色为参数，取两个颜色中间的颜色</p>
</li>
<li><p>加深颜色darken(颜色，百分比)</p>
</li>
</ul>
<h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><ul>
<li><p>@import用来将其他的less引入到当前的less</p>
</li>
<li><p>在less中所有的数值都可以直接进行运算</p>
</li>
<li><p>easy  less配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;less.compile&quot;: &#123;</span><br><span class="line">        &quot;compress&quot;:  true,  &#x2F;&#x2F; 是否压缩</span><br><span class="line">        &quot;sourceMap&quot;: true,  &#x2F;&#x2F; 生成源码地图使less文件和css一一对应，调试的时候直接对应到less中的位置</span><br><span class="line">        &quot;out&quot;: true, &#x2F;&#x2F; 生成css文件</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>前端三大块</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>less</tag>
      </tags>
  </entry>
  <entry>
    <title>axios</title>
    <url>/2020/07/25/axios/</url>
    <content><![CDATA[<blockquote>
<p>序<br><br>前端最流行的ajax请求库</p>
</blockquote>
<a id="more"></a>
<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><ul>
<li>MDN文档：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview</a></li>
</ul>
<h2 id="HTTP-请求交互的基本过程"><a href="#HTTP-请求交互的基本过程" class="headerlink" title="HTTP 请求交互的基本过程"></a>HTTP 请求交互的基本过程</h2><p><img src="/axios/http.png" alt></p>
<ol>
<li>前后应用从浏览器端向服务器发送 HTTP 请求(请求报文)</li>
<li>后台服务器接收到请求后, 调度服务器应用处理请求, 向浏览器端返回 HTTP<br>响应(响应报文)</li>
<li>浏览器端接收到响应, 解析显示响应体/调用监视回调</li>
</ol>
<h2 id="HTTP-请求报文"><a href="#HTTP-请求报文" class="headerlink" title="HTTP 请求报文"></a>HTTP 请求报文</h2><h3 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h3><ul>
<li>method </li>
<li>url</li>
</ul>
<h3 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h3><ul>
<li>Host: <a href="http://www.baidu.com主机" target="_blank" rel="noopener">www.baidu.com主机</a></li>
<li>Cookie: BAIDUID=AD3B0FA706E; BIDUPSID=AD3B0FA706;<ul>
<li>Cookie是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器</li>
</ul>
</li>
<li>Content-Type: application/x-www-form-urlencoded 或者 application/json<ul>
<li>告诉服务器请求体内容的类型</li>
</ul>
</li>
</ul>
<h3 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h3><ul>
<li>urlencoded格式：username=tom&amp;pwd=123</li>
<li>JSON格式：{“username”: “tom”, “pwd”: 123}</li>
</ul>
<h2 id="HTTP-响应报文"><a href="#HTTP-响应报文" class="headerlink" title="HTTP 响应报文"></a>HTTP 响应报文</h2><ol>
<li>响应状态行<ul>
<li>status statusText状态码</li>
</ul>
</li>
<li>多个响应头<ul>
<li>Content-Type: text/html;charset=utf-8 Set-Cookie: BD_CK_SAM=1;path=/</li>
</ul>
</li>
<li>响应体<ul>
<li>html 文本/json 文本/js/css/图片…</li>
</ul>
</li>
</ol>
<h2 id="post-请求体参数格式"><a href="#post-请求体参数格式" class="headerlink" title="post 请求体参数格式"></a>post 请求体参数格式</h2><ol>
<li>Content-Type: application/x-www-form-urlencoded;charset=utf-8<ul>
<li>用于键值对参数，参数的键值用=连接, 参数之间用&amp;连接</li>
<li>例如: name=%E5%B0%8F%E6%98%8E&amp;age=12</li>
</ul>
</li>
<li>Content-Type: application/json;charset=utf-8<ul>
<li>用于 json 字符串参数</li>
<li>例如: {“name”: “%E5%B0%8F%E6%98%8E”, “age”: 12}</li>
</ul>
</li>
<li>Content-Type: multipart/form-data<ul>
<li>用于文件上传请求</li>
</ul>
</li>
</ol>
<h2 id="常见的响应状态码"><a href="#常见的响应状态码" class="headerlink" title="常见的响应状态码"></a>常见的响应状态码</h2><table>
<thead>
<tr>
<th>状态码</th>
<th>提示信息</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td>OK</td>
<td>请求成功。一般用于 GET 与 POST 请求</td>
</tr>
<tr>
<td>201</td>
<td>Created</td>
<td>已创建。成功请求并创建了新的资源</td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized</td>
<td>未授权/请求要求用户的身份认证</td>
</tr>
<tr>
<td>404</td>
<td>Not Found</td>
<td>服务器无法根据客户端的请求找到资源</td>
</tr>
<tr>
<td>500</td>
<td>Internal Server Error</td>
<td>服务器内部错误，无法完成请求</td>
</tr>
</tbody></table>
<h2 id="不同类型的请求及其作用"><a href="#不同类型的请求及其作用" class="headerlink" title="不同类型的请求及其作用"></a>不同类型的请求及其作用</h2><ol>
<li>GET: 从服务器端读取数据</li>
<li>POST: 向服务器端添加新数据</li>
<li>PUT: 更新服务器端已经有的数据</li>
<li>DELETE: 删除服务器端数据</li>
</ol>
<h2 id="API-的分类"><a href="#API-的分类" class="headerlink" title="API 的分类"></a>API 的分类</h2><ol>
<li>REST API:restful<ul>
<li>发送请求进行 CRUD 哪个操作由请求方式来决定</li>
<li>同一个请求路径可以进行多个操作</li>
<li>请求方式会用到 GET/POST/PUT/DELETE</li>
</ul>
</li>
<li>非 REST API:restless<ul>
<li>请求方式不决定请求的 CRUD 操作</li>
<li>一个请求路径只对应一个操作</li>
<li>一般只有 GET/POST</li>
</ul>
</li>
</ol>
<h2 id="使用-json-server-搭建-REST-API"><a href="#使用-json-server-搭建-REST-API" class="headerlink" title="使用 json-server 搭建 REST API"></a>使用 json-server 搭建 REST API</h2><h3 id="json-server-是什么"><a href="#json-server-是什么" class="headerlink" title="json-server 是什么?"></a>json-server 是什么?</h3><ul>
<li>用来快速搭建 REST API 的工具包</li>
</ul>
<h3 id="使用-json-server"><a href="#使用-json-server" class="headerlink" title="使用 json-server"></a>使用 json-server</h3><ol>
<li>在线文档: <a href="https://github.com/typicode/json-server" target="_blank" rel="noopener">https://github.com/typicode/json-server</a></li>
<li>下载: npm install -g json-server</li>
<li>目标根目录下创建数据库 json 文件: db.json<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JSON数据：</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">&quot;posts&quot;: [</span><br><span class="line">&#123; &quot;id&quot;: 1, &quot;title&quot;: &quot;json-server&quot;, &quot;author&quot;: &quot;typicode&quot; &#125;</span><br><span class="line">],</span><br><span class="line">&quot;comments&quot;: [</span><br><span class="line">&#123; &quot;id&quot;: 1, &quot;body&quot;: &quot;some comment&quot;, &quot;postId&quot;: 1 &#125;</span><br><span class="line">],</span><br><span class="line">&quot;profile&quot;: &#123; &quot;name&quot;: &quot;typicode&quot; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>启动服务器执行命令: json-server –watch db.json</li>
</ol>
<h3 id="使用浏览器访问测试"><a href="#使用浏览器访问测试" class="headerlink" title="使用浏览器访问测试"></a>使用浏览器访问测试</h3><ul>
<li><p><a href="http://localhost:3000/posts" target="_blank" rel="noopener">http://localhost:3000/posts</a></p>
</li>
<li><p><a href="http://localhost:3000/posts/1" target="_blank" rel="noopener">http://localhost:3000/posts/1</a></p>
</li>
<li><p>代码实现：<a href="https://github.com/XieYaXv6/Learn-axios/blob/master/01_restapi.html" target="_blank" rel="noopener">https://github.com/XieYaXv6/Learn-axios/blob/master/01_restapi.html</a></p>
</li>
</ul>
<h1 id="XHR-的理解和使用"><a href="#XHR-的理解和使用" class="headerlink" title="XHR 的理解和使用"></a>XHR 的理解和使用</h1><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><ol>
<li>使用 XMLHttpRequest (XHR)对象可以与服务器交互, 也就是发送 ajax 请求</li>
<li>前端可以获取到数据，而无需让整个的页面刷新。</li>
<li>这使得 Web 页面可以只更新页面的局部，而不影响用户的操作。</li>
</ol>
<h2 id="区别一般-http-请求与-ajax-请求"><a href="#区别一般-http-请求与-ajax-请求" class="headerlink" title="区别一般 http 请求与 ajax 请求"></a>区别一般 http 请求与 ajax 请求</h2><ol>
<li>ajax 请求是一种特别的 http 请求</li>
<li>对服务器端来说, 没有任何区别, 区别在浏览器端</li>
<li>浏览器端发请求: 只有 XHR 或 fetch 发出的才是 ajax 请求, 其它所有的都是非 ajax 请求</li>
<li>浏览器端接收到响应<ul>
<li>一般请求: 浏览器一般会直接显示响应体数据, 也就是我们常说的刷新/ 跳转页面</li>
<li>ajax 请求: 浏览器不会对界面进行任何更新操作, 只是调用监视的回调函数并传入响应相关数据</li>
</ul>
</li>
</ol>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><ol>
<li>XMLHttpRequest(): 创建 XHR 对象的构造函数</li>
<li>status: 响应状态码值, 比如 200, 404</li>
<li>statusText: 响应状态文本</li>
<li>readyState: 标识请求状态的只读属性<ul>
<li>初始</li>
<li>open()之后</li>
<li>send()之后</li>
<li>请求中</li>
<li>请求完成</li>
</ul>
</li>
<li>onreadystatechange: 绑定 readyState 改变的监听</li>
<li>responseType: 指定响应数据类型, 如果是’json’, 得到响应后自动解析响应体数据</li>
<li>response: 响应体数据, 类型取决于 responseType 的指定</li>
<li>timeout: 指定请求超时时间, 默认为 0 代表没有限制</li>
<li>ontimeout: 绑定超时的监听</li>
<li>onerror: 绑定请求网络错误的监听</li>
<li>open(): 初始化一个请求, 参数为: (method, url[, async])</li>
<li>send(data): 发送请求</li>
<li>abort(): 中断请求</li>
<li>getResponseHeader(name): 获取指定名称的响应头值</li>
<li>getAllResponseHeaders(): 获取所有响应头组成的字符串</li>
<li>setRequestHeader(name, value): 设置请求头</li>
</ol>
<h2 id="XHR-的-ajax-封装-简单版-axios"><a href="#XHR-的-ajax-封装-简单版-axios" class="headerlink" title="XHR 的 ajax 封装(简单版 axios)"></a>XHR 的 ajax 封装(简单版 axios)</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>函数的返回值为 promise, 成功的结果为 response, 异常的结果为 error</li>
<li>能处理多种类型的请求: GET/POST/PUT/DELETE</li>
<li>函数的参数为一个配置对象<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">url: &#39;&#39;,	&#x2F;&#x2F; 请求地址</span><br><span class="line">method: &#39;&#39;,		&#x2F;&#x2F; 请求方式 GET&#x2F;POST&#x2F;PUT&#x2F;DELETE params: &#123;&#125;,	&#x2F;&#x2F; GET&#x2F;DELETE 请求的 query 参数data: &#123;&#125;, &#x2F;&#x2F; POST 或 DELETE 请求的请求体参数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>响应 json 数据自动解析为 js</li>
</ol>
<ul>
<li>代码实现：<a href="https://github.com/XieYaXv6/Learn-axios/blob/master/02_xhr.html" target="_blank" rel="noopener">https://github.com/XieYaXv6/Learn-axios/blob/master/02_xhr.html</a></li>
</ul>
<h1 id="axios-的理解和使用"><a href="#axios-的理解和使用" class="headerlink" title="axios 的理解和使用"></a>axios 的理解和使用</h1><h2 id="axios-是什么"><a href="#axios-是什么" class="headerlink" title="axios 是什么?"></a>axios 是什么?</h2><ol>
<li>前端最流行的 ajax 请求库</li>
<li>react/vue 官方都推荐使用 axios 发 ajax 请求</li>
<li>文档: <a href="https://github.com/axios/axios" target="_blank" rel="noopener">https://github.com/axios/axios</a></li>
</ol>
<h2 id="axios-特点"><a href="#axios-特点" class="headerlink" title="axios 特点"></a>axios 特点</h2><ol>
<li>基本 promise 的异步 ajax 请求库</li>
<li>浏览器端/node 端都可以使用</li>
<li>支持请求／响应拦截器</li>
<li>支持请求取消</li>
<li>请求/响应数据转换</li>
<li>批量发送多个请求</li>
</ol>
<h2 id="axios-常用语法"><a href="#axios-常用语法" class="headerlink" title="axios 常用语法"></a>axios 常用语法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- axios(config): 通用&#x2F;最本质的发任意类型请求的方式</span><br><span class="line">- axios(url[, config]): 可以只指定 url 发 get 请求</span><br><span class="line">- axios.request(config): 等 同 于 axios(config) </span><br><span class="line">- axios.get(url[, config]): 发 get 请求</span><br><span class="line">- axios.delete(url[, config]): 发 delete 请求</span><br><span class="line">- axios.post(url[, data, config]): 发 post 请求</span><br><span class="line">- axios.put(url[, data, config]): 发 put 请求 </span><br><span class="line"></span><br><span class="line">- axios.defaults.xxx: 请求的默认全局配置</span><br><span class="line">- axios.interceptors.request.use(): 添加请求拦截器</span><br><span class="line">- axios.interceptors.response.use(): 添加响应拦截器</span><br><span class="line"></span><br><span class="line">- axios.create([config]): 创建一个新的 axios(它没有下面的功能)</span><br><span class="line"></span><br><span class="line">- axios.Cancel(): 用于创建取消请求的错误对象</span><br><span class="line">- axios.CancelToken(): 用于创建取消请求的 token 对象</span><br><span class="line">- axios.isCancel(): 是否是一个取消请求的错误</span><br><span class="line">- axios.all(promises): 用于批量执行多个异步请求</span><br><span class="line">- axios.spread(): 用来指定接收所有成功数据的回调函数的方法</span><br></pre></td></tr></table></figure>

<h2 id="难点语法的理解和使用"><a href="#难点语法的理解和使用" class="headerlink" title="难点语法的理解和使用"></a>难点语法的理解和使用</h2><h3 id="axios-create-config"><a href="#axios-create-config" class="headerlink" title="axios.create(config)"></a>axios.create(config)</h3><ol>
<li>根据指定配置创建一个新的 axios, 也就就每个新 axios 都有自己的配置</li>
<li>新 axios 只是没有取消请求和批量发请求的方法, 其它所有语法都是一致的</li>
<li>为什么要设计这个语法?<ul>
<li>需求: 项目中有部分接口需要的配置与另一部分接口需要的配置不太一样, 如何处理</li>
<li>解决: 创建 2 个新 axios, 每个都有自己特有的配置, 分别应用到不同要求的接口请求中</li>
</ul>
</li>
</ol>
<h3 id="拦截器函数-ajax-请求-请求的回调函数的调用顺序"><a href="#拦截器函数-ajax-请求-请求的回调函数的调用顺序" class="headerlink" title="拦截器函数/ajax 请求/请求的回调函数的调用顺序"></a>拦截器函数/ajax 请求/请求的回调函数的调用顺序</h3><ol>
<li>说明: 调用 axios()并不是立即发送 ajax 请求, 而是需要经历一个较长的流程</li>
<li>流程: 请求拦截器2 =&gt; 请求拦截器1 =&gt; 发ajax 请求 =&gt; 响应拦截器1 =&gt;  响应拦截器 2 =&gt; 请求的回调</li>
<li>注意: 此流程是通过 promise 串连起来的, 请求拦截器传递的是 config, 响应拦截器传递的是 response</li>
</ol>
<h3 id="取消请求"><a href="#取消请求" class="headerlink" title="取消请求"></a>取消请求</h3><ol>
<li>基本流程</li>
</ol>
<ul>
<li>配置 cancelToken 对象</li>
<li>缓存用于取消请求的 cancel 函数</li>
<li>在后面特定时机调用 cancel 函数取消请求</li>
<li>在错误回调中判断如果 error 是 cancel, 做相应处理</li>
</ul>
<ol start="2">
<li>实现功能</li>
</ol>
<ul>
<li>点击按钮, 取消某个正在请求中的请求</li>
<li>在请求一个接口前, 取消前面一个未完成的请求</li>
<li>可以用请求拦截器统一取消发送请求前未完成的请求，并且保存取消函数；用响应拦截器对结果统一处理</li>
</ul>
<ul>
<li>源码：<a href="https://github.com/XieYaXv6/Learn-axios" target="_blank" rel="noopener">https://github.com/XieYaXv6/Learn-axios</a></li>
</ul>
]]></content>
      <categories>
        <category>axios</category>
      </categories>
      <tags>
        <tag>ajax</tag>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue</title>
    <url>/2020/07/22/Vue/</url>
    <content><![CDATA[<blockquote>
<p>序<br><br>中国最火的一套构建用户界面的渐进式框架</p>
</blockquote>
<a id="more"></a>
<h1 id="Vue基本认识"><a href="#Vue基本认识" class="headerlink" title="Vue基本认识"></a>Vue基本认识</h1><p><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">中文官网</a></p>
<h2 id="Vue特点"><a href="#Vue特点" class="headerlink" title="Vue特点"></a>Vue特点</h2><ol>
<li>遵循MVVM模式</li>
<li>编码简洁,体积小,运行效率高,适合移动/PC端开发</li>
<li>它本身只关注UI,可以轻松引入vue插件或其它第三库开发项目</li>
</ol>
<h2 id="Vue扩展插件"><a href="#Vue扩展插件" class="headerlink" title="Vue扩展插件"></a>Vue扩展插件</h2><ol>
<li>vue-cli:vue脚手架</li>
<li>vue-resource(axios):ajax请求</li>
<li>vue-router:路由</li>
<li>vuex:状态管理</li>
<li>vue-lazyload:图片懒加载</li>
<li>vue-scroller:页面滑动相关</li>
<li>mint-ui:基于vue的UI组件库(移动端)</li>
<li>element-ui:基于vue的UI组件库(PC端)</li>
</ol>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 引入vue.js</span><br><span class="line">2. 创建Vue实例对象(vm),指定选项(配置)对象</span><br><span class="line">    * el:指定dom标签容器的选择器</span><br><span class="line">    * data:指定初始化状态数据的对象&#x2F;函数,返回一个对象</span><br><span class="line">3. 在页面模板中使用&#123;&#123;&#125;&#125;或vue指令</span><br></pre></td></tr></table></figure>

<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p><img src="/2020/07/22/Vue/mvvm.png" alt></p>
<ul>
<li>model: 模型，数据对象data</li>
<li>view：视图，模板页面</li>
<li>viewmodel：实体模型，vue的实例</li>
</ul>
<h2 id="vue指令"><a href="#vue指令" class="headerlink" title="vue指令"></a>vue指令</h2><h3 id="v-text-v-html-指定标签体"><a href="#v-text-v-html-指定标签体" class="headerlink" title="v-text/v-html: 指定标签体"></a>v-text/v-html: 指定标签体</h3><ul>
<li>v-text : 当作纯文本</li>
<li>v-html : 将value作为html标签来解析</li>
</ul>
<h3 id="v-if-v-else-v-show-显示-隐藏元素"><a href="#v-if-v-else-v-show-显示-隐藏元素" class="headerlink" title="v-if v-else v-show: 显示/隐藏元素"></a>v-if v-else v-show: 显示/隐藏元素</h3><ul>
<li>v-if : 如果vlaue为true, 当前标签会输出在页面中</li>
<li>v-else : 与v-if一起使用, 如果value为false, 将当前标签输出到页面中</li>
<li>v-show: 就会在标签中添加display样式, 如果vlaue为true, display=block, 否则是none</li>
</ul>
<h3 id="v-for-遍历"><a href="#v-for-遍历" class="headerlink" title="v-for : 遍历"></a>v-for : 遍历</h3><ul>
<li>遍历数组 : v-for=”(person, index) in persons”   </li>
<li>遍历对象 : v-for=”value in person”   $key</li>
<li>变异方法：vue对原生js中数组的方法进行了重新的定义，vue中的数组方法加上了监听，所以会触发视图的更新</li>
</ul>
<h3 id="v-on-绑定事件监听"><a href="#v-on-绑定事件监听" class="headerlink" title="v-on : 绑定事件监听"></a>v-on : 绑定事件监听</h3><ul>
<li>v-on:事件名, 可以缩写为: @事件名</li>
<li>监视具体的按键: @keyup.keyCode   @keyup.enter只有少数的按键才有</li>
<li>停止事件的冒泡和阻止事件默认行为: @click.stop   @click.prevent</li>
<li>隐含对象: $event就代表事件对象，可以通过event.target获取对象属性</li>
</ul>
<h3 id="v-bind-强制绑定解析表达式"><a href="#v-bind-强制绑定解析表达式" class="headerlink" title="v-bind : 强制绑定解析表达式"></a>v-bind : 强制绑定解析表达式</h3><ul>
<li>html标签属性是不支持表达式的, 就可以使用v-bind</li>
<li>可以缩写为:  :id=’name’</li>
<li>:class<ul>
<li>:class=”a”字符串</li>
<li>:class=”{classA : isA, classB : isB}”对象</li>
<li>:class=”[classA, classB]”数组</li>
</ul>
</li>
<li>:style<ul>
<li>:style=”{color : color}”</li>
</ul>
</li>
</ul>
<h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><ul>
<li>双向数据绑定</li>
<li>自动收集用户输入数据</li>
</ul>
<h3 id="ref-标识某个标签"><a href="#ref-标识某个标签" class="headerlink" title="ref : 标识某个标签"></a>ref : 标识某个标签</h3><ul>
<li>ref=’xxx’</li>
<li>读取得到标签对象: this.$refs.xxx</li>
</ul>
<h3 id="v-cloak-防止闪现-与css配合在解析之前匹配一个标签，解析后就不存在了-v-cloak-display-none"><a href="#v-cloak-防止闪现-与css配合在解析之前匹配一个标签，解析后就不存在了-v-cloak-display-none" class="headerlink" title="v-cloak:防止闪现,与css配合在解析之前匹配一个标签，解析后就不存在了:[v-cloak]{display:none}"></a>v-cloak:防止闪现,与css配合在解析之前匹配一个标签，解析后就不存在了:[v-cloak]{display:none}</h3><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><ol>
<li>注册全局指令<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.directive(&#39;my-directive&#39;,function(el,binding)&#123; </span><br><span class="line">    &#x2F;&#x2F;指令名v-省略，el：指令属性所在的标签对象，binding:包含指令相关信息数据的对象</span><br><span class="line">    el.innerHTML&#x3D;binding.value.toupperCase()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>注册局部指令<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">directives:&#123;</span><br><span class="line">&#39;my-directive&#39;:&#123;</span><br><span class="line">    bind(el,binding)&#123;</span><br><span class="line">        el.innerHTML&#x3D;binding.value.toupperCase()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用指令<br>v-my-directive=’xxx</li>
</ol>
<h3 id="自定义插件"><a href="#自定义插件" class="headerlink" title="自定义插件"></a>自定义插件</h3><ul>
<li>Vue插件是一个包含install方法的对象</li>
<li>通过install方法给Vue或Vue实例添加方法,定义全局指令等<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">举例： </span><br><span class="line">(function (window) &#123;</span><br><span class="line">  const MyPlugin &#x3D; &#123;&#125;</span><br><span class="line">  MyPlugin.install &#x3D; function (Vue, options) &#123;</span><br><span class="line">    &#x2F;&#x2F; 1. 添加全局方法或属性</span><br><span class="line">    Vue.myGlobalMethod &#x3D; function () &#123;</span><br><span class="line">      console.log(&#39;Vue函数对象的myGlobalMethod()&#39;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 2. 添加全局资源</span><br><span class="line">    Vue.directive(&#39;my-directive&#39;,function (el, binding) &#123;</span><br><span class="line">      el.textContent &#x3D; &#39;my-directive----&#39;+binding.value</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 3. 添加实例方法</span><br><span class="line">    Vue.prototype.$myMethod &#x3D; function () &#123;</span><br><span class="line">      console.log(&#39;vm $myMethod()&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    &#x2F;&#x2F; 4. 向外暴露</span><br><span class="line">  window.MyPlugin &#x3D; MyPlugin</span><br><span class="line">&#125;)(window)</span><br><span class="line"></span><br><span class="line">调用：</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;vue-myPlugin.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 声明使用插件(安装插件: 调用插件的install())</span><br><span class="line">  Vue.use(MyPlugin) &#x2F;&#x2F; 内部会调用插件对象的install()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Vue对象"><a href="#Vue对象" class="headerlink" title="Vue对象"></a>Vue对象</h2><h3 id="el"><a href="#el" class="headerlink" title="el"></a>el</h3><ul>
<li>指定dom标签容器的选择器</li>
<li>Vue就会管理对应的标签及其子标签</li>
</ul>
<h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><ul>
<li>对象或函数类型</li>
<li>指定初始化状态属性数据的对象</li>
<li>vm也会自动拥有data中所有属性</li>
<li>页面中可以直接访问使用</li>
<li>数据代理: 由vm对象来代理对data中所有属性的操作(读/写)</li>
</ul>
<h3 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h3><ul>
<li>包含多个方法的对象</li>
<li>供页面中的事件指令来绑定回调</li>
<li>回调函数默认有event参数, 但也可以指定自己的参数</li>
<li>所有的方法由vue对象来调用,访问data中的属性直接使用this.xxx</li>
</ul>
<h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><ul>
<li>包含多个方法的对象</li>
<li>对状态属性进行计算返回一个新的数据, 供页面获取显示</li>
<li>一般情况下是相当于是一个只读的属性</li>
<li>利用get/set方法来实现属性数据的计算读取, 同时监视属性数据的变化</li>
<li>如何给对象定义get/set属性<ul>
<li>在创建对象时指定: get name () {return xxx} / set name (value) {}</li>
<li>对象创建之后指定: Object.defineProperty(obj, age, {get(){}, set(value){}})</li>
</ul>
</li>
</ul>
<h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><ul>
<li>包含多个属性监视的对象</li>
<li>分为一般监视和深度监视<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    &#39;xxx&#39; : &#123;</span><br><span class="line">        deep : true,</span><br><span class="line">        handler : fun(value)</span><br><span class="line">    &#125;</span><br><span class="line">另一种添加监视方式: vm.$watch(&#39;xxx&#39;, funn)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Vue实例的生命周期"><a href="#Vue实例的生命周期" class="headerlink" title="Vue实例的生命周期"></a>Vue实例的生命周期</h2><p><img src="/2020/07/22/Vue/live.png" alt></p>
<ul>
<li>大致分为三个阶段：<ol>
<li>初始化显示<ul>
<li>beforeCreate()</li>
<li>created()</li>
<li>beforeMount()</li>
<li>mounted()<br>2) 更新状态:this.xxx=value</li>
<li>beforeUpdate()</li>
<li>updated()<br>3) 销毁vue实例:vm.$destory()</li>
<li>beforeDestory()</li>
<li>destoryed()</li>
</ul>
</li>
</ol>
</li>
</ul>
<ul>
<li>主要的生命周期函数(钩子)<ul>
<li>created() / mounted(): 启动异步任务(启动定时器,发送ajax请求, 绑定监听)</li>
<li>beforeDestroy(): 做一些收尾的工作,如：清除定时器</li>
</ul>
</li>
</ul>
<h2 id="过渡-amp-动画"><a href="#过渡-amp-动画" class="headerlink" title="过渡&amp;动画"></a>过渡&amp;动画</h2><ul>
<li>利用vue去操控css的transition/animation动画</li>
<li>模板: 使用<transition name="xxx">包含带动画的标签<ul>
<li>css样式<ul>
<li>.fade-enter-active: 进入过程, 指定进入的transition</li>
<li>.fade-leave-active: 离开过程, 指定离开的transition</li>
<li>.xxx-enter, .xxx-leave-to: 指定隐藏的样式<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">编码例子</span><br><span class="line">       &#x2F;&#x2F;显示隐藏时的过渡效果</span><br><span class="line">    .xxx-enter-active, .xxx-leave-active &#123;</span><br><span class="line">      transition: opacity .5s</span><br><span class="line">    &#125;</span><br><span class="line">       &#x2F;&#x2F;隐藏时的样式</span><br><span class="line">    .xxx-enter, .xxx-leave-to &#123;</span><br><span class="line">      opacity: 0</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &lt;transition name&#x3D;&quot;xxx&quot;&gt;</span><br><span class="line">      &lt;p v-if&#x3D;&quot;show&quot;&gt;hello&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;transition&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</transition></li>
</ul>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><ul>
<li>功能:对要显示的数据进行特定格式化后再显示</li>
<li>注意:并没有改变原本的数据,可是产生新的对应的数据</li>
</ul>
<ol>
<li>定义过滤器 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.filter(filterName,function(value[,arg1,arg2,...])&#123;</span><br><span class="line">&#x2F;&#x2F;进行一定的数据处理</span><br><span class="line">return newValue</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>使用过滤器 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;&#123;&#123;myData|filterName&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div&gt;&#123;&#123;myData|filterName(arg)&#125;&#125;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
 vue init webpack-simple vue_demo –offline</li>
</ol>
<h1 id="vue组件化编码"><a href="#vue组件化编码" class="headerlink" title="vue组件化编码"></a>vue组件化编码</h1><h2 id="创建vue项目"><a href="#创建vue项目" class="headerlink" title="创建vue项目"></a>创建vue项目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm init webpack vue_demo</span><br><span class="line">cd vue_demo</span><br><span class="line">npm install</span><br><span class="line">npm run dev</span><br><span class="line">访问:http:&#x2F;&#x2F;localhost:8080&#x2F;</span><br></pre></td></tr></table></figure>
<h2 id="模板项目的结构"><a href="#模板项目的结构" class="headerlink" title="模板项目的结构"></a>模板项目的结构</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|--build: webpack相关的配置文件夹(基本不需要修改)</span><br><span class="line">    |--dev-server.js:通过express启动后台服务器</span><br><span class="line">|--config:webpack相关的配置文件夹(基本不需要修改)</span><br><span class="line">    |--index.js:指定的后台服务的端口号和静态资源文件夹</span><br><span class="line">|--node_modules</span><br><span class="line">|--src:源码文件夹</span><br><span class="line">    |--components:vue组件及其相关资源文件夹</span><br><span class="line">    |--App.vue:应用根主组件</span><br><span class="line">    |--main.js:应用入口js</span><br><span class="line">|--static:静态资源文件夹</span><br><span class="line">|--.babelrc:babel的配置文件</span><br><span class="line">|--.eslintignore:eslint检查忽略的配置</span><br><span class="line">|--.eslintrc.js:eslint检查的配置</span><br><span class="line">|--.gitignore:git版本管制忽略的配置</span><br><span class="line">|--index.html:主页面文件</span><br><span class="line">|--package.json:应用包配置文件</span><br><span class="line">|--README.md:应用描述说明的readme文件</span><br></pre></td></tr></table></figure>
<h2 id="项目的打包"><a href="#项目的打包" class="headerlink" title="项目的打包"></a>项目的打包</h2><ul>
<li>npm run build</li>
<li>发布：<ol>
<li>使用静态服务器工具包<ul>
<li>npm install -g serve</li>
<li>serve dist </li>
<li>访问：localhost:5000</li>
</ul>
</li>
<li>使用动态web服务器（tomcat）<ul>
<li>配置webpack.prod.conf.js<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">output:&#123;</span><br><span class="line">  publicPath:&#39;打包文件夹名称&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>重新打包npm run build</li>
<li>修改dist文件夹名称</li>
<li>将dist文件夹复制到tomcat的webpack下</li>
<li>启动tomcat–&gt;startup</li>
<li>访问：localhost：8080</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="eslint"><a href="#eslint" class="headerlink" title="eslint"></a>eslint</h2><p>1)    ESLint 是一个代码规范检查工具<br>2)    它定义了很多特定的规则, 一旦你的代码违背了某一规则, eslint 会作出非常有用的提示<br>3)    官网: <a href="http://eslint.org/" target="_blank" rel="noopener">http://eslint.org/</a><br>4)    基本已替代以前的 JSLint</p>
<h3 id="ESLint-提供以下支持"><a href="#ESLint-提供以下支持" class="headerlink" title="ESLint 提供以下支持"></a>ESLint 提供以下支持</h3><p>1)    ES<br>2)    JSX<br>3)    style 检查<br>4)    自定义错误和提示</p>
<h3 id="ESLint-提供以下几种校验"><a href="#ESLint-提供以下几种校验" class="headerlink" title="ESLint 提供以下几种校验"></a>ESLint 提供以下几种校验</h3><p>1)    语法错误校验<br>2)    不重要或丢失的标点符号，如分号<br>3)    没法运行到的代码块（使用过 WebStorm 的童鞋应该了解）<br>4)    未被使用的参数提醒<br>5)    确保样式的统一规则，如 sass 或者 less<br>6)    检查变量的命名</p>
<h2 id="组件的定义和使用"><a href="#组件的定义和使用" class="headerlink" title="组件的定义和使用"></a>组件的定义和使用</h2><h3 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">页面模板</span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">JS 模块对象</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123; </span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;&#125;</span><br><span class="line">    &#125;, </span><br><span class="line">  methods: &#123;&#125;,</span><br><span class="line">  computed: &#123;&#125;, </span><br><span class="line">  components: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">样式</span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>
<h3 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;HelloWorld&gt;&lt;&#x2F;HelloWorld&gt; &#x2F;&#x2F;使用组件标签</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import HelloWorld from &#39;.&#x2F;components&#x2F;HelloWorld&#39; &#x2F;&#x2F;引入组件</span><br><span class="line">export default &#123;</span><br><span class="line">components: &#123; </span><br><span class="line">  HelloWorld          &#x2F;&#x2F;映射成标签</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a><strong>组件间通信</strong></h2><p>1)    不要在子组件中直接修改父组件的状态数据<br>2)    数据在哪, 更新数据的行为(函数)就应该定义在哪</p>
<h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><ol>
<li>父组件使用组件标签<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;my-component name&#x3D;&#39;tom&#39; :age&#x3D;&#39;3&#39; :set-name&#x3D;&#39;setName&#39;&gt;&lt;&#x2F;my-component&gt;</span><br><span class="line">需要动态的数据的时候，可以用属性绑定的形式设置，此时数据来自父组件data中的数据，传的值可以是数字、对象、数组等等</span><br></pre></td></tr></table></figure></li>
<li>子组件定义component<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在组件内声明所有的 props</span><br><span class="line"></span><br><span class="line">方式一: 只指定名称</span><br><span class="line">props: [&#39;name&#39;, &#39;age&#39;, &#39;setName&#39;]</span><br><span class="line"></span><br><span class="line">方式二: 指定名称和类型</span><br><span class="line">props: &#123;</span><br><span class="line">name: String, age: Number,</span><br><span class="line">setNmae: Function</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">方式三: 指定名称&#x2F;类型&#x2F;必要性&#x2F;默认值</span><br><span class="line">props: &#123;</span><br><span class="line">name: &#123;type: String, required: true, default:xxx&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
1)    此方式用于<strong>父组件向子组件传递数据</strong></li>
</ol>
<p>2)    所有标签属性都会成为组件对象的属性, 模板页面可以直接引用</p>
<p>3)    问题:</p>
<ul>
<li>如果需要向非子后代传递数据必须多层逐层传递</li>
<li>兄弟组件间也不能直接 props 通信, 必须借助父组件才可以</li>
</ul>
<h3 id="vue自定义事件"><a href="#vue自定义事件" class="headerlink" title="vue自定义事件"></a>vue自定义事件</h3><ol>
<li>绑定事件监听<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 方式一: 通过 v-on 绑定</span><br><span class="line">@delete_todo&#x3D;&quot;deleteTodo&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 方 式 二 : 通 过 $on() </span><br><span class="line">this.$refs.xxx.$on(&#39;delete_todo&#39;, function (todo) &#123;</span><br><span class="line">this.deleteTodo(todo)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>触发事件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 触发事件(只能在父组件中接收) </span><br><span class="line">this.$emit(eventName, data)</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><p>此方式只用于<strong>子组件向父组件发送消息(数据)</strong></p>
</li>
<li><p>问题: 隔代组件或兄弟组件间通信此种方式不合适</p>
</li>
</ul>
<h3 id="消息订阅与发布-PubSubJS-库"><a href="#消息订阅与发布-PubSubJS-库" class="headerlink" title="消息订阅与发布(PubSubJS 库)"></a>消息订阅与发布(PubSubJS 库)</h3><ol>
<li>订阅消息<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">绑定事件监听 (订阅消息)</span><br><span class="line">目标:  标签元素	&lt;button&gt; </span><br><span class="line">事件名(类型): click&#x2F;focus </span><br><span class="line">回调函数: function(event)&#123;&#125;</span><br><span class="line"></span><br><span class="line">PubSub.subscribe(&#39;msg&#39;, function(msg, data)&#123;&#125;)</span><br></pre></td></tr></table></figure></li>
<li>发布消息<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">触发事件 (发布消息)</span><br><span class="line">DOM 事件: 用户在浏览器上对应的界面上做对应的操作</span><br><span class="line">自定义: 编码手动触发</span><br><span class="line"></span><br><span class="line">PubSub.publish(&#39;msg&#39;, data)</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>优点: 此方式可实现<strong>任意关系组件间通信(数据)</strong></li>
</ul>
<h3 id="slot-插槽"><a href="#slot-插槽" class="headerlink" title="slot(插槽)"></a>slot(插槽)</h3><ul>
<li>此方式用于父组件向子组件传递<code>标签数据</code></li>
</ul>
<ol>
<li>子组件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;slot name&#x3D;&quot;xxx&quot;&gt;不确定的标签结构 1&lt;&#x2F;slot&gt;</span><br><span class="line">&lt;div&gt;组件确定的标签结构&lt;&#x2F;div&gt;</span><br><span class="line">&lt;slot name&#x3D;&quot;yyy&quot;&gt;不确定的标签结构 2&lt;&#x2F;slot&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure></li>
<li>父组件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;child&gt;</span><br><span class="line">&lt;div slot&#x3D;&quot;xxx&quot;&gt;xxx 对应的标签结构&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div slot&#x3D;&quot;yyy&quot;&gt;yyyy 对应的标签结构&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;child&gt;</span><br></pre></td></tr></table></figure>
<h1 id="Vue-ajax"><a href="#Vue-ajax" class="headerlink" title="Vue-ajax"></a>Vue-ajax</h1><h2 id="vue-resource"><a href="#vue-resource" class="headerlink" title="vue-resource"></a>vue-resource</h2></li>
</ol>
<ul>
<li>vue 插件, 非官方库, vue1.x 使用广泛</li>
<li><a href="https://github.com/pagekit/vue-resource/blob/develop/docs/http.md" target="_blank" rel="noopener">在线文档</a></li>
</ul>
<ol>
<li>下载<ul>
<li>npm install vue-resource –save</li>
</ul>
</li>
<li>使用 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 引入模块</span><br><span class="line">import VueResource from &#39;vue-resource&#39;</span><br><span class="line">&#x2F;&#x2F; 使用插件</span><br><span class="line">Vue.use(VueResource)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 通过 vue&#x2F;组件对象发送 ajax 请求</span><br><span class="line">this.$http.get(&#39;&#x2F;someUrl&#39;).then((response) &#x3D;&gt; &#123;</span><br><span class="line">&#x2F;&#x2F; success callback console.log(response.data) &#x2F;&#x2F;返回结果数据</span><br><span class="line">&#125;, (response) &#x3D;&gt; &#123;</span><br><span class="line">console.log(response.statusText) &#x2F;&#x2F;错误信息</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><ul>
<li>通用的 ajax 请求库, 官方推荐, vue2.x 使用广泛</li>
<li><a href="https://github.com/pagekit/vue-resource/blob/develop/docs/http.md" target="_blank" rel="noopener">在线文档</a></li>
</ul>
<ol>
<li><p>下载</p>
<ul>
<li>npm install axios –save</li>
</ul>
</li>
<li><p>使用</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 引入模块</span><br><span class="line">import axios from &#39;axios&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 发送 ajax 请求</span><br><span class="line">axios.get(url)</span><br><span class="line">.then(response &#x3D;&gt; &#123;</span><br><span class="line">console.log(response.data) &#x2F;&#x2F; 得到返回结果数据</span><br><span class="line">&#125;)</span><br><span class="line">.catch(error &#x3D;&gt; &#123; console.log(error.message)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="Vue-router"><a href="#Vue-router" class="headerlink" title="Vue-router"></a>Vue-router</h1><ul>
<li>路由的本质就是一种对应关系，比如说url地址和资源之间的对应关系</li>
</ul>
<ol>
<li><p>SPA</p>
<ul>
<li>单页面应用程序（single page application）：整个网站只有一个页面，内容的变化通过Ajax局部更新实现，同时支持浏览器地址栏前进后退操作</li>
<li>SPA实现原理之一：基于URl地址的hash（hash的变化会导致浏览器记录访问历史的变化，但是hash的变化不会触发新的url请求）</li>
<li>在SPA的实现过程中，最核心的技术点就是前端路由</li>
</ul>
</li>
<li><p>前端路由</p>
<ul>
<li>概念：根据不同的用户事件，显示不同的页面内容</li>
<li>本质：用户事件与事件处理函数之间的对应关系<br><img src="/2020/07/22/Vue/qian.png" alt></li>
</ul>
</li>
</ol>
<h2 id="router基本使用步骤"><a href="#router基本使用步骤" class="headerlink" title="router基本使用步骤"></a>router基本使用步骤</h2><ol>
<li><p>先创建路由器模块（定义路由组件）</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 路由器模块</span><br><span class="line">import Vue from &#39;vue&#39; </span><br><span class="line">import VueRouter from &#39;vue-router&#39; </span><br><span class="line">import About from &#39;.&#x2F;components&#x2F;About.vue&#39;</span><br><span class="line">import Home from &#39;.&#x2F;components&#x2F;Home.vue&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;挂载属性</span><br><span class="line">Vue.use(VueResource)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建路由对象并配置路由规则</span><br><span class="line">export default new VueRouter(&#123; routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#39;&#x2F;&#39;, redirect: &#39;&#x2F;about&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#39;&#x2F;about&#39;, component: About</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#39;&#x2F;home&#39;, component: Home</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在main.js引入路由模块</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39; </span><br><span class="line">import router from&#39;.&#x2F;router&#39;  &#x2F;&#x2F;引入路由器模块</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建 vue 配置路由器</span><br><span class="line">new Vue(&#123;</span><br><span class="line">el: &#39;#app&#39;, </span><br><span class="line">router:router,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用路由</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">&lt;!--路由链接--&gt;</span><br><span class="line">&lt;router-link    to&#x3D;&quot;&#x2F;about&quot;&gt;About&lt;&#x2F;router-link&gt;</span><br><span class="line">&lt;router-link to&#x3D;&quot;&#x2F;home&quot;&gt;Home&lt;&#x2F;router-link&gt;</span><br><span class="line">&lt;!--用于渲染当前路由组件--&gt;</span><br><span class="line">&lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="路由重定向redirect"><a href="#路由重定向redirect" class="headerlink" title="路由重定向redirect"></a>路由重定向redirect</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;routes是路由规则数组</span><br><span class="line">routes: [</span><br><span class="line">    &#x2F;&#x2F;path设置为&#x2F;表示页面最初始的地址 &#x2F; ,redirect表示要被重定向的新地址，设置为一个路由即可</span><br><span class="line">    &#123; path:&quot;&#x2F;&quot;,redirect:&quot;&#x2F;user&quot;&#125;,</span><br><span class="line">    &#123; path: &quot;&#x2F;user&quot;, component: User &#125;,</span><br><span class="line">    &#123; path: &quot;&#x2F;login&quot;, component: Login &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h2><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">实现步骤:</span><br><span class="line">A.更改现有的路由模板：(在模板中添加子级路由链接以及占位符)</span><br><span class="line">var Login &#x3D; &#123; template: &#96;&lt;div&gt;</span><br><span class="line">        &lt;router-link to&#x3D;&quot;&#x2F;login&#x2F;account&quot;&gt;账号密码登录&lt;&#x2F;router-link&gt;</span><br><span class="line">        &lt;router-link to&#x3D;&quot;&#x2F;login&#x2F;phone&quot;&gt;扫码登录&lt;&#x2F;router-link&gt;</span><br><span class="line">        &lt;!-- 子路由组件将会在router-view中显示 --&gt;</span><br><span class="line">        &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;&#96; &#125;</span><br><span class="line"></span><br><span class="line">B.使用children添加子级路由规则：</span><br><span class="line">var myRouter &#x3D; new VueRouter(&#123;</span><br><span class="line">        routes: [</span><br><span class="line">            &#123;   path: &quot;&#x2F;login&quot;, component: Login,</span><br><span class="line">                &#x2F;&#x2F;通过children属性为&#x2F;login添加子路由规则</span><br><span class="line">                children:[</span><br><span class="line">                    &#123; path: &quot;&#x2F;login&#x2F;account&quot;, component: account &#125;,</span><br><span class="line">                    &#123; path: &quot;&#x2F;login&#x2F;phone&quot;, component: phone &#125;,</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></code></pre><h2 id="向路由组件传参数"><a href="#向路由组件传参数" class="headerlink" title="向路由组件传参数"></a>向路由组件传参数</h2><ol>
<li><p>方式一：路由路径携带参数(param/query)</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$route.params</span><br><span class="line"></span><br><span class="line">配置路由组件</span><br><span class="line">children: [</span><br><span class="line">&#123;path: &#39;mdetail&#x2F;:id&#39;, component: MessageDetail&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">配置路由链接</span><br><span class="line">&lt;router-link :to&#x3D;&quot;&#39;&#x2F;home&#x2F;message&#x2F;mdetail&#x2F;$&#123;message.id&#125;&#39;&quot;&gt;&#123;&#123;m.title&#125;&#125;&lt;&#x2F;router-link&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式二：通过props获取参数</p>
</li>
</ol>
<ul>
<li><p>动态参数</p>
</li>
<li><p>A.我们可以将props属性设置为true来传递参数，route.params将会被设置为组件属性，那么组件可以通过props接收route.params</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">routes:[</span><br><span class="line">      &#123;path: &#39;mdetail&#x2F;:id&#39;, component: MessageDetail,props:true &#125;</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">props:[&#39;id&#39;]</span><br><span class="line">&lt;router-link :to&#x3D;&quot;&#39;&#x2F;home&#x2F;message&#x2F;mdetail&#x2F;message.id&#39;&quot;&gt;&#123;&#123;m.title&#125;&#125;&lt;&#x2F;router-link&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>静态参数</p>
</li>
<li><p>B.可以将props属性设置为一个对象，那么组件可以通过props接收对象的数据</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">routes:[</span><br><span class="line">      &#123;path: &#39;mdetail&#x2F;:id&#39;, component: MessageDetail, props:&#123;name : &#39;xxx&#39; ,age:12&#125;&#125;</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">props:[&#39;name&#39;,&#39;age&#39;],</span><br><span class="line">&lt;div&gt;&#123;&#123;name+age&#125;&#125;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>动静结合</p>
</li>
<li><p>C. 还可以将props属性设置为一个函数，那么就可以同时将参数数据以及对象数据传递给组件</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">routes:[</span><br><span class="line">      &#123;path: &#39;mdetail&#x2F;:id&#39;, component: MessageDetail, props:&#123;name : &#39;xxx&#39; ,age:12, id &#x3D; router.params.id&#125;&#125;</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">props:[&#39;name&#39;,&#39;age&#39;,&#39;id&#39;],</span><br><span class="line">&lt;div&gt;&#123;&#123;name+age+id&#125;&#125;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="3">
<li>方式三：&lt; router-view &gt;属性携带数据 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">router-view :msg&#x3D;&quot;msg&quot;&gt;&lt;&#x2F;router-view&gt;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="缓存路由组件对象"><a href="#缓存路由组件对象" class="headerlink" title="缓存路由组件对象"></a>缓存路由组件对象</h2><p>1)    默认情况下, 被切换的路由组件对象会死亡释放, 再次回来时是重新创建的<br>2)    如果可以缓存路由组件对象, 可以提高用户体验<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">&lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">&lt;&#x2F;keep-alive&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h2><ul>
<li>可以使用name属性给路由设置别名</li>
</ul>
<h2 id="编程式路由导航"><a href="#编程式路由导航" class="headerlink" title="编程式路由导航"></a>编程式路由导航</h2><ol>
<li>声明式导航：通过点击链接的方式实现的导航&lt; router-link &gt;</li>
<li>编程式导航：调用js的api方法实现导航 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.$router.push(path): 相当于点击路由链接(可以返回到当前路由界面)</span><br><span class="line"></span><br><span class="line">this.$router.replace(path): 用新路由替换当前路由(不可以返回到当前路由界面)</span><br><span class="line"></span><br><span class="line">this.$router.back(): 请求(返回)上一个记录路由</span><br><span class="line"></span><br><span class="line">this.$router.go(-1): 请求(返回)上一个记录路由</span><br><span class="line"></span><br><span class="line">this.$router.go(1): 请求下一个记录路由</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h1><ul>
<li><p><a href="https://vuex.vuejs.org/zh-cn/" target="_blank" rel="noopener">vuex官方文档</a></p>
</li>
<li><p>vuex是实现组件全局状态（数据）管理的一种机制，可以方便的实现组件之间的数据共享<br><img src="/2020/07/22/Vue/store.png" alt></p>
</li>
<li><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式</p>
</li>
<li><p>这个状态自管理应用包含以下几个部分：</p>
<ul>
<li>state，驱动应用的数据源</li>
<li>view，以声明方式将 state 映射到视图</li>
<li>actions，响应在 view 上的用户输入导致的状态变化(包含 n 个更新状态的方法)<br><img src="/2020/07/22/Vue/3.png" alt></li>
</ul>
</li>
<li><p>核心思想(工作流程)：<br>  <img src="/2020/07/22/Vue/x.png" alt></p>
</li>
<li><p>使用vuex的好处：</p>
<ol>
<li>能够在vuex中集中管理共享的数据，易于开发和后期维护</li>
<li>能够高效的实现组件之间的数据共享，提高开发效率</li>
<li>存储在vuex中的数据是响应式的，能够实时保持数据和页面的同步</li>
</ol>
</li>
<li><p>什么样的数据适合存储在vuex中</p>
<ul>
<li>一般情况下，只有组件之间共享的数据，才有必要存储在vuex中；对于组件中的私有数据，依旧存储在组件自身中的data中即可</li>
</ul>
</li>
</ul>
<h2 id="vuex的基本使用"><a href="#vuex的基本使用" class="headerlink" title="vuex的基本使用"></a>vuex的基本使用</h2><ol>
<li><p>安装vuex依赖包</p>
<ul>
<li>npm install vuex –save</li>
</ul>
</li>
<li><p>导入vuex包(在store组件中)</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vuex from &#39;vuex&#39;</span><br><span class="line">vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">const store &#x3D; new Vuex.Store(&#123;</span><br><span class="line">    state:&#123; count:0 &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>将store对象挂载到vue实例中</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39; </span><br><span class="line">import router from&#39;.&#x2F;router&#39;  &#x2F;&#x2F;引入路由器模块</span><br><span class="line">import store from&#39;.&#x2F;store&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建 vue 配置路由器</span><br><span class="line">new Vue(&#123;</span><br><span class="line">el: &#39;#app&#39;, </span><br><span class="line">router:router,</span><br><span class="line">store</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="vuex的核心概念"><a href="#vuex的核心概念" class="headerlink" title="vuex的核心概念"></a>vuex的核心概念</h2><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3></li>
</ol>
<ul>
<li><p>State提供唯一的公共数据源，所有的共享数据都要统一放到Store的State中进行存储</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">        state:&#123; </span><br><span class="line">            &#x2F;&#x2F;共享数据</span><br><span class="line">            count:0</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>如何访问state中数据：</p>
<ol>
<li>方式一：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.$store.state.全局变量名称</span><br></pre></td></tr></table></figure></li>
<li>方式二：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;从vuex中按需导入mapState函数</span><br><span class="line">import &#123;mapState&#125; from &#39;vuex&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通过mapState函数将全局数据映射为当前组件的计算属性</span><br><span class="line">computed：&#123;</span><br><span class="line">    ...mapState([&#39;count&#39;])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h3></li>
</ol>
</li>
<li><p>Mutation用于变更store中的数据</p>
</li>
<li><p>只能通过mutation变更store的数据，不可以直接操作store中的数据</p>
</li>
<li><p>通过这种方式虽然操作起来稍微繁琐一些，但是可以集中监控所有数据的变化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">        state:&#123; </span><br><span class="line">            &#x2F;&#x2F;共享数据</span><br><span class="line">            count:0</span><br><span class="line">         &#125;，</span><br><span class="line">         </span><br><span class="line">         &#x2F;&#x2F; 定义mutation</span><br><span class="line">         mutations:&#123;</span><br><span class="line">             add(state)&#123;</span><br><span class="line">                 &#x2F;&#x2F;变更状态</span><br><span class="line">                 state.count++</span><br><span class="line">             &#125;，</span><br><span class="line"></span><br><span class="line">             &#x2F;&#x2F; 可以在触发mutations时传递参数</span><br><span class="line">             addn(state,step)&#123;</span><br><span class="line">                 &#x2F;&#x2F;变更状态</span><br><span class="line">                 state.count+&#x3D;step</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>触发mutation的方式:</p>
<ol>
<li>方式一<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">    handel()&#123;</span><br><span class="line">        this.$store.commit(&#39;add&#39;)</span><br><span class="line">    &#125;,</span><br><span class="line">    handel2()&#123;</span><br><span class="line">        this.$store.commit(&#39;addn&#39;,3)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>方式二<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;从vuex中按需导入mapState函数</span><br><span class="line">import &#123;mapMutations&#125; from &#39;vuex&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通过mapMutations函数将需要的mutation函数映射为当前组件的methods方法</span><br><span class="line">methods：&#123;</span><br><span class="line">    ...mapMutations([&#39;add&#39;,&#39;addn&#39;])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><ul>
<li><p>action用于处理异步任务</p>
</li>
<li><p>如果通过异步操作变更数据，必须通过action而不是mutation，但是在action中还是要通过触发mutation的方式简介变更数据</p>
</li>
<li><p>actions异步任务（可以携带参数）：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;定义action</span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">    state:&#123; </span><br><span class="line">        &#x2F;&#x2F;共享数据</span><br><span class="line">        count:0</span><br><span class="line">     &#125;，</span><br><span class="line">     </span><br><span class="line">     &#x2F;&#x2F; 定义mutation</span><br><span class="line">     mutations:&#123;</span><br><span class="line">         add(state)&#123;</span><br><span class="line">             &#x2F;&#x2F;变更状态</span><br><span class="line">             state.count++</span><br><span class="line">         &#125;,</span><br><span class="line">         addn(state,step)&#123;</span><br><span class="line">             &#x2F;&#x2F;变更状态</span><br><span class="line">             state.count+&#x3D;step</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">     actions:&#123;</span><br><span class="line">         addnAsync(context,step)&#123;</span><br><span class="line">             setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">                 context.commit(&#39;addn&#39;,5)</span><br><span class="line">             &#125;,1000)</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>触发action的方式:</p>
<ol>
<li>方式一<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">    handle3&#123;</span><br><span class="line">        this.$store.dispatch(&#39;addnAsync&#39;,step)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>方式二<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;从vuex中按需导入mapActions函数</span><br><span class="line">import &#123;mapActions&#125; from &#39;vuex&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通过mapActions函数将需要的mapActions函数映射为当前组件的methods方法</span><br><span class="line">methods：&#123;</span><br><span class="line">    ...mapActions([&#39;addnAsync&#39;])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h3 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h3><ul>
<li>Getter用于对store中的数据进行加工处理形成新数据</li>
<li>Getter不会修改state中的数据，他只起到包装的作用</li>
<li>Getter可以对store中已有的数据进行加工处理之后形成新的数据，类似于vue的计算属性</li>
<li>store中数据发生变化，Getter的数据也会跟着变化<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;定义Getter</span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">        state:&#123; </span><br><span class="line">            count:0 </span><br><span class="line">        &#125;，</span><br><span class="line">        getters:&#123;</span><br><span class="line">            shownum:state&#x3D;&gt;&#123;</span><br><span class="line">                return state.count</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></li>
<li>使用getters<ol>
<li>方式一<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.$store.getters.名称</span><br></pre></td></tr></table></figure></li>
<li>方式二<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;mapGetters&#125; from &#39;vuex&#39;</span><br><span class="line"></span><br><span class="line">computed:&#123;</span><br><span class="line">    ...mapGetters([&#39;shownum&#39;])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h1 id="vue源码分析"><a href="#vue源码分析" class="headerlink" title="vue源码分析"></a>vue源码分析</h1><ul>
<li>源码：GitHub上一个仿vue实现的mvvm库：<a href="https://github.com/DMQ/mvvm" target="_blank" rel="noopener">https://github.com/DMQ/mvvm</a><h2 id="数据代理"><a href="#数据代理" class="headerlink" title="数据代理"></a>数据代理</h2>1)    数据代理: 通过一个对象代理对另一个对象(在前一个对象内部)中属性的操作(读/写)</li>
</ul>
<p>2)    vue 数据代理: 通过 vm 对象来代理 data 对象中所有属性的操作</p>
<p>3)    好处: 更方便的操作 data 中的数据</p>
<p>4)    基本实现流程<br>    1. 通过 Object.defineProperty()给 vm 添加与 data 对象的属性对应的属性描述符<br>    2. 所有添加的属性都包含 getter/setter<br>    3. getter/setter 内部去操作 data 中对应的属性数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">相关于Vue的构造函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MVVM</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将选项对象保存到vm</span></span><br><span class="line">  <span class="keyword">this</span>.$options = options;</span><br><span class="line">  <span class="comment">// 将data对象保存到vm和datq变量中</span></span><br><span class="line">  <span class="keyword">var</span> data = <span class="keyword">this</span>._data = <span class="keyword">this</span>.$options.data;</span><br><span class="line">  <span class="comment">//将vm保存在me变量中</span></span><br><span class="line">  <span class="keyword">var</span> me = <span class="keyword">this</span>;</span><br><span class="line">  <span class="comment">// 遍历data中所有属性</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123; <span class="comment">//key是data的某个属性名 举例属性名: name</span></span><br><span class="line">    <span class="comment">// 对指定属性实现代理</span></span><br><span class="line">    me._proxy(key);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对data进行监视</span></span><br><span class="line">  observe(data, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个用来编译模板的compile对象</span></span><br><span class="line">  <span class="keyword">this</span>.$compile = <span class="keyword">new</span> Compile(options.el || <span class="built_in">document</span>.body, <span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MVVM.prototype = &#123;</span><br><span class="line">  $watch: <span class="function"><span class="keyword">function</span> (<span class="params">key, cb, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Watcher(<span class="keyword">this</span>, key, cb);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对指定属性实现代理</span></span><br><span class="line">  _proxy: <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 保存vm</span></span><br><span class="line">    <span class="keyword">var</span> me = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 给vm添加指定属性名的属性(使用属性描述)</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(me, key, &#123;</span><br><span class="line">      configurable: <span class="literal">false</span>, <span class="comment">// 不能再重新定义</span></span><br><span class="line">      enumerable: <span class="literal">true</span>, <span class="comment">// 可以枚举</span></span><br><span class="line">      <span class="comment">// 当通过vm.name读取属性值时自动调用</span></span><br><span class="line">      <span class="keyword">get</span>: function proxyGetter() &#123;</span><br><span class="line">        <span class="comment">// 读取data中对应属性值返回(实现代理读操作)</span></span><br><span class="line">        <span class="keyword">return</span> me._data[key];</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 当通过vm.name = 'xxx'时自动调用</span></span><br><span class="line">      <span class="keyword">set</span>: function proxySetter(newVal) &#123;</span><br><span class="line">        <span class="comment">// 将最新的值保存到data中对应的属性上(实现代理写操作)</span></span><br><span class="line">        me._data[key] = newVal;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="模板解析"><a href="#模板解析" class="headerlink" title="模板解析"></a>模板解析</h2><h3 id="模板解析的基本流程"><a href="#模板解析的基本流程" class="headerlink" title="模板解析的基本流程"></a>模板解析的基本流程</h3><p>1)    将 el 的所有子节点取出, 添加到一个新建的文档 fragment 对象中<br>2)    对 fragment 中的所有层次子节点递归进行编译解析处理<br>    *    对大括号表达式文本节点进行解析<br>    *    对元素节点的指令属性进行解析<br>    *    事件指令解析<br>    *    一般指令解析</p>
<p>3)    将解析后的 fragment 添加到 el 中显示</p>
<h3 id="大括号表达式解析"><a href="#大括号表达式解析" class="headerlink" title="大括号表达式解析"></a>大括号表达式解析</h3><p>1)    根据正则对象得到匹配出的表达式字符串:  子匹配/RegExp.$1    name<br>2)    从 data 中取出表达式对应的属性值<br>3)    将属性值设置为文本节点的 textContent</p>
<h3 id="事件指令解析"><a href="#事件指令解析" class="headerlink" title="事件指令解析"></a>事件指令解析</h3><p>1)    从指令名中取出事件名<br>2)    根据指令的值(表达式)从 methods 中得到对应的事件处理函数对象<br>3)    给当前元素节点绑定指定事件名和回调函数的 dom 事件监听<br>4)    指令解析完后, 移除此指令属性</p>
<h3 id="一般指令解析"><a href="#一般指令解析" class="headerlink" title="一般指令解析"></a>一般指令解析</h3><p>1)    得到指令名和指令值(表达式)    text/html/class    msg/myClass<br>2)    从 data 中根据表达式得到对应的值<br>3)    根据指令名确定需要操作元素节点的什么属性<br>    *    v-text—textContent 属性<br>    *    v-html—innerHTML 属性<br>    *    v-class–className 属性<br>4)    将得到的表达式的值设置到对应的属性上<br>5)    移除元素的指令属性</p>
<h2 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h2><ul>
<li>一旦更新了 data 中的某个属性数据, 所有界面上直接使用或间接使用了此属性的节点都会更新</li>
</ul>
<h3 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h3><p>1)    数据劫持是 vue 中用来实现数据绑定的一种技术<br>2)    基本思想: 通过 defineProperty()来监视 data 中所有属性(任意层次)数据的变化, 一旦变化就去更新界面</p>
<h3 id="四个重要对象"><a href="#四个重要对象" class="headerlink" title="四个重要对象"></a>四个重要对象</h3><p>1)    Observer<br>    -    用来对 data 所有属性数据进行劫持的构造函数<br>    -    给 data 中所有属性重新定义属性描述(get/set)<br>    -    为 data 中的每个属性创建对应的 dep 对象</p>
<p>2)    Dep(Depend)<br>    -    data 中的每个属性(所有层次)都对应一个 dep 对象<br>    -    创建的时机:<br>        *    在初始化 define data 中各个属性时创建对应的 dep 对象<br>        *    在 data 中的某个属性值被设置为新的对象时<br>    -    对象的结构<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">id, &#x2F;&#x2F; 每个 dep 都有一个唯一的 id</span><br><span class="line">subs &#x2F;&#x2F;包含 n 个对应 watcher 的数组(subscribes 的简写)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>    -    subs 属性说明<br>        *    当 watcher 被创建时, 内部将当前 watcher 对象添加到对应的 dep 对象的 subs 中<br>        *    当此 data 属性的值发生改变时, subs 中所有的 watcher 都会收到更新的通知,从而最终更新对应的界面</p>
<p>3)    Compiler<br>    -    用来解析模板页面的对象的构造函数(一个实例)<br>    -    利用 compile 对象解析模板页面<br>    -    每解析一个表达式(非事件指令)都会创建一个对应的 watcher 对象, 并建立 watcher与 dep 的关系<br>    -    complie 与 watcher 关系: 一对多的关系</p>
<p>4)    Watcher</p>
<ul>
<li>模板中每个非事件指令或表达式都对应一个 watcher 对象</li>
<li>监视当前表达式数据的变化</li>
<li>创建的时机: 在初始化编译模板时</li>
<li>对象的组成<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">vm,	&#x2F;&#x2F;vm 对象</span><br><span class="line">exp, &#x2F;&#x2F;对应指令的表达式</span><br><span class="line">cb, &#x2F;&#x2F;当表达式所对应的数据发生改变的回调函数value, &#x2F;&#x2F;表达式当前的值</span><br><span class="line">depIds &#x2F;&#x2F;表达式中各级属性所对应的 dep 对象的集合对象</span><br><span class="line">&#x2F;&#x2F;属性名为 dep 的 id, 属性值为 dep</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>5)    总结: dep 与 watcher 的关系: 多对多<br>    -    data 中的一个属性对应一个 dep, 一个 dep 中可能包含多个 watcher(模板中有几个表达式使用到了同一个属性)<br>    -    模板中一个非事件表达式对应一个 watcher, 一个 watcher 中可能包含多个 dep(表达式是多层: a.b)<br>    -    数据绑定使用到 2 个核心技术<br>        *    defineProperty()<br>        *    消息订阅与发布</p>
<p><img src="/2020/07/22/Vue/mv.png" alt></p>
<h2 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h2><p>1)    双向数据绑定是建立在单向数据绑定(model==&gt;View)的基础之上的<br>2)    双向数据绑定的实现流程:<br>    - 在解析 v-model 指令时, 给当前元素添加 input 监听<br>    - 当 input 的 value 发生改变时, 将最新的值赋值给当前表达式所对应的 data 属性</p>
<p><strong><em>最后这点源码的解析属实给我看的有点晕，讲的时候能明白，自己再看就又想不通了/(ㄒoㄒ)/~~，还是理解的不够深入</em></strong></p>
<h1 id="other"><a href="#other" class="headerlink" title="other"></a>other</h1><ul>
<li>vue.set<ul>
<li>向对象添加一个新的属性</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>高级框架</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue实战之外卖平台</title>
    <url>/2020/08/02/Vue%E5%AE%9E%E6%88%98%E4%B9%8B%E5%A4%96%E5%8D%96%E5%B9%B3%E5%8F%B0/</url>
    <content><![CDATA[<blockquote>
<p>序<br><br>基于vue实现的一个外卖移动端项目</p>
</blockquote>
<a id="more"></a>
<h1 id="项目展示"><a href="#项目展示" class="headerlink" title="项目展示"></a>项目展示</h1><h2 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h2><p><img src="/2020/08/02/Vue%E5%AE%9E%E6%88%98%E4%B9%8B%E5%A4%96%E5%8D%96%E5%B9%B3%E5%8F%B0/1.png" alt></p>
<h2 id="商家详情页"><a href="#商家详情页" class="headerlink" title="商家详情页"></a>商家详情页</h2><h3 id="菜品列表"><a href="#菜品列表" class="headerlink" title="菜品列表"></a>菜品列表</h3><p><img src="/2020/08/02/Vue%E5%AE%9E%E6%88%98%E4%B9%8B%E5%A4%96%E5%8D%96%E5%B9%B3%E5%8F%B0/2.png" alt><br><img src="/2020/08/02/Vue%E5%AE%9E%E6%88%98%E4%B9%8B%E5%A4%96%E5%8D%96%E5%B9%B3%E5%8F%B0/2.1.png" alt><br><img src="/2020/08/02/Vue%E5%AE%9E%E6%88%98%E4%B9%8B%E5%A4%96%E5%8D%96%E5%B9%B3%E5%8F%B0/2.2.png" alt></p>
<h3 id="购物车"><a href="#购物车" class="headerlink" title="购物车"></a>购物车</h3><p><img src="/2020/08/02/Vue%E5%AE%9E%E6%88%98%E4%B9%8B%E5%A4%96%E5%8D%96%E5%B9%B3%E5%8F%B0/3.png" alt></p>
<h3 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h3><p><img src="/2020/08/02/Vue%E5%AE%9E%E6%88%98%E4%B9%8B%E5%A4%96%E5%8D%96%E5%B9%B3%E5%8F%B0/4.png" alt></p>
<h3 id="商家信息"><a href="#商家信息" class="headerlink" title="商家信息"></a>商家信息</h3><p><img src="/2020/08/02/Vue%E5%AE%9E%E6%88%98%E4%B9%8B%E5%A4%96%E5%8D%96%E5%B9%B3%E5%8F%B0/5.png" alt></p>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p><img src="/2020/08/02/Vue%E5%AE%9E%E6%88%98%E4%B9%8B%E5%A4%96%E5%8D%96%E5%B9%B3%E5%8F%B0/6.png" alt><br><img src="/2020/08/02/Vue%E5%AE%9E%E6%88%98%E4%B9%8B%E5%A4%96%E5%8D%96%E5%B9%B3%E5%8F%B0/6.1.png" alt></p>
<h2 id="登陆注册"><a href="#登陆注册" class="headerlink" title="登陆注册"></a>登陆注册</h2><p><img src="/2020/08/02/Vue%E5%AE%9E%E6%88%98%E4%B9%8B%E5%A4%96%E5%8D%96%E5%B9%B3%E5%8F%B0/7.png" alt><br><img src="/2020/08/02/Vue%E5%AE%9E%E6%88%98%E4%B9%8B%E5%A4%96%E5%8D%96%E5%B9%B3%E5%8F%B0/71.png" alt><br><img src="/2020/08/02/Vue%E5%AE%9E%E6%88%98%E4%B9%8B%E5%A4%96%E5%8D%96%E5%B9%B3%E5%8F%B0/8.png" alt><br><img src="/2020/08/02/Vue%E5%AE%9E%E6%88%98%E4%B9%8B%E5%A4%96%E5%8D%96%E5%B9%B3%E5%8F%B0/81.png" alt></p>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p><img src="/2020/08/02/Vue%E5%AE%9E%E6%88%98%E4%B9%8B%E5%A4%96%E5%8D%96%E5%B9%B3%E5%8F%B0/db1.png" alt><br><img src="/2020/08/02/Vue%E5%AE%9E%E6%88%98%E4%B9%8B%E5%A4%96%E5%8D%96%E5%B9%B3%E5%8F%B0/db2.png" alt><br><img src="/2020/08/02/Vue%E5%AE%9E%E6%88%98%E4%B9%8B%E5%A4%96%E5%8D%96%E5%B9%B3%E5%8F%B0/db3.png" alt></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><ul>
<li><p>页面：vue, vue-router, vue-lazyload, styls</p>
<ul>
<li>router：路由器页面跳转，开发单页应用</li>
<li>lazyload：图片懒加载，从接口获取图片数据有个过程用一个加载动画填补</li>
<li>styls：css预编译器，不过真的不推荐这个，styls是用缩进控制来取代大括号小括号，有时候代码格式化就会导致一些样式失效，还是推荐less，两者语法大同小异</li>
</ul>
</li>
<li><p>插件：better-scroll, swiper, mint-ui, moment</p>
<ul>
<li>Bscroll: 实现页面滑动</li>
<li>swiper：实现轮播图</li>
<li>mint-ui：构建界面</li>
<li>moment：处理日期格式</li>
</ul>
</li>
<li><p>数据：ajax, axios, mock, vuex, postman</p>
<ul>
<li>ajax,axios: 实现前后台交互</li>
<li>mock：模拟数据库，拦截Ajax请求返回自定义格式的数据</li>
<li>vuex：对数据进行全局的统一管理</li>
<li>postman：测试后端接口</li>
</ul>
</li>
</ul>
<h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><ul>
<li>Node+Express <ul>
<li>用express搭建后台路由</li>
</ul>
</li>
<li>Mongodb+Mongoose<ul>
<li>用mongoose操作mongodb数据库</li>
</ul>
</li>
</ul>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p><strong><em>这个项目是跟着视频教程做的，主要是想找个项目练手来巩固一下知识，静态页面是直接拿的别人的，不得不说自己做静态页面还是比较花时间的，以后再找点时间来练练</em></strong><br></p>
<p><strong><em>这次主要是想知道一个全栈项目的具体的工作流程，后端怎么读数据，怎么定义接口。怎么把数据发送出去等等，还有前端怎么实现一些动画效果，怎么拿到数据，怎么对数据进行处理，怎么渲染到页面上等等</em></strong><br></p>
<p><strong><em>这次的项目本来教的是后端从json文件中获取数据，然后我加了一些改动，把json文件数据插到数据库，然后在从数据库里面读取，还有一些从接口里读到的数据，我能实现的，也都搞到数据库里</em></strong><br><br><img src="/2020/08/02/Vue%E5%AE%9E%E6%88%98%E4%B9%8B%E5%A4%96%E5%8D%96%E5%B9%B3%E5%8F%B0/211.png" alt><br><br><strong><em>项目其实最后没有做完，还有支付和订单没有完成，教程也到这里就结束了，以前了解过用支付宝的接口，后面如果有时间的话考虑再把项目完善一下，到这里我也能算上接触到前端的一名小白了吧哈哈哈，虽然还有很多东西没学 ( ╥﹏╥ )</em></strong></p>
<ul>
<li>最后放一个小玩意（这个比较简单就不另写博客<em>★,°</em>:.☆(￣▽￣)/$:<em>.°★</em> 。）<br>(<a href="http://www.xyx6.top:8080/Vuemusic/" target="_blank" rel="noopener">http://www.xyx6.top:8080/Vuemusic/</a>)<br><img src="/2020/08/02/Vue%E5%AE%9E%E6%88%98%E4%B9%8B%E5%A4%96%E5%8D%96%E5%B9%B3%E5%8F%B0/music.png" alt><h1 id="taking-my-time-step-by-step"><a href="#taking-my-time-step-by-step" class="headerlink" title="taking my time,step by step!"></a>taking my time,step by step!</h1></li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>MongoDB</tag>
        <tag>Vue</tag>
        <tag>Vuex</tag>
        <tag>Mongoose</tag>
      </tags>
  </entry>
</search>
